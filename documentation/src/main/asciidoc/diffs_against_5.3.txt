diff --git a/documentation/src/main/asciidoc/contributing/chapter-1-The_Basics.adoc b/documentation/src/main/asciidoc/contributing/chapter-1-The_Basics.adoc
index c8d8124..4e13ea3 100644
--- a/documentation/src/main/asciidoc/contributing/chapter-1-The_Basics.adoc
+++ b/documentation/src/main/asciidoc/contributing/chapter-1-The_Basics.adoc
@@ -3,8 +3,6 @@
 TIP: In this chapter we quickly walk through the basics on contributing; future chapters go into more depth.
 
 == Prequisites
-
-
 |=============
 |Java 1.6|Infinispan is baselined on Java 6.0, and is built and tested using Sun Java 6.0.
 |Maven 3|The Infinispan build uses Maven, and we recommend using Maven 3.
@@ -12,7 +10,7 @@ TIP: In this chapter we quickly walk through the basics on contributing; future
 |=============
 
 
-[[sid-8093993_ContributingtoInfinispan-IssueManagementJIRA]]
+[[sid-68355157_ContributingtoInfinispan-IssueManagementJIRA]]
 
 
 == Issue Management - JIRA
@@ -51,7 +49,7 @@ If you need to create a new issue then follow these steps.
 
 .  Finally, hit _Create_ 
 
-[[sid-8093993_ContributingtoInfinispan-VersioningGuidelines]]
+[[sid-68355157_ContributingtoInfinispan-VersioningGuidelines]]
 
 
 ==== Versioning Guidelines
@@ -82,7 +80,7 @@ Version numbers are defined as MAJOR.MINOR.MICRO.MODIFIER.  For example, 4.1.0.B
 
  If the issue relates to a bug which affected a previous FINAL version, then the Fixed In field should also contain the .FINAL version which contains the fix, in addition to any ALPHA, BETA or CR release.  For example, see link:$$https://issues.jboss.org/browse/ISPN-546$$[ISPN-546] . If the issue pertains to a bug in the current release, then the .FINAL version should not be in the Fixed In field.  For example, a bug found in 4.1.0.ALPHA2 (but not in 4.1.0.ALPHA1) should be marked as fixed in 4.1.0.ALPHA3, but not in 4.1.0.FINAL.  For example, see link:$$https://issues.jboss.org/browse/ISPN-416$$[ISPN-416] . 
 
-[[sid-8093993_ContributingtoInfinispan-SourcecontrolGit]]
+[[sid-68355157_ContributingtoInfinispan-SourcecontrolGit]]
 
 
 === Source control - Git
@@ -105,9 +103,9 @@ $ git clone git@github.com:YOUR_GITHB_USERNAME/infinispan.git
 
 ----
 
- For more information, read <<sid-8093999,the Git chapter>> . 
+ For more information, read <<sid-68355164,the Git chapter>> . 
 
-[[sid-8093993_ContributingtoInfinispan-SettingupyourIDE]]
+[[sid-68355157_ContributingtoInfinispan-SettingupyourIDE]]
 
 
 ==== Setting up your IDE
@@ -116,10 +114,15 @@ Maven supports generating IDE configuration files for easy setup of a project. T
 
 Before we import the project, we need to clone the project as described above.
 
-[[sid-8093993_ContributingtoInfinispan-Eclipse]]
+[[sid-68355157_ContributingtoInfinispan-Eclipse]]
+
 
+==== Eclipse
 
-===== Eclipse
+[[sid-68355157_ContributingtoInfinispan-]]
+
+
+===== 
 
 
 .  Install the m2eclipse plugin if you have not already installed it. Eclipse is including it since version "Indigo" 3.7, for older versions follow instructions at link:$$http://eclipse.org/m2e/$$[] . 
@@ -157,95 +160,125 @@ image::[]
 .TODO InformalFigure image title empty
 image::[]
 
- Code Formatting. From the menu Window-&gt;Preferences-&gt; select Java -&gt; Code Style -&gt; Formatter. Import link:$$https://github.com/infinispan/infinispan/blob/master/ide-settings/eclipse/formatter.xml$$[formatter.xml] Code template. From the menu Window-&gt;Preferences-&gt; select Java -&gt; Code Style -&gt;  Code Templates. Import link:$$https://github.com/infinispan/infinispan/blob/master/ide-settings/eclipse/codetemplates.xml$$[codetemplates.xml] 
+ Code Formatting. From the menu Window-&gt;Preferences-&gt; select Java -&gt; Code Style -&gt; Formatter. Import link:$$https://raw.github.com/infinispan/infinispan/master/ide-settings/eclipse/formatter.xml$$[formatter.xml] Code template. From the menu Window-&gt;Preferences-&gt; select Java -&gt; Code Style -&gt;  Code Templates. Import link:$$https://raw.github.com/infinispan/infinispan/master/ide-settings/eclipse/codetemplates.xml$$[codetemplates.xml] 
 
- As some modules use Scala, it's worth installing the link:$$http://www.scala-lang.org/node/94$$[Scala tools] . 
+ Some modules use Scala, if you plan contributing to one of these modules it's worth installing the link:$$http://www.scala-lang.org/node/94$$[Scala tools] . 
 
-[[sid-8093993_ContributingtoInfinispan-IntelliJIDEA]]
+[[sid-68355157_ContributingtoInfinispan-IntelliJIDEA]]
 
 
 ===== IntelliJ IDEA
 
-IntelliJ's built-in Maven support is the best way to go. From IntelliJ 9 onwards, this is a robust and reliable mechanism to import a project from Maven.
+[[sid-68355157_ContributingtoInfinispan-Importing]]
 
 
-. Create a new project in IntelliJ
+===== =Importing
 
- 
-.TODO InformalFigure image title empty
+
+*  When you start IntelliJ, you will be greeted by a screen as shown below: 
+.TODO Gliffy image title empty
 image::[]
 
  
 
 
-. And choose to import the project from an external model
+*  If you have already obtained a copy of the Infinispan sources via Github (see _'Source Control'_ ), then simply follow: _Import Project -&gt; /directory/to/downloaded/sources_ . IntelliJ will automatically make use of maven to import the project since it will detect a _pom.xml_ file in the base directory. 
+
+
+*  If you have not obtained the sources already, you can simply use the Git integration provided within IntelliJ 12. Click on _Check out from Version Control -&gt; Github_ . After entering your Github credentials, you will then be prompted to enter the git repository URL along with the location that you want to check out the source code to. 
+
 
- 
 .TODO InformalFigure image title empty
 image::[]
 
+[[sid-68355157_ContributingtoInfinispan-Compilersettings]]
+
+
+===== =Compiler settings
+
+
+* From Infinispan 5.0 onwards, annotation processing is used to allow log messages to be internationalized. This processing can be done directly from IntelliJ as part of compilation but it requires some set up:
+
+
+*  Go to "Preferences/Compiler/Annotation Processor" and click on _Enable annotation processing_ 
+
+
+*  Add an annotation processor with "Processor FQN Name" as org.jboss.logging.LoggingToolsProcessor 
+
+
+*  In "Processed Modules", add all modules except the root and the parent modules. 
+.TODO Gliffy image title empty
+image::[]
+
  
 
 
-. When asked, point the wizard to the directory created when you cloned the repository
+*  There can sometimes be issues with the generated logging classes on rebuild (particularly when you switch Git branches). If these issues do crop up then simply run _mvn clean install -DskipTests=true_ on the command line to clear them out. 
 
 
-. Make sure that the check-boxes for "Search for projects recursively" and "Create module groups for multi-module Maven projects" are checked.
+*  _EXTRA:_ If you are running a multi-core environment (e.g. quad-core or above) then you can follow the instructions on making use of parallelized compilation in IntelliJ 12. Information on how to do this can be found link:$$http://blogs.jetbrains.com/idea/2012/12/intellij-idea-12-compiler-twice-as-fast/$$[here] . 
 
+[[sid-68355157_ContributingtoInfinispan-ScalaPlugin]]
 
-. Just follow through the rest of the steps in the wizard and you're good to go.
 
+===== =Scala Plugin
 
-. Finally, from Infinispan 5.0 onwards, annotation processing is used to allow log messages to be internationalized. This processing can be done directly from IntelliJ as part of compilation but it requires some set up:
 
+*  You will need to download the Scala plugin for IntelliJ as well. This can be done by: _Project Settings -&gt; Plugins -&gt; Browse Repositories_ . Then run a search for 'Scala'. JetBrains themselves are the vendor for this plugin and more information on it can be found link:$$http://confluence.jetbrains.net/display/SCA/Scala+Plugin+for+IntelliJ+IDEA$$[here] . 
 
-*  Go to "Preferences/Compiler/Annotation Processor" and click on _Enable annotation processing_ 
 
+.TODO InformalFigure image title empty
+image::[]
 
-*  Add an annotation processor with "Processor FQN Name" as org.jboss.logging.LoggingToolsProcessor 
 
+*  You also have to configure the Scala plugin to use the Scala compiler for Scala files and the Java compiler for Java files. You can do this by going into _Settings -&gt; Compiler -&gt; Scala Compiler_ . Be sure to add the scala compiler bundle as shown in the screenshot below. 
 
-* In "Processed Modules", add all modules except the root and the parent modules.
 
- 
 .TODO InformalFigure image title empty
 image::[]
 
- 
+[[sid-68355157_ContributingtoInfinispan-x]]
+
+
+===== =
+
+[[sid-68355157_ContributingtoInfinispan-CodeStyle]]
 
-IntelliJ has built in Scala support, just make sure the Scala module is installed.
 
- IntelliJ related code style jar is at link:$$https://github.com/infinispan/infinispan/blob/master/ide-settings/intellij/IntelliJ_IDEA_Code_Style.jar$$[idea-code-style.jar] 
+===== =Code Style
 
-[[sid-8093993_ContributingtoInfinispan-BuildMaven]]
+
+*  You can find the code style .jar file for IntelliJ in the Infinispan source download. It is located in _/path/to/infinispan/home/ide-settings/intellij_ . 
+
+[[sid-68355157_ContributingtoInfinispan-BuildMaven]]
 
 
 === Build - Maven
 
- Infinispan uses link:$$http://maven.apache.org/$$[Maven] for builds. Make sure you have Maven 3 installed, and properly configured. For more information, read <<sid-8093999,the Maven chapter>> . 
+ Infinispan uses link:$$http://maven.apache.org/$$[Maven] for builds. Make sure you have Maven 3 installed, and properly configured. For more information, read link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=4784481$$[the Maven chapter] . 
 
-[[sid-8093993_ContributingtoInfinispan-ContinuousIntegrationJenkinsonCloudbees]]
+[[sid-68355157_ContributingtoInfinispan-ContinuousIntegrationTeamCity]]
 
 
-==== Continuous Integration - Jenkins on Cloudbees
+==== Continuous Integration - TeamCity
 
- Infinispan uses Jenkins on Cloudbees for continuous integration. Jenkins polls GitHub for updates and runs whenever updates are available. For more information view link:$$http://www.jboss.org/infinispan/build.html$$[the project site] . 
+ Infinispan link:$$http://www.jetbrains.com/teamcity$$[TeamCity] for continuous integration. TeamCity polls GitHub for updates and runs whenever updates are available. You can check the status of the latest builds link:$$http://ci.infinispan.org/overview.html$$[here] . 
 
-[[sid-8093993_ContributingtoInfinispan-TestingTestNG]]
+[[sid-68355157_ContributingtoInfinispan-TestingTestNG]]
 
 
 === Testing - TestNG
 
- Infinispan uses TestNG for unit and functional tests, and all Infinispan tests are run in parallel. For more information see <<sid-8093995,the Test Suite chapter>> ; this chapter gives advice on writing tests which can safely execute in parallel. 
+ Infinispan uses TestNG for unit and functional tests, and all Infinispan tests are run in parallel. For more information see <<sid-68355159,the Test Suite chapter>> ; this chapter gives advice on writing tests which can safely execute in parallel. 
 
-[[sid-8093993_ContributingtoInfinispan-CommunicatingwithotherInfinispancontributors]]
+[[sid-68355157_ContributingtoInfinispan-CommunicatingwithotherInfinispancontributors]]
 
 
 === Communicating with other Infinispan contributors
 
  Infinispan contributors use a mix of link:$$http://www.jboss.org/infinispan/mailinglists$$[mailings lists] and link:$$http://www.jboss.org/infinispan/community.html$$[IRC] to communicate ideas and designs, with more detailed designs often making their way into link:$$http://community.jboss.org/$$[wiki pages] . 
 
-[[sid-8093993_ContributingtoInfinispan-StyleRequirements]]
+[[sid-68355157_ContributingtoInfinispan-StyleRequirements]]
 
 
 === Style Requirements
@@ -262,39 +295,41 @@ IntelliJ has built in Scala support, just make sure the Scala module is installe
 
  All patches or code committed must adhere to this style. Code style settings which can be imported into IntelliJ IDEA and Eclipse are committed in the project sources, in link:$$https://github.com/infinispan/infinispan/blob/master/ide-settings/$$[ide-settings] . 
 
-[[sid-8093993_ContributingtoInfinispan-Spelling]]
+[[sid-68355157_ContributingtoInfinispan-Spelling]]
 
 
 ==== Spelling
 
  Ensure correct spelling in code, comments, Javadocs, etc. (use _American English_ spelling). It is recommended that you use a spellchecker plugin for your IDE. 
 
-[[sid-8093993_ContributingtoInfinispan-Licenseheader]]
+[[sid-68355157_ContributingtoInfinispan-Licenseheader]]
 
 
 ==== License header
 
  All source files must have up-to-date license headers as described in link:$$http://community.jboss.org/docs/16352$$[Copyright Ownership and Licenses] . Never remove existing headers or copyrights. 
 
-[[sid-8093993_ContributingtoInfinispan-Checkincomments]]
+[[sid-68355157_ContributingtoInfinispan-Checkincomments]]
 
 
 ==== Check-in comments
 
- Please ensure any commit comments use link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=8094053_InfinispanandGitHub-Comments$$[this format] if related to a task or issue in JIRA. This helps JIRA pick out these checkins and display them on the issue, making it very useful for back/forward porting fixes. If your comment does not follow this format, your commit may not be merged into upstream. 
+ Please ensure any commit comments use link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=68355224_InfinispanandGitHub-Comments$$[this format] if related to a task or issue in JIRA. This helps JIRA pick out these checkins and display them on the issue, making it very useful for back/forward porting fixes. If your comment does not follow this format, your commit may not be merged into upstream. 
 
-[[sid-8093993_ContributingtoInfinispan-Configuration]]
+[[sid-68355157_ContributingtoInfinispan-Configuration]]
 
 
 === Configuration
 
- Infinispan offers both programmatic configuration and XML configuration. For more information read the <<sid-8094000,Configuration>> chapter. 
+ Infinispan offers both programmatic configuration and XML configuration. For more information read the <<sid-68355165,Configuration>> chapter. 
 
-[[sid-8093993_ContributingtoInfinispan-Logging]]
+[[sid-68355157_ContributingtoInfinispan-Logging]]
 
 
 === Logging
 
+ Infinispan follows the JBoss logging standards, which can be found link:$$https://community.jboss.org/wiki/LoggingStandards$$[here] . 
+
  From Infinispan 5.0 onwards, Infinispan uses JBoss Logging to abstract over the logging backend. Infinispan supports localization of log message for categories of INFO or above as explained in link:$$http://community.jboss.org/docs/16738$$[the JBoss Logging guidelines] . As a developer, this means that for each INFO , WARN , ERROR , FATAL message your code emits, you need to modify the Log class in your module and add an explicit method for it with the right annotations. For example: 
 
 
@@ -323,7 +358,7 @@ The last thing to figure out is which id to give to the message. Each module tha
 |===============
 |Module name|Id range
 |core|1 - 1000
-|tree|1001 - 2000
+|tree|2001 - 3000
 |bdbje cache store|2001 - 3000
 |cassandra cache store|3001 - 4000
 |hotrod client|4001 - 5000
@@ -339,6 +374,14 @@ The last thing to figure out is which id to give to the message. Each module tha
 |query|14001 - 15000
 |lucene directory|15001 - 16000
 |rhq plugin|16001 - 17000
+|cdi integration|17001 - 18000
+| hbase cache store | 18001 - 19000 
+| cli interpreter | 19001 - 20000 
+| cli client | 20001 - 21000 
+|mongodb cache store|21001 - 22000
+|jpa cache store|22001 - 23000
+|leveldb cache store|23001 - 24000
+|couchbase cache store|24001 - 25000
 
 |===============
 
@@ -346,6 +389,15 @@ The last thing to figure out is which id to give to the message. Each module tha
 
 [NOTE]
 ==== 
+When editing the above table, remember to update the README-i18n.txt file in the project sources!
+
+
+==== 
+
+
+
+[NOTE]
+==== 
 You will need to enable annotation processing in order to be able to compile Infinispan and have the logger implementation generated.
 
 
diff --git a/documentation/src/main/asciidoc/contributing/chapter-2-Source_Control.adoc b/documentation/src/main/asciidoc/contributing/chapter-2-Source_Control.adoc
index 3315375..e756836 100644
--- a/documentation/src/main/asciidoc/contributing/chapter-2-Source_Control.adoc
+++ b/documentation/src/main/asciidoc/contributing/chapter-2-Source_Control.adoc
@@ -1,24 +1,24 @@
-[[sid-8093993_ContributingtoInfinispan-SourceControl]]
+[[sid-68355157_ContributingtoInfinispan-SourceControl]]
 
 ==  Source Control
 
 
 [NOTE]
 ==== 
- As a convention, _upstream_ is used as the name of the link:$$http://github.com/infinispan/infinispan$$[] repository. This repository is the canonical repository for Infinispan. 
+ As a convention, _upstream_ is used as the name of the link:$$http://github.com/infinispan/infinispan$$[] repository. This repository is the canonical repository for Infinispan. We usually name _origin_ the fork on github of each contributor. So the exact meaning of _origin_ is relative to the developer: you could think of _origin_ as your own fork. 
 
 
 ==== 
 
 
-[[sid-8093993_ContributingtoInfinispan-Prerequisitesx]]
+[[sid-68355157_ContributingtoInfinispan-Prerequisitesx]]
 
 
 === requisites
 
- This document assumes some working knowledge of git. We recommend Scott Chacon's excellent link:$$http://progit.org/$$[Pro Git] as a valuable piece of background reading. The book is released under the Creative Commons license and can be downloaded in electronic form for free At very least, we recommend that link:$$http://progit.org/book/ch2-0.html$$[Chapter 2] , link:$$http://progit.org/book/ch3-0.html$$[Chapter 3] and link:$$http://progit.org/book/ch5-0.html$$[Chapter 5] of Pro Git are read before proceeding. 
+ This document assumes some working knowledge of git. We recommend Scott Chacon's excellent link:$$http://progit.org/$$[Pro Git] as a valuable piece of background reading. The book is released under the Creative Commons license and can be downloaded in electronic form for free. At very least, we recommend that link:$$http://progit.org/book/ch2-0.html$$[Chapter 2] , link:$$http://progit.org/book/ch3-0.html$$[Chapter 3] and link:$$http://progit.org/book/ch5-0.html$$[Chapter 5] of Pro Git are read before proceeding. 
 
-[[sid-8093993_ContributingtoInfinispan-Repositories]]
+[[sid-68355157_ContributingtoInfinispan-Repositories]]
 
 
 === Repositories
@@ -27,7 +27,7 @@
 
  Typically, only _Project Admins_ would be able to push to this repo while all else may clone or fork this repo. 
 
-[[sid-8093993_ContributingtoInfinispan-Roles]]
+[[sid-68355157_ContributingtoInfinispan-Roles]]
 
 
 === Roles
@@ -52,7 +52,7 @@ None of the roles assume that you are a Red Hat employee.  All it assumes is ho
 ==== 
 
 
-[[sid-8093993_ContributingtoInfinispan-OccasionalContributor]]
+[[sid-68355157_ContributingtoInfinispan-OccasionalContributor]]
 
 
 ==== Occasional Contributor
@@ -76,7 +76,7 @@ A GitHub pull request is the preferred method to submit a patch!
 ==== 
 
 
-[[sid-8093993_ContributingtoInfinispan-AttachapatchfiletotheJIRAissue]]
+[[sid-68355157_ContributingtoInfinispan-AttachapatchfiletotheJIRAissue]]
 
 
 ===== Attach a patch file to the JIRA issue
@@ -94,13 +94,13 @@ In this workflow, the contributor directly clones the upstream repository, makes
 
 [NOTE]
 ==== 
-Rather than emailing the patches to a developer mail list as suggested by Pro Git, please attach your patch to the JIRA issue.
+Rather than emailing the patches to a developer mail list, please attach your patch to the JIRA issue.
 
 
 ==== 
 
 
-[[sid-8093993_ContributingtoInfinispan-CreatingapullrequestonGitHub]]
+[[sid-68355157_ContributingtoInfinispan-CreatingapullrequestonGitHub]]
 
 
 ===== Creating a pull request on GitHub
@@ -117,7 +117,7 @@ image::[]
 [NOTE]
 .Topic Branches
 ==== 
- It is desirable to work off a _topic branch_ , even when using your own, forked repository. A topic branch is created for every feature or bug fix you do. Typically you would create one topic branch per issue.  
+ It is desirable to work off a _topic branch_ , even when using your own, forked repository. A topic branch is created for every feature or bug fix you do. Typically you would create one topic branch per issue, but if several patches are related it's acceptable to have several commits in the same branch; however different changes should always be identified by different commits.  
 
 
 ==== 
@@ -127,13 +127,13 @@ Before you push your work onto your fork of the repository, it is often a good i
 
  The section on _Public Small Project_ in link:$$http://progit.org/book/ch5-2.html$$[Chapter 5, Section 2] of Pro Git has more information on this style of workflow. 
 
-[[sid-8093993_ContributingtoInfinispan-Aworkedexample]]
+[[sid-68355157_ContributingtoInfinispan-Aworkedexample]]
 
 
 ===== =A worked example
 
 
-.  Make sure your master is synced up with upstream. See <<sid-8093993_ContributingtoInfinispan-Ifyouhaveforkedupstream,this section>> for how to do this 
+.  Make sure your master is synced up with upstream. See <<sid-68355157_ContributingtoInfinispan-Ifyouhaveforkedupstream,this section>> for how to do this 
 
 
 . Create new branch for your topic and switch to it. For the example issue, ISPN-1234:
@@ -171,12 +171,18 @@ git branch -d ISPN-12345 && git push origin :ISPN-12345
 
 . Sync with upstream again so that your changes now appear in your master branch
 
-If your topic branch has been open for a while and you are afraid changes upstream may clash with your changes, it may make sense to rebase your topic branch before you issue a pull request. To do this:
+If your topic branch has been open for a while and you are afraid changes upstream may clash with your changes, it makes sense to rebase your topic branch before you issue a pull request. To do this:
 
 
 . Sync your master branch with upstream
 
 
+----
+git checkout master
+git pull upstream master
+----
+
+
 . Switch to your topic branch. For example:
 
 
@@ -193,10 +199,13 @@ git rebase master
 ----
 
 
-. Test, test, test!
+. During the rebase process you might need to fix conflicts;
 
 
-.  Push your rebased topic branch to your repo on GitHub (you may need to force this with the -f option). 
+. when you're done test your code again.
+
+
+.  Push your rebased topic branch to your repo on GitHub (you will likely need to force this with the -f option). 
 
 
 ----
@@ -209,22 +218,22 @@ git push -f origin ISPN-12345
 
 [TIP]
 ==== 
-If you are sharing your forked Infinispan repo with others, then do not rebase!  Use a merge instead.
+If you are sharing your forked Infinispan repo with others, then do not rebase! Use a merge instead.
 
 
 ==== 
 
 
-[[sid-8093993_ContributingtoInfinispan-Multistepcoordinationbetweendevelopersusingforkedrepositories]]
+[[sid-68355157_ContributingtoInfinispan-Multistepcoordinationbetweendevelopersusingforkedrepositories]]
 
 
 ===== Multi-step coordination between developers using forked repositories
 
-Sometimes a feature/task is rather complex to implement and requires competence from multiple areas of the projects. In such occasions it is not uncommon for developers to coordinate feature implementation using personal forks of Infinispan repo prior to finally issuing request to integrate into Infinispan main repository on GitHub.
+Sometimes a feature/task is rather complex to implement and requires competence from multiple areas of the projects. In such occasions it is not uncommon for developers to coordinate feature implementation using personal forks of Infinispan prior to finally issuing request to integrate into Infinispan main repository on GitHub.
 
 For example, developer A using his personal Infinispan fork creates a topic branch T and completes as much work as he/she can before requesting for assistance from developer B. Developer A pushes topic T to his personal Infinispan fork where developer B picks it up and brings it down to his local repo. Developer B then in turn completes necessary work, commits his/her changes on branch T, and finally pushes back T to his own personal fork. After issuing request for pull to developer A, developer B waits for notification that developer A integrated his changes. This exchange can be repeated as much as it is necessary and can involve multiple developers.
 
-[[sid-8093993_ContributingtoInfinispan-Aworkedexamplex]]
+[[sid-68355157_ContributingtoInfinispan-Aworkedexamplex]]
 
 
 ===== =A worked example
@@ -234,7 +243,7 @@ For example, developer A using his personal Infinispan fork creates a topic bran
 
 ----
 
-git remote add devA https://github.com/developerA/infinispan.git]
+git remote add devA https://github.com/developerA/infinispan.git
 
 ----
 
@@ -268,25 +277,25 @@ git push origin my_ispn244
 
 .  Developer B sends pull request to developer A to integrate changes from my_ispn244 to ispn244 
 
-[[sid-8093993_ContributingtoInfinispan-FrequentContributor]]
+[[sid-68355157_ContributingtoInfinispan-FrequentContributor]]
 
 
 ==== Frequent Contributor
 
 A frequent contributor will only ever submit patches via a pull requests. The pull request will be submitted via GitHub.
 
- Frequent contributors should _always_ fork the upstream project on GitHub and work off a clone of this fork. This is very similar to <<sid-8093993_ContributingtoInfinispan-CreatingapullrequestonGitHub,Creating a pull request on GitHub>> workflow used by a <<sid-8093993_ContributingtoInfinispan-OccasionalContributor,Occasional Contributor>> . 
+ Frequent contributors should _always_ fork the upstream project on GitHub and work off a clone of this fork. This is very similar to <<sid-68355157_ContributingtoInfinispan-CreatingapullrequestonGitHub,Creating a pull request on GitHub>> workflow used by a <<sid-68355157_ContributingtoInfinispan-OccasionalContributor,Occasional Contributor>> . 
 
 
 [NOTE]
 ==== 
-All Infinispan core developers are considered frequent contributors and work off personal forks of the upstream repository.  This allows for complex features to be developed in parallel without tripping up over one another.  This process is certainly not restricted to just Infinispan core developers; any contributor may also participate in this manner.
+All Infinispan core developers are considered frequent contributors and work off personal forks of the upstream repository. This allows for complex features to be developed in parallel without tripping up over one another. This process is certainly not restricted to just Infinispan core developers; any contributor is welcome to also participate in this manner.
 
 
 ==== 
 
 
-[[sid-8093993_ContributingtoInfinispan-ProjectAdmin]]
+[[sid-68355157_ContributingtoInfinispan-ProjectAdmin]]
 
 
 ==== Project Admin
@@ -302,9 +311,9 @@ All Contributors who are also Project Admins are encouraged to not merge their o
 ==== 
 
 
-This approach ensures Infinispan maintains quality on the main code source tree, and allows for important code reviews to take place again ensuring quality. Further, it ensures clean and easily traceable code history.
+This approach ensures Infinispan maintains quality on the main code source tree, and allows for important code reviews to take place again ensuring quality. Further, it ensures clean and easily traceable code history and makes sure that more than one person knows about the changes being performed.
 
-[[sid-8093993_ContributingtoInfinispan-Merginginpatches]]
+[[sid-68355157_ContributingtoInfinispan-Merginginpatches]]
 
 
 ===== Merging in patches
@@ -319,7 +328,7 @@ Patches submitted via JIRA are audited and promoted to the upstream repository a
 
  More information on applying patches can be found in link:$$http://progit.org/book/ch5-3.html$$[Chapter 5, Section 3] of Pro Git, under _Applying Patches From Email._ 
 
-[[sid-8093993_ContributingtoInfinispan-Handlingpullrequests]]
+[[sid-68355157_ContributingtoInfinispan-Handlingpullrequests]]
 
 
 ===== Handling pull requests
@@ -353,26 +362,60 @@ $ git reset cb4e5d6  # revert the bad merge
 
  More information on pulling changes from remote, forked repos can be found in link:$$http://progit.org/book/ch5-3.html$$[Chapter 5, Section 3] of Pro Git, under _Checking Out Remote Branches_ . 
 
-[[sid-8093993_ContributingtoInfinispan-Cuttingreleases]]
+[[sid-68355157_ContributingtoInfinispan-Possibletroublehandlingpullrequests]]
+
+
+===== =Possible trouble handling pull requests
+
+
+. If you have warnings about "Merge made by recursive" you have to fix it rebasing.
+
+
+. If you have warnings about "non-fast-forward" you have to rebase.
+
+
+. If you see "non-fast-forward updates were rejected" you shall never use "force" on upstream! It means that another patch was merged before you and you have to update your master again, and rebase again.
+
+
+. "force" is allowed only in special maintenance circumstances. If you find you're needing it to handle a pull request, then you're doing it wrong, and the mistake might be a dangerous one! It's like the good rule of never commit when you're drunk (coding is allowed).
+
+
+[WARNING]
+.Never use force on git push
+==== 
+ Using _-f_ while pushing on a shared repository such as _upstream_ you could effectively erase other committed patches. Noone shall ever use this option unless unanimously approved on the public mailing list: the most dangerous aspect of it is that nobody gets any notification if this happens, and we might think issues are solved but you silently removed the fix and it's history from the repository. 
+
+
+==== 
+
+
+[[sid-68355157_ContributingtoInfinispan-Cuttingreleases]]
 
 
 ===== Cutting releases
 
 Releases can only me cut by Project Admins, and must be done off a recently updated (git fetch and git pull origin) clone of the upstream repo. Infinispan's release.py script takes care of the rest.
 
-[[sid-8093993_ContributingtoInfinispan-Committingyourwork]]
+[[sid-68355157_ContributingtoInfinispan-ContributorLicenseAgreement%28CLA%29]]
+
+
+=== Contributor License Agreement (CLA)
+
+ Contributors that submit patches to Infinispan, if they're not employed by Red Hat, are required to sign the _Contributor License Agreement (CLA)_ following the instructions in link:$$https://cla.jboss.org/index.seam$$[our dedicated site] . 
+
+[[sid-68355157_ContributingtoInfinispan-Committingyourwork]]
 
 
 === Committing your work
 
-[[sid-8093993_ContributingtoInfinispan-Releasebranches]]
+[[sid-68355157_ContributingtoInfinispan-Releasebranches]]
 
 
 ==== Release branches
 
-Infinispan has 4 main release branches.  These are master (ongoing work on the 5.0.x series), 4.2.x (ongoing work on the 4.2.x series), 4.1.x and 4.0.x (respective maintenance branches). Work should never be committed directly to any of these release branches; topic branches should always be used for work, and these topic branches should be merged in.
+Infinispan has 4 main release branches. These are master (ongoing work on the 5.0.x series), 4.2.x (ongoing work on the 4.2.x series), 4.1.x and 4.0.x (respective maintenance branches). Work should never be committed directly to any of these release branches; topic branches should always be used for work, and these topic branches should be merged in.
 
-[[sid-8093993_ContributingtoInfinispan-Topicbranches]]
+[[sid-68355157_ContributingtoInfinispan-Topicbranches]]
 
 
 ==== Topic branches
@@ -381,7 +424,7 @@ Some of the biggest features of git are speed and efficiency of branching, and a
 
  link:$$http://progit.org/book/ch3-4.html$$[Chapter 3, Section 4] of Pro Git has a detailed discussion of topic branches. For Infinispan, it makes sense to create a topic branch and name it after the JIRA it corresponds to. (if it doesn't correspond to a JIRA, a simple but descriptive name should be used). 
 
-[[sid-8093993_ContributingtoInfinispan-TopicBranchesAffectingMoreThanOneReleaseBranch]]
+[[sid-68355157_ContributingtoInfinispan-TopicBranchesAffectingMoreThanOneReleaseBranch]]
 
 
 ===== Topic Branches Affecting More Than One Release Branch
@@ -408,7 +451,7 @@ git checkout -b <topic>_master master
 *  Do your work on &lt;topic&gt;_master , test and commit your fixes 
 
 
-* Switch to {{&lt;topic&gt;_4.2.x}. For example:
+*  Switch to &lt;topic&gt;_4.2.x . For example: 
 
 
 ----
@@ -429,7 +472,7 @@ git cherry-pick <commit_id>
 
 * Issue pull requests for both topic branches
 
-[[sid-8093993_ContributingtoInfinispan-Comments]]
+[[sid-68355157_ContributingtoInfinispan-Comments]]
 
 
 ==== Comments
@@ -438,10 +481,10 @@ git cherry-pick <commit_id>
 
 
 ----
-ISPN-XXX - Subject line of the JIRA in question
+ISPN-XXX Subject line of the JIRA in question
 ----
 
-This should be followed by a detailed explanation of the commit.  Why it was done, how much of it. was completed, etc. You may wish to express this as a list, for example:
+This can optionally be followed by a detailed explanation of the commit. Why it was done, how much of it was completed, etc. You may wish to express this as a list, for example:
 
 
 ----
@@ -453,27 +496,25 @@ This should be followed by a detailed explanation of the commit.  Why it was do
 
 ----
 
-[[sid-8093993_ContributingtoInfinispan-Commits]]
+Make sure however to split separate concerns - especially if they are unrelated - in separate commits.
 
+[[sid-68355157_ContributingtoInfinispan-Commits]]
 
-==== Commits
 
- Sometimes work on your topic branch may include several commits. For example, committing a test. Then committing another test. Then perhaps committing a fix. And perhaps fixing the fix in the next commit 
-.TODO Gliffy image title empty
-image::[]
+==== Commits
 
- . Before issuing a pull request for this topic branch, consider cleaning up these commits. Interactive rebasing helps you squash several commits into a single commit, which is often more coherent to deal with for others merging in your work. link:$$http://progit.org/book/ch6-4.html$$[Chapter 6, Section 4] of Pro Git has details on how to squash commits and generally, clean up a series of commits before sharing this work with others. 
+ Sometimes work on your topic branch may include several commits. For example, committing a test. Then committing another test. Then perhaps committing a fix. And perhaps fixing your own fix in the next commit... Before issuing a pull request for this topic branch, consider cleaning up these commits. Interactive rebasing helps you squash several commits into a single commit, which is often more coherent to deal with for others merging in your work. link:$$http://progit.org/book/ch6-4.html$$[Chapter 6, Section 4] of Pro Git has details on how to squash commits and generally, clean up a series of commits before sharing this work with others. Note that you can also easily reorder them, just change the order of lines during the interactive rebase process. 
 
  Also, it is important to make sure you don't accidentally commit files for which no real changes have happened, but rather, whitespace has been modified. This often happens with some IDEs. git diff --check should be run before you issue such a pull request, which will check for such "noise" commits and warn you accordingly. Such files should be reverted and not be committed to the branch. 
 
- Further, adhering to <<sid-8093994_Contributing-TheBasics-StyleRequirements,Infinispan's code style>> guidelines will help minimise "noise" commits. Project Admins should feel free to ask contributors to reformat their code if necessary. 
+ Adhering to <<sid-68355158_Contributing-TheBasics-StyleRequirements,Infinispan's code style>> guidelines will help minimise "noise" commits. Project Admins are going to ask contributors to reformat their code if necessary. 
 
-[[sid-8093993_ContributingtoInfinispan-Keepingyourrepoinsyncwithupstream]]
+[[sid-68355157_ContributingtoInfinispan-Keepingyourrepoinsyncwithupstream]]
 
 
 === Keeping your repo in sync with upstream
 
-[[sid-8093993_ContributingtoInfinispan-Ifyouhaveclonedupstream]]
+[[sid-68355157_ContributingtoInfinispan-Ifyouhaveclonedupstream]]
 
 
 ==== If you have cloned upstream
@@ -500,7 +541,7 @@ $ git pull origin 4.2.x
 
 ----
 
-[[sid-8093993_ContributingtoInfinispan-Updatingtopicbranches]]
+[[sid-68355157_ContributingtoInfinispan-Updatingtopicbranches]]
 
 
 ===== Updating topic branches
@@ -525,7 +566,7 @@ $ git rebase 4.2.x
 
 ----
 
-[[sid-8093993_ContributingtoInfinispan-Ifyouhaveforkedupstream]]
+[[sid-68355157_ContributingtoInfinispan-Ifyouhaveforkedupstream]]
 
 
 ==== If you have forked upstream
@@ -539,7 +580,7 @@ $ git remote add upstream git://github.com/infinispan/infinispan.git
 
 ----
 
- You should now be able to fetch and pull changes from upstream into your local repo, though you should make sure you have no uncommitted changes. (You _do_ use topic branches, right?) 
+ You should now be able to fetch and pull changes from upstream into your local repository, though you should make sure you have no uncommitted changes. (You _do_ use topic branches, right?) 
 
 
 ----
@@ -557,7 +598,7 @@ $ git push origin 4.2.x
 
  A script can do this for you - have a look at link:$$https://github.com/maniksurtani/githelpers/blob/master/contributors/sync_with_upstream$$[sync_with_upstream] . 
 
-[[sid-8093993_ContributingtoInfinispan-Updatingtopicbranchesx]]
+[[sid-68355157_ContributingtoInfinispan-Updatingtopicbranchesx]]
 
 
 ===== Updating topic branches
@@ -584,12 +625,12 @@ $ git rebase 4.2.x
 
 The sync_with_upstream script can do this for you if your topic branch naming conventions match the script.
 
-[[sid-8093993_ContributingtoInfinispan-Tipsonenhancinggit]]
+[[sid-68355157_ContributingtoInfinispan-Tipsonenhancinggit]]
 
 
 === Tips on enhancing git
 
-[[sid-8093993_ContributingtoInfinispan-Autocompletions]]
+[[sid-68355157_ContributingtoInfinispan-Autocompletions]]
 
 
 ==== completions
@@ -609,7 +650,7 @@ source ~/.git-completion.bash
 
  Note that you get git autocompletion for free if you use link:$$http://zsh.sourceforge.net/$$[zsh] instead of bash. 
 
-[[sid-8093993_ContributingtoInfinispan-Terminalcolours]]
+[[sid-68355157_ContributingtoInfinispan-Terminalcolours]]
 
 
 ==== Terminal colours
@@ -637,12 +678,12 @@ source ~/.git-completion.bash
 
 ----
 
-[[sid-8093993_ContributingtoInfinispan-Aliases]]
+[[sid-68355157_ContributingtoInfinispan-Aliases]]
 
 
 ==== Aliases
 
- Some git commands are pretty long to type, especially with various switches. Aliases help you to map shortcuts to more complex commands.; Again, For example, add the followin to ~/.gitconfig : 
+ Some git commands are pretty long to type, especially with various switches. Aliases help you to map shortcuts to more complex commands.; Again, For example, add the following to ~/.gitconfig : 
 
 
 ----
@@ -664,21 +705,21 @@ source ~/.git-completion.bash
 
 ----
 
-[[sid-8093993_ContributingtoInfinispan-VisualHistory]]
+[[sid-68355157_ContributingtoInfinispan-VisualHistory]]
 
 
 ==== Visual History
 
- Git ships with gitk, a GUI that visually represents a log. If you use Mac OS X, link:$$http://gitx.frim.nl/$$[GitX] is a good alternative. Try typing gitk or gitx in a git project directory. 
+ Git ships with gitk, a GUI that visually represents a log. If you use Mac OS X, link:$$http://gitx.frim.nl/$$[GitX] is a good alternative. Try typing gitk or gitx in a git project directory. For Linux users, there are lots of alternatives: _gitk_ , _gitg_ , _giggle_ , ... up to _egit_ for Eclipse. 
 
-[[sid-8093993_ContributingtoInfinispan-Visualdiffandmergetools]]
+[[sid-68355157_ContributingtoInfinispan-Visualdiffandmergetools]]
 
 
 ==== Visual diff and merge tools
 
  There are several options available, including link:$$http://kdiff3.sourceforge.net/$$[KDiff3] , link:$$http://meld.sourceforge.net/$$[meld] and Perforce's link:$$http://www.perforce.com/perforce/products/merge.html$$[P4Merge] which are all either open source or available for free. See link:$$http://progit.org/book/ch7-1.html$$[this link] on setting these up (section under External Merge and Diff Tools) 
 
-[[sid-8093993_ContributingtoInfinispan-ChoosinganEditor]]
+[[sid-68355157_ContributingtoInfinispan-ChoosinganEditor]]
 
 
 ==== Choosing an Editor
@@ -695,7 +736,7 @@ source ~/.git-completion.bash
 
 Alternatively, you could fire up TextMate or another editors of your choice.
 
-[[sid-8093993_ContributingtoInfinispan-Shellprompt]]
+[[sid-68355157_ContributingtoInfinispan-Shellprompt]]
 
 
 ==== Shell prompt
@@ -743,7 +784,7 @@ For example, the following prompt indicates that the current branch is 't_ispn77
 
 ----
 
-~/Go/code/infinispan.git]% (t_ispn775_master⚡)
+[~/Go/code/infinispan.git]% (t_ispn775_master⚡)
 
 ----
 
diff --git a/documentation/src/main/asciidoc/contributing/chapter-3-Building_Infinispan.adoc b/documentation/src/main/asciidoc/contributing/chapter-3-Building_Infinispan.adoc
index 780196e..2a49c60 100644
--- a/documentation/src/main/asciidoc/contributing/chapter-3-Building_Infinispan.adoc
+++ b/documentation/src/main/asciidoc/contributing/chapter-3-Building_Infinispan.adoc
@@ -1,10 +1,10 @@
-[[sid-8093993_ContributingtoInfinispan-BuildingInfinispan]]
+[[sid-68355157_ContributingtoInfinispan-BuildingInfinispan]]
 
 ==  Building Infinispan
 
  Infinispan uses link:$$http://maven.apache.org/$$[Maven] as a build system. 
 
-[[sid-8093993_ContributingtoInfinispan-Requirements]]
+[[sid-68355157_ContributingtoInfinispan-Requirements]]
 
 
 === Requirements
@@ -18,13 +18,94 @@
 
 [WARNING]
 ==== 
- Make sure you follow the steps outlined in link:$$http://community.jboss.org/docs/15169$$[Maven Getting Started - Users] to set up your JBoss repository correctly. This step is _crucial_ to ensure your Maven setup can locate JBoss artifacts! 
+ Make sure you follow the steps outlined in link:$$http://community.jboss.org/docs/15169$$[Maven Getting Started - Users] to set up your JBoss repository correctly. This step is _crucial_ to ensure your Maven setup can locate JBoss artifacts! If you also want to test the EAP integration modules you should also add the appropriate link:$$http://maven.repository.redhat.com/$$[Enterprise Red Hat Maven Repository.] 
 
 
 ==== 
 
 
-[[sid-8093993_ContributingtoInfinispan-Quickcommandreference]]
+The following is an example settings.xml to get you started:
+
+
+----
+
+<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
+  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
+                      http://maven.apache.org/xsd/settings-1.0.0.xsd" >
+  <localRepository/>
+  <interactiveMode/>
+  <usePluginRegistry/>
+  <offline/>
+  <proxies/>
+  <profiles>
+    <profile>
+      <id>jboss-public-repository</id>
+      <repositories>
+        <repository>
+          <id>jboss-public-repository-group</id>
+          <name>JBoss Public Maven Repository Group</name>
+          <url> https://repository.jboss.org/nexus/content/groups/public-jboss/ </url>
+          <layout>default</layout>
+          <releases>
+            <enabled>true</enabled>
+            <updatePolicy>never</updatePolicy>
+          </releases>
+          <snapshots>
+            <enabled>true</enabled>
+            <updatePolicy>never</updatePolicy>
+          </snapshots>
+        </repository>
+      </repositories>
+      <pluginRepositories>
+        <pluginRepository>
+          <id>jboss-public-repository-group</id>
+          <name>JBoss Public Maven Repository Group</name>
+          <url> https://repository.jboss.org/nexus/content/groups/public-jboss/ </url>
+          <layout>default</layout>
+          <releases>
+            <enabled>true</enabled>
+            <updatePolicy>never</updatePolicy>
+          </releases>
+          <snapshots>
+            <enabled>true</enabled>
+            <updatePolicy>never</updatePolicy>
+          </snapshots>
+        </pluginRepository>
+      </pluginRepositories>
+    </profile>
+
+    <!-- Include early access of application server and other products -->
+    <profile>
+      <id>redhat-earlyaccess-repository</id>
+        <repositories>
+          <repository>
+            <id>redhat-earlyaccess-repository-group</id>
+            <name>Red Hat early access repository</name>
+            <url> http://maven.repository.redhat.com/earlyaccess/all/ </url>
+            <layout>default</layout>
+            <releases>
+              <enabled>true</enabled>
+              <updatePolicy>never</updatePolicy>
+            </releases>
+            <snapshots>
+              <enabled>true</enabled>
+              <updatePolicy>never</updatePolicy>
+            </snapshots>
+          </repository>
+        </repositories>
+     </profile>
+  </profiles>
+  <activeProfiles>
+    <activeProfile>jboss-public-repository</activeProfile>
+    <activeProfile>redhat-earlyaccess-repository</activeProfile>
+  </activeProfiles>
+</settings>
+
+
+----
+
+[[sid-68355157_ContributingtoInfinispan-Quickcommandreference]]
 
 
 === Quick command reference
@@ -49,7 +130,7 @@
 | mvn install -Dmaven.test.skip.exec=true |Installs the artifacts in your local repo for use by other projects/modules, including inter-module dependencies within the same project.
 | mvn install -P distribution | In addition to install, will also use Maven's assembly plugin to build ZIP files for distribution (in target/distribution ). Contents of various distribution are controlled by the files in src/main/resources/assemblies . 
 | mvn deploy |Builds and deploy the project to the JBoss snapshots repository.
-| mvn -Pconfigdoc install -DskipTests=true &amp;&amp; firefox target/site/apidocs/config.html |Builds the configuration reference HTML file
+| mvn -Pgenerate-schema-doc install -DskipTests=true -pl core &amp;&amp; firefox core/target/xsd_doc |Builds the configuration reference HTML file
 | mvn install -P-extras |Avoids the extras profile disables the enforce plugin, generation of source jars and OSGI bundleconstruction, hence making builds run faster. Clearly, this option should not be used when making a release or publishing a snapshot.
 
 |===============
@@ -64,7 +145,7 @@
 ==== 
 
 
-[[sid-8093993_ContributingtoInfinispan-PublishingreleasestoMaven]]
+[[sid-68355157_ContributingtoInfinispan-PublishingreleasestoMaven]]
 
 
 === Publishing releases to Maven
@@ -97,7 +178,7 @@
 
 ----
 
-[[sid-8093993_ContributingtoInfinispan-Publishingsnapshots]]
+[[sid-68355157_ContributingtoInfinispan-Publishingsnapshots]]
 
 
 ==== Publishing snapshots
@@ -113,14 +194,14 @@ $ mvn clean deploy -Dmaven.test.skip.exec=true
 
 in the Infinispan root directory will deploy a snapshot.
 
-[[sid-8093993_ContributingtoInfinispan-Publishingreleases]]
+[[sid-68355157_ContributingtoInfinispan-Publishingreleases]]
 
 
 ==== Publishing releases
 
 Use the bin/release.py script.
 
-[[sid-8093993_ContributingtoInfinispan-TheMavenArchetypes]]
+[[sid-68355157_ContributingtoInfinispan-TheMavenArchetypes]]
 
 
 === The Maven Archetypes
@@ -145,7 +226,7 @@ These archetypes have only been tested with Maven 3.  Please report back if you
 ==== 
 
 
-[[sid-8093993_ContributingtoInfinispan-Startinganewproject]]
+[[sid-68355157_ContributingtoInfinispan-Startinganewproject]]
 
 
 ==== Starting a new project
@@ -165,14 +246,14 @@ $ mvn archetype:generate \
 
  You will be prompted for a few things, including the artifactId , groupId and version of your new project. And that's it - you're ready to go! 
 
-[[sid-8093993_ContributingtoInfinispan-Exploringyournewproject]]
+[[sid-68355157_ContributingtoInfinispan-Exploringyournewproject]]
 
 
 ===== Exploring your new project
 
  The skeleton project ships with a sample application class for interacting with Infinispan. You can open this new project in your IDE - most good IDEs such as IntelliJ and Eclipse allow you to import Maven projects, see link:$$http://www.jetbrains.com/idea/webhelp/importing-maven-project.html$$[this guide] and link:$$http://m2eclipse.sonatype.org/$$[this guide] .  Once you open your project in your IDE, you should examine the generated classes and read through the comments. 
 
-[[sid-8093993_ContributingtoInfinispan-Onthecommandline...]]
+[[sid-68355157_ContributingtoInfinispan-Onthecommandline...]]
 
 
 ===== On the command line...
@@ -188,7 +269,7 @@ $ mvn install -Prun
 
 in your newly generated project. This runs the main() method in the generated application class.
 
-[[sid-8093993_ContributingtoInfinispan-WritingatestcaseforInfinispan]]
+[[sid-68355157_ContributingtoInfinispan-WritingatestcaseforInfinispan]]
 
 
 ==== Writing a test case for Infinispan
@@ -210,7 +291,7 @@ $ mvn archetype:generate \
 
 As above, this will prompt you for project details and again as above, you should open this project in your IDE. Once you have done so, you will see some sample tests written for Infinispan making use of Infinispan's test harness and testing tools along with extensive comments and links for further reading.
 
-[[sid-8093993_ContributingtoInfinispan-Onthecommandline...x]]
+[[sid-68355157_ContributingtoInfinispan-Onthecommandline...x]]
 
 
 ===== On the command line...
@@ -235,7 +316,7 @@ $ mvn test -Pudp
 
 ----
 
-[[sid-8093993_ContributingtoInfinispan-Availableprofiles]]
+[[sid-68355157_ContributingtoInfinispan-Availableprofiles]]
 
 
 ===== Available profiles
@@ -251,7 +332,7 @@ The profiles available in the generated sample project are:
 
 *  jbosstm: Use the embedded link:$$http://www.jboss.org/jbosstm$$[JBoss Transaction Manager] rather than Infinispan's dummy test transaction manager 
 
-[[sid-8093993_ContributingtoInfinispan-ContributingtestsbacktoInfinispan]]
+[[sid-68355157_ContributingtoInfinispan-ContributingtestsbacktoInfinispan]]
 
 
 ===== Contributing tests back to Infinispan
@@ -269,14 +350,14 @@ Want to know how best to work with the repositories and contribute code?  Read
 ==== 
 
 
-[[sid-8093993_ContributingtoInfinispan-Versions]]
+[[sid-68355157_ContributingtoInfinispan-Versions]]
 
 
 ==== Versions
 
 The archetypes generate poms with dependencies to specific versions of Infinispan. You should edit these generated poms by hand to point to other versions of Infinispan that you are interested in.
 
-[[sid-8093993_ContributingtoInfinispan-SourceCode]]
+[[sid-68355157_ContributingtoInfinispan-SourceCode]]
 
 
 ==== Source Code
diff --git a/documentation/src/main/asciidoc/contributing/chapter-4-API_Commons_and_Core.adoc b/documentation/src/main/asciidoc/contributing/chapter-4-API_Commons_and_Core.adoc
new file mode 100644
index 0000000..15d6a75
--- /dev/null
+++ b/documentation/src/main/asciidoc/contributing/chapter-4-API_Commons_and_Core.adoc
@@ -0,0 +1,27 @@
+[[sid-68355157_ContributingtoInfinispan-API%2CCommonsandCore]]
+
+==  API, Commons and Core
+
+In order to provide proper separation between public APIs, common     utilities and the actual implementation of Infinispan, these are     split into 3 modules: infinispan-api, infinispan-commons and     infinispan-core. This separation also makes sure that modules, such     as the remote clients, don't have to depend on infinispan-core and     its transitive dependencies. The following paragraphs describe the     role of each of these modules and give indication as to what goes     where.
+
+[[sid-68355157_ContributingtoInfinispan-API]]
+
+
+=== API
+
+ The infinispan-api module should only contain the public interfaces     which can be used in any context (local, remote, etc). Any additions and/or modifications to this module _must_ be discussed and approved by the team beforehand. Ideally it     should not contain any concrete classes: rare exceptions may be made for small, self-contained classes which need to be     referenced from the API interfaces and for which the introduction of an interface would be deemed cumbersome. 
+
+[[sid-68355157_ContributingtoInfinispan-Commons]]
+
+
+=== Commons
+
+The infinispan-commons module contains utility classes which can be     reused across other modules. Classes in infinispan-commons should be     self-contained and not pull in any dependencies (apart from the existing jboss-logging and infinispan-api). They should     also make no reference to configuration aspects specific to a     particular environment.
+
+[[sid-68355157_ContributingtoInfinispan-Core]]
+
+
+=== Core
+
+The infinispan-core module contains the actual implementation used     for local/embedded mode. When adding new functionality to the APIs,     it is generally safe to start by putting them in infinispan-core and     promoting them to infinispan-api only when it is deemed to do so and     it makes sense across the various use-cases.
+
diff --git a/documentation/src/main/asciidoc/contributing/chapter-5-Running_and_Writing_Tests.adoc b/documentation/src/main/asciidoc/contributing/chapter-5-Running_and_Writing_Tests.adoc
new file mode 100644
index 0000000..1941bcf
--- /dev/null
+++ b/documentation/src/main/asciidoc/contributing/chapter-5-Running_and_Writing_Tests.adoc
@@ -0,0 +1,296 @@
+[[sid-68355157_ContributingtoInfinispan-RunningandWritingTests]]
+
+==  Running and Writing Tests
+
+ Tests are written using the link:$$http://testng.org/$$[TestNG] framework. 
+
+[[sid-68355157_ContributingtoInfinispan-Runningthetests]]
+
+
+=== Running the tests
+
+Before running the actual tests it is highly recommended to configure adjust suite's memory setting by updating the MAVEN_OPTS variables. E.g.
+
+
+----
+
+$ export MAVEN_OPTS="-Xms512m -Xmx2048m -XX:MaxPermSize=384m"
+
+----
+
+The default run executes all tests in the functional and unit groups. To just run the tests with txt and xml output the command is:
+
+
+----
+
+$ mvn test
+
+----
+
+ Alternatively, you can execute the tests _and_ generate a report with: 
+
+
+----
+
+$ mvn surefire-report:report
+
+----
+
+
+[NOTE]
+==== 
+ If you are running the tests on a Unix-like operating system, the default limits per user are typically low. The Infinispan test suite creates a lot of processes/threads, thus you will have to increase your user's limits and reboot the system to pick up the new values. Open up /etc/security/limits.conf and add the following lines replacing the user name with your username. 
+
+
+----
+
+rhusar    soft    nofile    16384
+rhusar    hard    nofile    16384
+rhusar    soft    nproc     16384
+rhusar    hard    nproc     16384
+
+----
+
+
+==== 
+
+
+[[sid-68355157_ContributingtoInfinispan-Specifyingwhichteststorun]]
+
+
+==== Specifying which tests to run
+
+A single test can be executed using the test property. The value is the short name (not the fully qualified package name) of the test. For example:
+
+
+----
+
+$ mvn -Dtest=FqnTest test
+
+----
+
+Alternatively, if there is more than one test with a given classname in your test suite, you could provide the path to the test.
+
+
+----
+
+$ mvn -Dtest=org/infinispan/api/MixedModeTest test
+
+----
+
+ Alternatively, you can always pass your own Log4j configuration file via -Dlog4.configuration with your own logging settings. 
+
+Patterns are also supported:
+
+
+----
+
+$ mvn -Dtest=org/infinispan/api/* test
+
+----
+
+[[sid-68355157_ContributingtoInfinispan-Skippingthetestrun]]
+
+
+==== Skipping the test run
+
+ It is sometimes desirable to install the Infinispan package in your local repository without performing a full test run. To do this, simply use the maven.test.skip.exec property: 
+
+
+----
+
+$ mvn -Dmaven.test.skip.exec=true install
+
+----
+
+ Note that you should _never_ use -Dmaven.test.skip=true since modules' test classes depend on other module test classes, and this will cause compilation errors. 
+
+[[sid-68355157_ContributingtoInfinispan-Runningtestsusing%7B%7B@Parameters%7D%7D]]
+
+
+==== Running tests using @Parameters
+
+ If you want to execute tests relying on TestNG's @Parameters from an IDE (such as Eclipse or IntelliJ IDEA), please check link:$$http://infinispan.blogspot.com/2009/06/executing-testng-tests-relying-on.html$$[this blog entry] . 
+
+[[sid-68355157_ContributingtoInfinispan-EnablingTRACEintestlogs]]
+
+
+==== Enabling TRACE in test logs
+
+ When you run tests, you can get TRACE logging via using the traceTests profile 
+
+
+----
+
+mvn test -PtraceTests
+
+----
+
+ Executing this will generate a GZIP file called trace-infinispan.log.gz . This file is not fully closed, so to extract the log file, execute: 
+
+
+----
+
+gunzip -c trace-infinispan.log.gz > trace-infinsipan.log
+
+----
+
+[[sid-68355157_ContributingtoInfinispan-Enablingcodecoveragegeneration]]
+
+
+==== Enabling code coverage generation
+
+ When you run tests, you can enable code coverage recorder for calculating and analysing the Infinispan code coverage. You can do this using coverage and jacocoReport profiles. As a code coverage evaluation tool, the JaCoCo is used. 
+
+
+----
+
+mvn test -Pcoverage -Dmaven.test.failure.ignore=true
+
+----
+
+ Please note, that -Dmaven.test.failure.ignore=true is used for generating JaCoCo code coverage report, even if there are test failures. 
+
+ Executing this will generate jacoco.exec file in each module's target/ directory. These are the JaCoCo execution data files, which contain full data about the specific module's coverage. 
+
+ As soon as the coverage execution command is finished, you will need to generate the JaCoCo report, which will merge the generated jacoco.exec files as well as will create the code coverage report. 
+
+For having the report in place, run the following command from your Infinispan home directory:
+
+
+----
+
+mvn install -pl parent -PjacocoReport
+
+----
+
+ The jacoco-html/ directory will be generated in Infinispan Home directory, which will contain the code coverage report. 
+
+[[sid-68355157_ContributingtoInfinispan-Testgroups]]
+
+
+=== Test groups
+
+Each test should belong to one or more group. The group acts as a filter, and is used to select which tests are ran as part of the maven test lifecycle.
+
+[[sid-68355157_ContributingtoInfinispan-WhichgroupshouldIuse%3F]]
+
+
+==== Which group should I use?
+
+
+[TIP]
+==== 
+If your test does not fit into one of these group, a new group should be added.
+
+
+==== 
+
+
+
+|===============
+| _unit_ |Unit tests using stubs to isolate and test each major class in Infinispan. This is the default group run if no test group is specified
+| _functional_ |Tests which test the general functionality of Infinispan
+| _jgroups_ |Tests which need to send data on a JGroups Channel
+| _transaction_ |Tests which use a transaction manager
+| _profiling_ |Tests used for manual profiling, not meant for automated test runs
+| _manual_ |Other tests that are run manually
+
+|===============
+
+
+
+[NOTE]
+==== 
+Every test (except those not intended to be run by Hudson) should at least be in the functional or unit groups, since these are the default test groups executed by Maven, and are run when preparing a release.
+
+
+==== 
+
+
+[[sid-68355157_ContributingtoInfinispan-Testpermutations]]
+
+
+=== Test permutations
+
+ We use the term permutation to describe a test suite execution against a particular configuration. This allows us to test a variety of environments and configurations without rewriting the same basic test over and over again. For example, if we pass JVM parameter -Dinfinispan.test.jgroups.protocol=udp test suite is executed using UDP config. 
+
+
+----
+
+$ mvn -Dinfinispan.test.jgroups.protocol=udp test
+
+----
+
+Each permutation uses its own report directory, and its own html output file name. This allows you to execute multiple permutations without wiping the results from the previous run. Note that due to the way Maven operates, only one permutation can be executed per mvn command. So automating multiple runs requires shell scripting, or some other execution framework to make multiple calls to Maven.
+
+[[sid-68355157_ContributingtoInfinispan-RunningpermutationsmanuallyorinanIDE]]
+
+
+==== Running permutations manually or in an IDE
+
+ Sometimes you want to run a test using settings other than the defaults (such as UDP for _jgroups_ group tests or the DummyTransactionManager for _transaction_ group tests). This can be achieved by referring to the Maven POM file to figure out which system properties are passed in to the test when doing something different. For example to run a _jgroups_ group test in your IDE using TCP instead of the default UDP, set -Dinfinispan.test.jgroups.protocol=tcp . Or, to use JBoss JTA (Arjuna TM) instead of the DummyTransactionManager in a _transaction_ group test, set -Dinfinispan.test.jta.tm=jbosstm Please refer to the POM file for more properties and permutations. 
+
+[[sid-68355157_ContributingtoInfinispan-TheParallelTestSuite]]
+
+
+=== The Parallel Test Suite
+
+Infinispan runs its unit test suite in parallel; Infinispan tests are often IO rather than processor bound, so executing them in parallel offers significant speed up.
+
+[[sid-68355157_ContributingtoInfinispan-Tipsforwritinganddebuggingparalleltests]]
+
+
+==== Tips for writing and debugging parallel tests
+
+There are a number of constraints and best practices that need to be followed in order to ensure correctness and keep the execution time to a minimum. If you follow these guidelines you will find your tests are more reliable:
+
+ _Each test class is run in a single thread_ There is no need to synchronize unit test's fixture, as test methods will be run in sequence. However, multiple test classes are executed in parallel. 
+
+ _Each test class must have an unique test name_ As a convention, the name of the test should be the FQN of the test class with the org.infinispan prefix removed. For example, given a test class org.infinispan.mypackage.MyTest the name of the test should be mypackage.MyTest . This convention guarantees a unique name. 
+
+.MyTest.java
+
+==== 
+----
+
+package org.infinispan.mypackage;
+@Test (testName = "mypackage.MyTest")
+public class MyTest { ... }
+
+----
+
+==== 
+ _Use_ TestCacheManagerFactory.createXyzCacheManager _$$and _never_create managers using$$_ new DefaultCacheManager() This ensures that there are no conflicts on resources e.g. a cluster created by one test won't interfere with a cluster created by another test. 
+
+ _Where possible, extend_ SingleCacheManagerTestorMultipleCacheManagersTest Tests inheriting from these template method classes will only create a cache/cluster once for all the test methods, rather than before each method. This helps keep the execution time down. 
+
+ _Never rely_ onThread.sleep() When running in heavily threaded environments this will most often not work. For example, if using ASYNC_REPL , don't use a sleep(someValue) and expect the data will be replicated to another cache instance after this delay has elpased. Instead, use a ReplicationListener (check the javadoc for more information). Generally speaking, if you expect something will happen and you don't have a guarantee when, a good approach is to try that expectation in a loop, several times, with an generous (5-10secs) timeout. For example: 
+
+
+----
+
+while (Systet.currentTimeMillis() - startTime < timeout) {
+   if (conditionMeet()) break;
+   Thread.sleep(50);
+}
+
+----
+
+ Thread.sleep(10) _may not work in certain OS/JRE combos (e.g. Windows XP/Sun JRE 1.5)_ Use values grater than 10 for these statements, e.g. 50. Otherwise, a System.currentTimeMillis() might return same value when called before and after such a sleep statement. 
+
+ _JMX_ For each cache that is create with TestCacheManagerFactory.createXyzCacheManager() the test harness will allocate a unique JMX domain name which can be obtained through CacheManager.getJmxDomain() . This ensures that no JMX collisions will takes place between any tests executed in parallel. If you want to enforce a JMX domain name, this can be done by using one of the TestCacheManagerFactory.createCacheManagerEnforceJmxDomain methods . These methods must be used with care, and you are responsible for ensuring no domain name collisions happen when the parallel suite is executed. 
+
+ _Use obscure words_ Insert uncommon or obscure words into the cache that has been generated with a random word generator. In a multi-threaded environment like Infinispan's testsuite, grepping for these words can greatly help the debugging process. You may find link:$$http://watchout4snakes.com/creativitytools/RandomWord/RandomWordPlus.aspx$$[this random word generator] useful. 
+
+ _Use the test method name as the key_ Grab the test method and use it as part of the cached key. You can dynamically grab the test method using code like this: 
+
+
+----
+
+Thread.currentThread().getStackTrace()(1).getMethodName()
+
+----
+
+ Even though we've tried to reduce them to a min, intermittent failures might still appear from time to time. If you see such failures _in existing code_ please report them in the issue tracker. 
+
diff --git a/documentation/src/main/asciidoc/contributing/chapter-6-Helping_Others_Out.adoc b/documentation/src/main/asciidoc/contributing/chapter-6-Helping_Others_Out.adoc
new file mode 100644
index 0000000..07a4fd4
--- /dev/null
+++ b/documentation/src/main/asciidoc/contributing/chapter-6-Helping_Others_Out.adoc
@@ -0,0 +1,14 @@
+[[sid-68355157_ContributingtoInfinispan-HelpingOthersOut]]
+
+==  Helping Others Out
+
+Infinispan is reliant on the whole community helping each other out. Less experienced contributors are often able to help out answering the "newbie" questions, leaving more experienced contributors to handle the more complex questions.
+
+ Users are encouraged to follow the link:$$http://community.jboss.org/wiki/HowToAskAForumQuestion$$[How to ask a forum question] guide. 
+
+ Forum discussions can be posed as questions (we encourage people to do this). Questions can be marked as answered, indicating to the community that they no longer require answering, allowing easy tracking of open questions. Open questions can link:$$http://community.jboss.org/en/infinispan?view=discussions#/?filter=open$$[be easily viewed using this filter] . Community members are encouraged to regularly view the open questions and answer any questions they can. 
+
+In order to track what questions are still open, you are encouraged to mark questions as "assumed answered" if you provide information that you think resolves the query and you don't hear back to the contrary after a week or so.
+
+Approximately every month, a member of the Infinispan team will go through any open questions for the past month and clear up any unanswered questions, either by chasing for an answer from core team, or by checking with the user if they require more info.
+
diff --git a/documentation/src/main/asciidoc/contributing/chapter-7-Adding_Configuration.adoc b/documentation/src/main/asciidoc/contributing/chapter-7-Adding_Configuration.adoc
new file mode 100644
index 0000000..f2c9a4b
--- /dev/null
+++ b/documentation/src/main/asciidoc/contributing/chapter-7-Adding_Configuration.adoc
@@ -0,0 +1,65 @@
+[[sid-68355157_ContributingtoInfinispan-AddingConfiguration]]
+
+==  Adding Configuration
+
+
+[WARNING]
+==== 
+We still use the old configuration system internally within Infinispan. This makes things a little complicated. This will be switched out soon! For now, you need to also add your property to the old config system as well as the new.
+
+
+==== 
+
+
+Note, these guides assume you are adding an element to the cache configuration, but apply equally to the global configuration.
+
+Before you start adding a configuration property, identify whether you want to add a property to an existing configuration group/element, or whether you need to create a child object. We call the configuration group XXX in the steps below.
+
+[[sid-68355157_ContributingtoInfinispan-Addingaproperty]]
+
+
+=== Adding a property
+
+ Add the property to the relevant XXXConfiguration class. Add a private final field, add a parameter to the constructor, and assign the value to the field in the constructor body. Add a accessor for the property. If the property should be mutable at runtime, then add a mutator as well. Most configuration properties are not mutable at runtime - if the configuration is runtime mutable, then Infinispan needs to take notice of this update whilst the cache is running (you can't cache the value of the configuration in your implementation class). Mutators and accessors don't use the classic JavaBean pattern of prepending accessors with "get" and mutators with "set". Instead, the name of the property is used for an accessor. A mutator is an overloaded version of the accessor which takes a parameter, the new value. 
+
+ Add the property to the matching XXXConfigurationBuilder . You'll need to add a mutable field to the class, and initialise it to it's default value in the field declaration. Add a mutator (following the above pattern). 
+
+ The create() method is called by the parent object in order to instantiate the XXXConfiguration object from the builder. Therefore, make sure to pass the value of the field in the builder to the XXXConfiguration object's constructor here. Additionally, if you require a complex default (for example, the value of a configuration property is defaulted conditionally based on the value of some other configuration property), then this is the place to do this. 
+
+ The validate() method is called by the parent object to validate the values the user has passed in. This method may also be called directly by user code, should they wish to manually validate a configuration object. You should place any validation logic here related to your configuration property. If you need to "cross-validate" properties (validate the value of your property conditionally upon the value of another property), and the other property is on another builder object, increase the visibility of that other property field to "default", and reference it from this builder, by calling the getBuilder() method, which will gives you a handle on the root configuration builder. 
+
+ The final step is to add parsing logic to the Parser class. First, add the attribute to name to the Attribute enum (this class simply provides a mapping between the non-type-safe name of the attribute in XML and a type-safe reference to use in the parser). Locate the relevant parseXXX() method on the class, and add a case to the switch statement for the attribute. Call the builder mutator you created above, performing any XML related validation (you are unlikely to need this), and type conversion (using the static methods on the primitive wrapper classes, String class, or relevant enum class). 
+
+[[sid-68355157_ContributingtoInfinispan-Addingagroup]]
+
+
+=== Adding a group
+
+ In some situations you may additionally want to add a configuration grouping object, represented in XML as an element. You might want to do this if you are adding a new area of functionality to Infinispan. Identify the location of the new configuration grouping object. It might be added to the root Configuration object, or it might be added to one it's children, children's children. We'll call the parent YYY in the steps below. Create the XXXConfiguration object. Add any properties required following the guide for adding properties. The constructors visibility should be "default". 
+
+ Create the XXXConfigurationBuilder object. It should subclass the relevant configuration child builder – use the YYYConfigurationChildBuilder as the superclass. This will ensure that all builder methods that allow the user to "escape" are provided correctly (i.e provide access to other grouping elements), and also require you to provide a create() and validate() method. The constructor needs to take the the YYYConfigurationBuilder as an argument, and pass this to the superclass (this simply allows access to the root of the builder tree using the getBuilder() method). 
+
+ Follow the property adding guide to add any properties you need to the builder. The create() method needs to return a new instance of the XXXConfiguration object. Implement any validation needed in the validate() method. 
+
+ In the YYYConfiguration object, add your new configuration class as a private final field, add an accessor, and add initialiser assignment in the constructor 
+
+ In the YYYConfigurationBuilder , add your new configuration builder as a private final field, and initialise it in the constructor with a new instance. Finally, add an accessor for it following the standard pattern discussed in the guide. 
+
+ In the YYYConfigurationBuilder ensure that your validate method is called in it's validate method, and that result of the XXXConfiguration instances' create method is passed to the constructor of YYYConfiguration . 
+
+ Finally, add this to the parser. First, add the element to the Element class, which provides a type safe representation of the element name in XML. In the Parser class, add a new parseXXX method, copying one of the others that most matches your requirements (parse methods either parse elements only - look for ParseUtils.requireNoAttributes() , attributes only – look for ParseUtils.requireNoContent() or a combination of both – look for an iterator over both elements and attributes). Add any attributes as discussed in the adding a property guide. Finally, wire this in by locating the parseYYY() method, and adding an element to the switch statement, that calls your new parseXXX() method. 
+
+[[sid-68355157_ContributingtoInfinispan-Don%27tforgettoupdatetheXSDandXSDtest]]
+
+
+=== Don't forget to update the XSD and XSD test
+
+ Add your new elements or attributes to the XSD in src/main/resources . Update src/test/resources/configs/all.xml to include your new elements or attributes. 
+
+[[sid-68355157_ContributingtoInfinispan-Bridgingtotheoldconfiguration]]
+
+
+=== Bridging to the old configuration
+
+Until we entirely swap out the old configuration you will need to add your property to the old configuration (no need to worry about jaxb mappings though!), and then add some code to the LegacyConfigurationAdaptor to adapt both ways. It's fairly straightforward, just locate the relevant point in the adapt() method (near the configuration group you are using) and map from the legacy configuration to the new configuration, or vs versa. You will need to map both ways, in both adapt methods.
+
diff --git a/documentation/src/main/asciidoc/contributing/chapter-8-Writing_Documentation_and_FAQs.adoc b/documentation/src/main/asciidoc/contributing/chapter-8-Writing_Documentation_and_FAQs.adoc
new file mode 100644
index 0000000..85a503c
--- /dev/null
+++ b/documentation/src/main/asciidoc/contributing/chapter-8-Writing_Documentation_and_FAQs.adoc
@@ -0,0 +1,347 @@
+[[sid-68355157_ContributingtoInfinispan-WritingDocumentationandFAQs]]
+
+==  Writing Documentation and FAQs
+
+[[sid-68355157_ContributingtoInfinispan-Introduction]]
+
+
+=== Introduction
+
+Infinispan uses this Confluence instance to store documentation and FAQs. The documentation is organised into:
+
+[options="header"]
+|===============
+| | |Future plans
+| <<sid-68355130>> |Tutorials for using Infinispan|This will be developed into a Getting Started Guide, where each tutorial as an associated quickstart example
+| <<sid-68355028>> |Goes into depth on using and configuring Infinispan|This will be split into a Developer Reference Guide, a Configuration Guide and a Tuning Guide
+| <<sid-68355169>> |An explanation of the terminology used by Infinispan| 
+| <<sid-68354929>> |Contains both product and technical FAQs|Each Q&amp;A will be moved into a document and included into the outline document
+
+|===============
+
+
+ Editing and adding pages on Confluence is restricted to regular contributors to Infinispan (if you think you should have access, or want to become a regular contributor to the documentation, then please email infinispan-dev@lists.jboss.org . 
+
+[[sid-68355157_ContributingtoInfinispan-Whatgoeswhere%3F]]
+
+
+=== What goes where?
+
+ Infinispan has both this Confluence instance, and the SBS instance at link:$$http://community.jboss.org/wiki/Infinispan$$[] . Documentation and FAQs belong in Confluence, whilst design notes, meeting notes and user contributed articles belong on SBS. 
+
+
+[NOTE]
+==== 
+Once the final set of guides (as described in the table above) is complete, there will be additional guidance here to describe how to decide which guide to place content in.
+
+
+==== 
+
+
+[[sid-68355157_ContributingtoInfinispan-Wikimarkuporrichtext]]
+
+
+=== Wiki markup or rich text
+
+You should always use wiki markup, it gives you much greater control over output format. The "Full notation guide" link in the "Help Tips" panel to the right (on the edit page) gives a full list of markup available.
+
+[[sid-68355157_ContributingtoInfinispan-Markupguide]]
+
+
+=== Markup guide
+
+This section discusses the typical markup you would use to write a documentation chapter. The Style and Grammar guide will discuss the writing style you should use.
+
+Let's start at the beginning - headers, page structure, and the table of contents.
+
+[[sid-68355157_ContributingtoInfinispan-Headers%2CPageStructureandtheTableofContents]]
+
+
+==== Headers, Page Structure and the Table of Contents
+
+This Confluence instance is styled to produce structured documentation. Each node in the Infinispan space can have children, producing a tree of nodes. Note that pages are actually stored in a flat structure in the Infinispan space, they are just logically arranged into the tree. This means that URLs do not reflect the tree structure, and names of documents must be unique within the space.
+
+The child nodes of the Infinispan space represent the various guides, and the FAQs. The child nodes of each guide represent the sections of the guides. Some sections of a guide may be further split into subsections stored in different pages (it is likely this was done because a section was getting large).
+
+ The include macro is used to display inline the contents of the various sub pages into the top level guide page, and if a section is made up of child pages, each child page should be inlined into the section page using the include macro. 
+
+
+[WARNING]
+==== 
+ The include macro is not automatically updated if you change a page name! 
+
+
+==== 
+
+
+ Confluence auto-generates the table of contents (using the toc macro) for the various guides, based on the headings used in the guide. As the include macro does not print the title of the page you are including, it is necessary to add the title above the include macro. You should not use the toc macro except on the main guide page. 
+
+ h1 headers should only be used to name sections of guide, h2 headers to name sub-sections and so on. You should not skip header levels. Headings should follow the same capitalization rules as a sentence - only capitalize the first letter and proper nouns. 
+
+ For an example, take a look at the wiki markup for the <<sid-68355157>> guide. 
+
+[[sid-68355157_ContributingtoInfinispan-Markinguptext]]
+
+
+==== Marking up text
+
+You will likely want to introduce some inline formatting for text. Here are the various styles you should use.
+
+[options="header"]
+|===============
+|Style|Use
+|bold|Bold should be used for emphasis only. You should never use another style to give emphasis.
+|italic| Italic should be used when you introduce a new piece of terminology. For example "Infinispan is a _data grid_ ". Further uses of the term do not need to be italicised. 
+|underline|Underline should not be used
+|strikethrough|Strikethrough should not be used
+|fixed width font| A fixed width font should be used whenever you refer to a class, variable, method by name, whenever you make a reference to a path on filesystem, or whenever you refer to a command the user _can_ execute. A fixed width font should be used when referring to a sequence of clicks required by a user in a GUI. the -&gt; symbols should be used to indicate the transition through a nested menu. 
+|code block| Should be used whenever you have a multi-line code example, or are expressing an instruction for a user to _do_ something 
+|quotation|Should be used whenever you refer to text someone, or something, else has written, for example the "Help Tips" on the right hand side of the edit page. You may wish to quote a statement to indicate that your text is not overly precise. Quotes should not be used to refer to a variable, class or method name, or a filesystem path or command
+|blockquote|Should be used for multiline quotes
+|Color|Colored text should not be used
+
+|===============
+
+
+[[sid-68355157_ContributingtoInfinispan-Listsandtables]]
+
+
+==== Lists and tables
+
+[[sid-68355157_ContributingtoInfinispan-Markup]]
+
+
+===== Markup
+
+You will normally wish to use an unordered list, however a numbered list is useful when expressing a set of steps the user should take. There are no "definition list" macros available in Confluence, so a table makes a good alternative.
+
+You can make nested lists by using "double" markup.
+
+[[sid-68355157_ContributingtoInfinispan-Grammarinlistsandtables]]
+
+
+===== Grammar in lists and tables
+
+The trailing sentence in a list or a table should normally not have a full stop at the end.
+
+Often, you will want to introduce a list or a table using a sentence. If you do this, a colon is often used to punctuate the end of the sentence, rather than a full stop/period.
+
+[[sid-68355157_ContributingtoInfinispan-Links]]
+
+
+==== Links
+
+Links should be used as normal!
+
+[[sid-68355157_ContributingtoInfinispan-Admonitions]]
+
+
+==== Admonitions
+
+Confluence supports three admonition styles, and you are encouraged to use them in your documentation as they allow the flow of information to the reader to be controlled, by moving orthogonal information out of the main body of text.
+
+
+|===============
+|tip|A tip should be used when you want to convey useful information to the user. If the user does not read the tip, it will have no impact on them understanding your documentation, however they will gain useful extra information by reading the tip
+|note|A note should be used when you wish to convey extra information to the user. Without the information the user may struggle to completely understand your documentation
+|warning|A warning should be used when the there is some counter-intuitive information to be called out to the user. For example, that the following information is out of date.
+
+|===============
+
+
+ You can use the title attribute to give the admonition a title 
+
+[[sid-68355157_ContributingtoInfinispan-Imagesandothermedia]]
+
+
+==== Images and other media
+
+ If you are describing the use of a GUI, or showing results of some operation, images embedded in the page can bring the documentation to life for the reader. Images can be attached to the page using the Tools menu, and then linked. The "Full notation guide" discusses the syntax for embedding images. If you are embedding the image to describe a series of steps taken in a GUI, it is not necessary to title your image, otherwise you should give every image a title. 
+
+ Giffy is supported in this Confluence instance, allowing you to easily create drawings online. For more, link:$$http://www.gliffy.com/products/confluence-plugin/$$[read the Giffy documentation] for more information. 
+
+Confluence supports a charting macro, however it is recommended that you embed charts as images, generating the chart using your favourite program.
+
+ The use of the panel macro is not recommended. 
+
+ Confluence allows you to natively embed video, however the use of this is not recommended, instead it is recommended the widget macro is used to connect to Vimeo or YouTube. The Screencasts section describes the creation of screencasts and upload of video to Vimeo or YouTube. To embed a video using the widget macro simply reference the URL to the video, for example: 
+
+
+----
+
+{widget:url=http://au.youtube.com/watch?v=-dnL00TdmLY}
+
+----
+
+This produces
+
+You can also embed Google Docs documents, Twitter searches, slide decks from SlideShare, and presentations from SlideRocket. Just follow the above example, substituting the URL for your media.
+
+[[sid-68355157_ContributingtoInfinispan-Codesamples]]
+
+
+==== Code samples
+
+ Confluence includes a code macro, but unfortunately it is not very advanced. This Confluence instance also supports the snippet macro which can be used to include text from other sites. The use of the snippet macro is strongly recommended as it ensures that code samples do not get out of date. It is critical that you add a title to the your snippet, and it is also recommended you enable linenumbers and trim the text. For example 
+
+
+----
+
+{snippet:title=My Code Sample|language=none|linenumbers=true|first=2|last=5|url=github.com/infinispan/infinispan/raw/master/README.mkdn}
+
+----
+
+Which results in:
+
+Code Snippet error: Unable to retrieve the URL: https://github.com/infinispan/infinispan/raw/master/README.mkdn status code: 404.
+
+
+[NOTE]
+==== 
+ The snippet macro doesn't like the default "raw" link that GitHub provides. Instead, craft a URL like github.com/infinispan/infinispan/raw/master/README.mkdn ; to do this, take the URL from your browser, and insert raw/master after the project name and before the path to the file. 
+
+
+==== 
+
+
+
+[TIP]
+==== 
+ If you want to indicate that the user needs to substitute a variable in a code sample with their own, then use &lt; and &gt; around the variable name. For example, to indicate the user needs to checkout a topic branch from git: 
+
+
+----
+
+git checkout -b <topic>
+
+----
+
+
+==== 
+
+
+[[sid-68355157_ContributingtoInfinispan-Voiceandgrammarguide]]
+
+
+=== Voice and grammar guide
+
+By using a consistent voice throughout the documentation, the Infinispan documentation appears more professional. The aim is to make it feel to the user like the documentation was written by a single person. This can only be completely achieved by regular editing, however in order to make the workload of the editor lighter, following these rules will produce a pretty consistent voice.
+
+
+* Never use abbreviations. On the other hand, contractions are fine.
+
+
+* Always use the project name "Infinispan". Never abbreviate it.
+
+
+* Always write in the second or third person, never the first (plural or singular forms). Use the second person to emphasize you are giving instructions to the user.
+
+
+[TIP]
+==== 
+Naturally, most people write in the first person, and, typically find it the easiest form to write, however without a lot of care it can produce the most "unprofessional" text. Conversely, writing in the third person is trickier, but will produce text that feels well written almost without fail. The first person can be used for emphasis but in general it is recommended to avoid it unless you feel confident!
+
+ Writing entirely in the third person can produce quite "dry" text, so it is recommended that you use the second person when you are giving instructions to the user. This could be when you are walking through a sequence of steps they should perform, or could be when you are stating that they _must_ do something in order for them to succeed. 
+
+So, are there any tricks to reformulate a sentence so the first person is not used?
+
+
+* Use the passive voice "I recommend" can become "It is recommended". However, extensive use of the can produce boring, dry and indefinite text, so don't do this too much!
+
+
+* Change the subject. For example you can change "Here we discuss" to "This section discusses"
+
+
+==== 
+
+
+
+* Use a "chatty" style. Although the use of the first person is avoided, the documentation shouldn't be too dry. Use the second person as needed. Short sentences and good use of punctuation help too!
+
+
+* If you define a list, keep the ordering of the list the same whenever you express the list. For example, if you say "In this section you will learn about interceptors, commands and factories" do not go on to say "First, let's discuss factories". This will subconsciously confuse the user
+
+
+* You should only capitalize proper nouns only. For example "data grid" is lower case (it's a concept), whilst "Infinispan" is capitalized (it's a project/product name)
+
+
+* You should always use American spelling. Enable a spell checker!
+
+
+* Use the definite article when discussing a specific instance or the indefinite article when describing a generalization of something; generally you omit the article when using a name for a project or product.
+
+
+[TIP]
+==== 
+[quote]
+____
+ Infinispan uses _a_ logging framework to communicate messages to the user, _the_ logging framework used by Infinispan is JBoss Logging. 
+
+
+____
+
+
+Let's dig into this. First, the sentence states that "Infinispan uses logging", and the indefinite article is used - we are not stating which of many possibilities is used. Second, the sentence goes on to discuss the logging framework Infinispan uses, and here the definite article is used, as the specific framework in use is discussed. Finally, the sentence is concluded by stating that the logging framework used is called "JBoss Logging", and as this is a product name, no article is used.
+
+This is not a formal or complete description, but is a good rule of thumb.
+
+
+==== 
+
+
+
+* Keep the tense the same. It's very easy to slip between the present, past and future tenses, but this produces text that is feels "unnatural" to the reader. Here's an example:
+
+
+[TIP]
+==== 
+[quote]
+____
+Data is collected from Infinispan every hour. Upon analysis the data showed that Infinispan is 2 million times faster than it's nearest competitor
+
+
+____
+
+
+ You may not have noticed, but the phrase starts using the present tense ( _is_ ) and slips into the past tense ( _showed_ ). This is clearly not actually the order in which the events happened! 
+
+Of course, if you are actually describing the progression of time, then changing tenses is fine. For example:
+
+[quote]
+____
+ In the last section you _were_ shown how to configure Infinispan using XML, and in the next section you _will be_ shown how to configure Infinispan programmatically. 
+
+
+____
+
+
+
+==== 
+
+
+
+* If you are telling the user about a procedure they can follow, do be explicit about this, and enumerate the steps clearly
+
+[[sid-68355157_ContributingtoInfinispan-Glossary]]
+
+
+=== Glossary
+
+ When writing a glossary entry, you should follow the <<sid-68355194>> as a template. 
+
+
+* If the entry is commonly referred to using an acronym, then the title should consistent of the fully expanded name, with the acronym in brackets. You can then use the acronym always within the main text body
+
+
+* If you want to refer to other glossary articles using links in the text body, then just link them with no alternative text
+
+
+* If you want to make external links (e.g. wikipedia, user guide), then add a h2 header "More resources", and list them there. This clearly indicates to users when they are moving outside of our definitions
+
+[[sid-68355157_ContributingtoInfinispan-Screencasts]]
+
+
+=== Screencasts
+
+TODO
+
diff --git a/documentation/src/main/asciidoc/contributing/chapter-9-Managing_this_confluence_instance_.adoc b/documentation/src/main/asciidoc/contributing/chapter-9-Managing_this_confluence_instance_.adoc
new file mode 100644
index 0000000..05b8a41
--- /dev/null
+++ b/documentation/src/main/asciidoc/contributing/chapter-9-Managing_this_confluence_instance_.adoc
@@ -0,0 +1,8 @@
+[[sid-68355157_ContributingtoInfinispan-Managingthisconfluenceinstance.]]
+
+==  Managing this confluence instance.
+
+ On a minor release we clone this space to a versioned name (e.g. ISPN51), leaving the ISPN space available for development in HEAD. To do this, visit _Browse_ -&gt; _Space Admin_ and choose _Permissions_ and make sure you have _Space Admin_ and _Space Export_ permissions. Then, visit _Copy Space_ , and fill in the name (e.g. Infinispan 5.1) and key (e.g. ISPN51). Make sure all the boxes are checked, and click Save. 
+
+ Finally, you'll need to update the name of the ISPN space to reflect the minor version of the development in HEAD (e.g. Infinispan 5.2). You can do this in _Space Details_ . 
+
diff --git a/documentation/src/main/asciidoc/extending/chapter-1-Custom_Commands.adoc b/documentation/src/main/asciidoc/extending/chapter-1-Custom_Commands.adoc
index 834dbb8..be395c9 100644
--- a/documentation/src/main/asciidoc/extending/chapter-1-Custom_Commands.adoc
+++ b/documentation/src/main/asciidoc/extending/chapter-1-Custom_Commands.adoc
@@ -1,30 +1,60 @@
-[[sid-8094037_ExtendingInfinispan-CustomCommands]]
+[[sid-68355203_ExtendingInfinispan-CustomCommands]]
 
 ==  Custom Commands
 
- Infinispan makes use of a link:$$http://en.wikipedia.org/wiki/Command_pattern$$[command/visitor pattern] to implement the various top-level methods you see on the public-facing API.  This is explained in further detail in the link:$$http://community.jboss.org/wiki/ArchitecturalOverview$$[Architectural Overview] on the Infinispan public wiki.  However, these commands - and their corresponding visitors - are hard-coded as a part of Infinispan's core module, making it impossible for module authors to extend and enhance Infinispan to create new, arbitrary commands and visitors. 
+ Infinispan makes use of a link:$$http://en.wikipedia.org/wiki/Command_pattern$$[command/visitor pattern] to implement the various top-level methods you see on the public-facing API.  This is explained in further detail in the link:$$http://community.jboss.org/wiki/ArchitecturalOverview$$[Architectural Overview] on the Infinispan public wiki.  However, these commands - and their corresponding visitors - are hard-coded as a part of Infinispan's core module, making it impossible for module authors to extend and enhance Infinispan to create new arbitrary commands and visitors. 
 
- However, since Infinispan 5.0, this capability has now been added.  As a module author (such as link:$$https://github.com/infinispan/infinispan/tree/master/tree$$[infinispan-tree] , link:$$https://github.com/infinispan/infinispan/tree/master/query$$[infinispan-query] , etc.) you can now define your own commands.  You do so by: 
+ However, since Infinispan 5.0, this capability has now been added.  As a module author (such as link:$$https://github.com/infinispan/infinispan/tree/master/tree$$[infinispan-tree] , link:$$https://github.com/infinispan/infinispan/tree/master/query$$[infinispan-query] , etc.) you can now define your own commands.  From Infinispan 5.1 onwards, you do so by: 
 
 
-.  Creating an infinispan-module.properties file and ensuring that this is packaged in the root of your jar file. 
+.  Create a META-INF/services/org.infinispan.commands.module.ModuleCommandExtensions file and ensure this is packaged in your jar. 
 
 
 .  Implementing 
               link:$$https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/commands/module/ModuleCommandFactory.java$$[ModuleCommandFactory]
              and 
               link:$$https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/commands/module/ModuleCommandInitializer.java$$[ModuleCommandInitializer]
-             from infinispan-core 
+             from infinispan-core . 
 
 
-.  Specifing the fully-qualified class names of your implementations in infinispan-module.properties 
+.  Implementing 
+              link:$$https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/commands/module/ModuleCommandExtensions.java$$[ModuleCommandExtensions]
+             from infinispan-core . 
+
+
+.  Specifing the fully-qualified class name of the 
+              link:$$https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/commands/module/ModuleCommandExtensions.java$$[ModuleCommandExtensions]
+             implementation in META-INF/services/org.infinispan.commands.module.ModuleCommandExtensions . 
 
 
 . Implement your custom commands and visitors for these commands
 
- Here is an example of an infinispan-modules.properties file, configured accordingly: 
+ Here is an example of an META-INF/services/org.infinispan.commands.module.ModuleCommandExtensions file, configured accordingly: 
+
+.org.infinispan.commands.module.ModuleCommandExtensions
+
+==== 
+----
+
+1. org.infinispan.query.QueryModuleCommandExtensions
+
+----
+
+==== 
+ For a full, working example of a sample module that makes use of custom commands and visitors, check out link:$$https://github.com/infinispan/infinispan-sample-module$$[Infinispan Sample Module] . 
+
+[[sid-68355203_ExtendingInfinispan-PreassignedCustomCommandIdRanges]]
+
+
+=== Preassigned Custom Command Id Ranges
+
+ This is the list of Command identifiers that are used by Infinispan based modules or frameworks. Infinispan users should avoid using ids within these ranges. (RANGES to be finalised yet!) Being this a single byte, ranges can't be too large. 
+
+
+|===============
+|Infinispan Query:|100 - 119
+|Hibernate Search:|120 - 139
 
-Code Snippet error: Unable to retrieve the URL: https://github.com/infinispan/infinispan-sample-module/raw/master/src/main/resources/infinispan-module.properties status code: 404.
+|===============
 
- For a full, working example of a sample module that makes use of custom commands and visitors, check out link:$$https://github.com/infinispan/infinispan-sample-module$$[] . 
 
diff --git a/documentation/src/main/asciidoc/extending/chapter-2-Writing_custom_commands_in_Infinispan.adoc b/documentation/src/main/asciidoc/extending/chapter-2-Writing_custom_commands_in_Infinispan.adoc
index be62abe..87430cd 100644
--- a/documentation/src/main/asciidoc/extending/chapter-2-Writing_custom_commands_in_Infinispan.adoc
+++ b/documentation/src/main/asciidoc/extending/chapter-2-Writing_custom_commands_in_Infinispan.adoc
@@ -1,30 +1,60 @@
-[[sid-8094038]]
+[[sid-68355204]]
 
 ==  Writing custom commands in Infinispan
 
- Infinispan makes use of a link:$$http://en.wikipedia.org/wiki/Command_pattern$$[command/visitor pattern] to implement the various top-level methods you see on the public-facing API.  This is explained in further detail in the link:$$http://community.jboss.org/wiki/ArchitecturalOverview$$[Architectural Overview] on the Infinispan public wiki.  However, these commands - and their corresponding visitors - are hard-coded as a part of Infinispan's core module, making it impossible for module authors to extend and enhance Infinispan to create new, arbitrary commands and visitors. 
+ Infinispan makes use of a link:$$http://en.wikipedia.org/wiki/Command_pattern$$[command/visitor pattern] to implement the various top-level methods you see on the public-facing API.  This is explained in further detail in the link:$$http://community.jboss.org/wiki/ArchitecturalOverview$$[Architectural Overview] on the Infinispan public wiki.  However, these commands - and their corresponding visitors - are hard-coded as a part of Infinispan's core module, making it impossible for module authors to extend and enhance Infinispan to create new arbitrary commands and visitors. 
 
- However, since Infinispan 5.0, this capability has now been added.  As a module author (such as link:$$https://github.com/infinispan/infinispan/tree/master/tree$$[infinispan-tree] , link:$$https://github.com/infinispan/infinispan/tree/master/query$$[infinispan-query] , etc.) you can now define your own commands.  You do so by: 
+ However, since Infinispan 5.0, this capability has now been added.  As a module author (such as link:$$https://github.com/infinispan/infinispan/tree/master/tree$$[infinispan-tree] , link:$$https://github.com/infinispan/infinispan/tree/master/query$$[infinispan-query] , etc.) you can now define your own commands.  From Infinispan 5.1 onwards, you do so by: 
 
 
-.  Creating an infinispan-module.properties file and ensuring that this is packaged in the root of your jar file. 
+.  Create a META-INF/services/org.infinispan.commands.module.ModuleCommandExtensions file and ensure this is packaged in your jar. 
 
 
 .  Implementing 
               link:$$https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/commands/module/ModuleCommandFactory.java$$[ModuleCommandFactory]
              and 
               link:$$https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/commands/module/ModuleCommandInitializer.java$$[ModuleCommandInitializer]
-             from infinispan-core 
+             from infinispan-core . 
 
 
-.  Specifing the fully-qualified class names of your implementations in infinispan-module.properties 
+.  Implementing 
+              link:$$https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/commands/module/ModuleCommandExtensions.java$$[ModuleCommandExtensions]
+             from infinispan-core . 
+
+
+.  Specifing the fully-qualified class name of the 
+              link:$$https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/commands/module/ModuleCommandExtensions.java$$[ModuleCommandExtensions]
+             implementation in META-INF/services/org.infinispan.commands.module.ModuleCommandExtensions . 
 
 
 . Implement your custom commands and visitors for these commands
 
- Here is an example of an infinispan-modules.properties file, configured accordingly: 
+ Here is an example of an META-INF/services/org.infinispan.commands.module.ModuleCommandExtensions file, configured accordingly: 
+
+.org.infinispan.commands.module.ModuleCommandExtensions
+
+==== 
+----
+
+1. org.infinispan.query.QueryModuleCommandExtensions
+
+----
+
+==== 
+ For a full, working example of a sample module that makes use of custom commands and visitors, check out link:$$https://github.com/infinispan/infinispan-sample-module$$[Infinispan Sample Module] . 
+
+[[sid-68355204_WritingcustomcommandsinInfinispan-PreassignedCustomCommandIdRanges]]
+
+
+=== Preassigned Custom Command Id Ranges
+
+ This is the list of Command identifiers that are used by Infinispan based modules or frameworks. Infinispan users should avoid using ids within these ranges. (RANGES to be finalised yet!) Being this a single byte, ranges can't be too large. 
+
+
+|===============
+|Infinispan Query:|100 - 119
+|Hibernate Search:|120 - 139
 
-Code Snippet error: Unable to retrieve the URL: https://github.com/infinispan/infinispan-sample-module/raw/master/src/main/resources/infinispan-module.properties status code: 404.
+|===============
 
- For a full, working example of a sample module that makes use of custom commands and visitors, check out link:$$https://github.com/infinispan/infinispan-sample-module$$[] . 
 
diff --git a/documentation/src/main/asciidoc/faqs/chapter-1-Project_FAQs.adoc b/documentation/src/main/asciidoc/faqs/chapter-1-Project_FAQs.adoc
index 51e0f6c..b53bded 100644
--- a/documentation/src/main/asciidoc/faqs/chapter-1-Project_FAQs.adoc
+++ b/documentation/src/main/asciidoc/faqs/chapter-1-Project_FAQs.adoc
@@ -1,4 +1,4 @@
-[[sid-8093834_FrequentlyAskedQuestions-ProjectFAQs]]
+[[sid-68354929_FrequentlyAskedQuestions-ProjectFAQs]]
 
 ==  Project FAQs
 
diff --git a/documentation/src/main/asciidoc/faqs/chapter-2-Technical_FAQs.adoc b/documentation/src/main/asciidoc/faqs/chapter-2-Technical_FAQs.adoc
index e75bd3f..c9023de 100644
--- a/documentation/src/main/asciidoc/faqs/chapter-2-Technical_FAQs.adoc
+++ b/documentation/src/main/asciidoc/faqs/chapter-2-Technical_FAQs.adoc
@@ -1,4 +1,4 @@
-[[sid-8093834_FrequentlyAskedQuestions-TechnicalFAQs]]
+[[sid-68354929_FrequentlyAskedQuestions-TechnicalFAQs]]
 
 ==  Technical FAQs
 
diff --git a/documentation/src/main/asciidoc/faqs/chapter-3-Project_Evaluation_FAQs.adoc b/documentation/src/main/asciidoc/faqs/chapter-3-Project_Evaluation_FAQs.adoc
index 50d19db..273fb46 100644
--- a/documentation/src/main/asciidoc/faqs/chapter-3-Project_Evaluation_FAQs.adoc
+++ b/documentation/src/main/asciidoc/faqs/chapter-3-Project_Evaluation_FAQs.adoc
@@ -1,38 +1,38 @@
-[[sid-8093835]]
+[[sid-68354930]]
 
 ==  Project Evaluation FAQs
 
 
-*  <<sid-8093836>> 
+*  <<sid-68354932>> 
 
 
-*  <<sid-8093845>> 
+*  <<sid-68354941>> 
 
 
-*  <<sid-8093837>> 
+*  <<sid-68354933>> 
 
 
-*  <<sid-8093838>> 
+*  <<sid-68354934>> 
 
 
-*  <<sid-8093839>> 
+*  <<sid-68354935>> 
 
 
-*  <<sid-8093840,How come Infinispan's first release is 4.0.0?  This sounds weird!>> 
+*  <<sid-68354936,How come Infinispan's first release is 4.0.0?  This sounds weird!>> 
 
 
-*  <<sid-8093841>> 
+*  <<sid-68354937>> 
 
 
-*  <<sid-8093842>> 
+*  <<sid-68354938>> 
 
 
-*  <<sid-8093843>> 
+*  <<sid-68354939>> 
 
 
-*  <<sid-8093844>> 
+*  <<sid-68354940>> 
 
-[[sid-8093836]]
+[[sid-68354932]]
 
 
 === What is Infinispan?
@@ -62,14 +62,14 @@ So, why would you use it? Infinispan offers:
 
 *  _Support for Compute Grids_ - Infinispan 5 adds the ability to pass a Runnable around the grid. This allows you to push complex processing towards the server where data is local, and pull back results using a Future . This map/reduce style paradigm is common in applications where a large amount of data is needed to compute relatively small results. 
 
-[[sid-8093845]]
+[[sid-68354941]]
 
 
 === What would I use Infinispan for?
 
  Infinispan's link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html$$[org.infinispan.Cache] is a simple, flat data structure that can optionally include characteristics such as distribution, eviction, link:$$http://en.wikipedia.org/wiki/Java_Transaction_API$$[JTA] compatibility. 
 
-[[sid-8093837]]
+[[sid-68354933]]
 
 
 === How is Infinispan related to JBoss Cache?
@@ -80,42 +80,42 @@ The current release of JBoss Cache, 3.2.3, is considered stable enough.  No new
 
 So, why not just call it JBoss Cache 4?. Several reasons.  Binary and even API compatibility with older JBoss Cache releases is no longer maintained, and the new API is simpler and easier to use.  Also, the internal data structure used is not compatible with JBoss Cache.
 
-[[sid-8093838]]
+[[sid-68354934]]
 
 
 === What version of Java does Infinispan need to run? Does Infinispan need an application server to run?
 
  All that is needed is a Java 6.0 compatible JVM. An application server is _not_ a requirement. 
 
-[[sid-8093839]]
+[[sid-68354935]]
 
 
 === Will there be a POJO Cache replacement in Infinispan?
 
- Yes.  A fine-grained API is on the link:$$http://community.jboss.org/wiki/InfinispanRoadmap$$[roadmap] , currently scheduled for Infinispan 5.1.  Notably, this fine-grained API will not use bytecode weaving and AOP like POJO Cache did, and instead will use a much more robust and powerful session-based design.  See this page for more details on this. 
+ Yes, and this is called link:$$http://www.hibernate.org/subprojects/ogm.html$$[Hibernate OGM] . 
 
-[[sid-8093840]]
+[[sid-68354936]]
 
 
 === How come Infinispan's first release is 4.0.0?  This sounds weird!
 
 We didn't want to release Infinispan as a 1.0, as in all fairness it is not a virgin codebase.  A lot of the code, designs and ideas in Infinispan are from JBoss Cache, and has been tried and tested, proven in high stress environments.  Infinispan should thus be viewed as a mature and stable platform and not a new, experimental one.
 
-[[sid-8093841]]
+[[sid-68354937]]
 
 
 === What should I use, JBoss Cache or Infinispan?
 
 If you are starting a new project, by all means use Infinispan.  If you already use JBoss Cache, consider upgrading to Infinispan as this is where most of our focus and efforts will be.  There is a compatibility layer to help people migrate, although we recommend only using this if you (a) absolutely need a tree structure, or (b) only for a short time as a stepping stone.  You will find that Infinispan's Map based API performs much better.  In addition, we plan to provide migration guides and configuration conversion tools.
 
-[[sid-8093842]]
+[[sid-68354938]]
 
 
 === Where can I get more information on Infinispan?
 
  The link:$$http://www.jboss.org/infinispan$$[Infinispan project page] is your best place to start things off, whether you are interested in using Infinispan in your work or are interested in collaborating on and contributing to Infinispan. 
 
-[[sid-8093843]]
+[[sid-68354939]]
 
 
 === How is this related to JSR 107, the JCACHE specification?
@@ -124,7 +124,7 @@ If you are starting a new project, by all means use Infinispan.  If you already
 
  link:$$http://community.jboss.org/people/manik$$[Manik Surtani] , who is project lead on Infinispan, and link:$$http://in.relation.to/Bloggers/Pete$$[Pete Muir] are on the JSR 107 expert group. 
 
-[[sid-8093844]]
+[[sid-68354940]]
 
 
 === Can I use Infinispan with Hibernate?
@@ -135,7 +135,7 @@ Yes, you can combine one or more of these integrations in the same application:
 *  _Caching database access_ : Hibernate can cache frequently loaded entities and queries in Infinispan, taking advantage of state of the art eviction algorithms, and clustering if needed but it provides a good performance boost in non-clustered deployments too. See link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737110$$[Using Infinispan as JPA/Hibernate Second Level Cache Provider] for details on how to do this. 
 
 
-*  _Storing Lucene indexes_ : When using Hibernate Search to provide full-text capabilities to your Hibernate/JPA enabled application, you need to store an Apache Lucene index separately from the database. You can store the index in Infinispan: this is ideal for clustered applications since it's otherwise tricky to share the index with correct locking on shared file systems, but is an interesting option for non-clustered deployments too as it can combine the benefits of in-memory performance with reliability and write-through to cloud storage backends like S3, or the Hibernate database itself. See link:$$http://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/#infinispan-directories$$[Infinispan Directory Configuration] in the Hibernate Search reference documentation for the integration details, or learn more about it at link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737047$$[Infinispan as a storage for Lucene indexes] . 
+*  _Storing Lucene indexes_ : When using Hibernate Search to provide full-text capabilities to your Hibernate/JPA enabled application, you need to store an Apache Lucene index separately from the database. You can store the index in Infinispan: this is ideal for clustered applications since it's otherwise tricky to share the index with correct locking on shared file systems, but is an interesting option for non-clustered deployments too as it can combine the benefits of in-memory performance with reliability and write-through to cloud storage backends like S3, or the Hibernate database itself. See link:$$http://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/#infinispan-directories$$[Infinispan Directory Configuration] in the Hibernate Search reference documentation for the integration details, or learn more about it at <<sid-68355039>> . 
 
 
 *  _Using Infinispan as a database replacement_ : using the experimental Hibernate Object/Grid Mapper (OGM) you can remove the database and store your entities and relations in the grid directly, interacting with it through the well known JPA(2) interface, with some limitations in the query capabilities. For more details see link:$$http://www.hibernate.org/subprojects/ogm.html$$[Hibernate Object/Grid Mapper (OGM)] . 
diff --git a/documentation/src/main/asciidoc/faqs/chapter-4-Technical_FAQs.adoc b/documentation/src/main/asciidoc/faqs/chapter-4-Technical_FAQs.adoc
index e04fcbe..992765d 100644
--- a/documentation/src/main/asciidoc/faqs/chapter-4-Technical_FAQs.adoc
+++ b/documentation/src/main/asciidoc/faqs/chapter-4-Technical_FAQs.adoc
@@ -1,257 +1,280 @@
-[[sid-8093846]]
+[[sid-68354942]]
 
 ==  Technical FAQs
 
 
-*  <<sid-8093847>> 
+*  <<sid-68354943>> 
 
 
-*  <<sid-8093850>> 
+*  <<sid-68354944>> 
 
 
-*  <<sid-8093848>> 
+*  <<sid-68354945>> 
 
 
-*  <<sid-8093849>> 
+*  <<sid-68354946>> 
 
 
-*  <<sid-8093851>> 
+*  <<sid-68354947>> 
 
 
-*  <<sid-8093852>> 
+*  <<sid-68454081>> 
 
 
-*  <<sid-8093855>> 
+*  <<sid-68354948>> 
 
 
-*  <<sid-8093853>> 
+*  <<sid-68354949>> 
 
 
-*  <<sid-8093856>> 
+*  <<sid-68354952>> 
 
 
-*  <<sid-8093854>> 
+*  <<sid-68354950>> 
 
 
-*  <<sid-8093857>> 
+*  <<sid-68354953>> 
 
 
-*  <<sid-8093860>> 
+*  <<sid-68354951>> 
 
 
-*  <<sid-8093861>> 
+*  <<sid-68354955>> 
 
 
-*  <<sid-8093862>> 
+*  <<sid-68354956>> 
 
 
-*  <<sid-8093858>> 
+*  <<sid-68354959>> 
 
 
-*  <<sid-8093859>> 
+*  <<sid-68354960>> 
 
 
-*  <<sid-8093863>> 
+*  <<sid-68354961>> 
 
 
-*  <<sid-8093864>> 
+*  <<sid-68354957>> 
 
 
-*  <<sid-8093865>> 
+*  <<sid-68354958>> 
 
 
-*  <<sid-8093866>> 
+*  <<sid-68354962>> 
 
 
-*  <<sid-8093868>> 
+*  <<sid-68354963>> 
 
 
-*  <<sid-8093867>> 
+*  <<sid-68354964>> 
 
 
-*  <<sid-8093869>> 
+*  <<sid-68354968>> 
 
 
-*  <<sid-8093871>> 
+*  <<sid-68354965>> 
 
 
-*  <<sid-8093872>> 
+*  <<sid-68354967>> 
 
 
-*  <<sid-8093870>> 
+*  <<sid-68354966>> 
 
 
-*  <<sid-8093873>> 
+*  <<sid-68354969>> 
 
 
-*  <<sid-8093874>> 
+*  <<sid-68354971>> 
 
 
-*  <<sid-8093875>> 
+*  <<sid-68354972>> 
 
 
-*  <<sid-8093880>> 
+*  <<sid-68354973>> 
 
 
-*  <<sid-8093877>> 
+*  <<sid-68354970>> 
 
 
-*  <<sid-8093879>> 
+*  <<sid-68354974>> 
 
 
-*  <<sid-8093876>> 
+*  <<sid-68354975>> 
 
 
-*  <<sid-8093878>> 
+*  <<sid-68354977>> 
 
 
-*  <<sid-8093881>> 
+*  <<sid-68354982>> 
 
 
-*  <<sid-8093882>> 
+*  <<sid-68354979>> 
 
 
-*  <<sid-8093883>> 
+*  <<sid-68354981>> 
 
 
-*  <<sid-8093884>> 
+*  <<sid-68354978>> 
 
 
-*  <<sid-8093885>> 
+*  <<sid-68354980>> 
 
 
-*  <<sid-8093886>> 
+*  <<sid-68354983>> 
 
 
-*  <<sid-8093887>> 
+*  <<sid-68354984>> 
 
 
-*  <<sid-8093888>> 
+*  <<sid-68354985>> 
 
 
-*  <<sid-8093889>> 
+*  <<sid-68354986>> 
 
 
-*  <<sid-8093891>> 
+*  <<sid-68354987>> 
 
 
-*  <<sid-8093890>> 
+*  <<sid-68354988>> 
 
 
-*  <<sid-8093892>> 
+*  <<sid-68354989>> 
 
 
-*  <<sid-8093893>> 
+*  <<sid-68354990>> 
 
 
-*  <<sid-8093894>> 
+*  <<sid-68354991>> 
 
 
-*  <<sid-8093895>> 
+*  <<sid-68354992>> 
 
 
-*  <<sid-8093896>> 
+*  <<sid-68354993>> 
 
 
-*  <<sid-8093897>> 
+*  <<sid-68354995>> 
 
 
-*  <<sid-8093898>> 
+*  <<sid-68354994>> 
 
 
-*  <<sid-8093899>> 
+*  <<sid-68354996>> 
 
 
-*  <<sid-8093905>> 
+*  <<sid-68354997>> 
 
 
-*  <<sid-8093901>> 
+*  <<sid-68354998>> 
 
 
-*  <<sid-8093906>> 
+*  <<sid-68354999>> 
 
 
-*  <<sid-8093902>> 
+*  <<sid-68355000>> 
 
 
-*  <<sid-8093903>> 
+*  <<sid-68355001>> 
 
 
-*  <<sid-8093900>> 
+*  <<sid-68355002>> 
 
 
-*  <<sid-8093904>> 
+*  <<sid-68355003>> 
 
 
-*  <<sid-8093907>> 
+*  <<sid-68355009>> 
 
 
-*  <<sid-8093908>> 
+*  <<sid-68355005>> 
 
 
-*  <<sid-8093909>> 
+*  <<sid-68355010>> 
 
 
-*  <<sid-8093910>> 
+*  <<sid-68355006>> 
 
 
-*  <<sid-8093911>> 
+*  <<sid-68355007>> 
 
 
-*  <<sid-8093915>> 
+*  <<sid-68355004>> 
 
 
-*  <<sid-8093914>> 
+*  <<sid-68355008>> 
 
 
-*  <<sid-8093912>> 
+*  <<sid-68355011>> 
 
 
-*  <<sid-8093913>> 
+*  <<sid-68355012>> 
 
 
-*  <<sid-8093916>> 
+*  <<sid-68355013>> 
 
 
-*  <<sid-8093917>> 
+*  <<sid-68355014>> 
 
 
-*  <<sid-8093918>> 
+*  <<sid-68355015>> 
 
 
-*  <<sid-8093919>> 
+*  <<sid-68355019>> 
 
 
-*  <<sid-8093920>> 
+*  <<sid-68355018>> 
 
 
-*  <<sid-8093921>> 
+*  <<sid-68355016>> 
 
 
-*  <<sid-8093922>> 
+*  <<sid-68355017>> 
 
-[[sid-8093847]]
+
+*  <<sid-68355020>> 
+
+
+*  <<sid-68355021>> 
+
+
+*  <<sid-68355023>> 
+
+
+*  <<sid-68355022>> 
+
+
+*  <<sid-68355024>> 
+
+
+*  <<sid-68355025>> 
+
+
+*  <<sid-68355026>> 
+
+
+*  <<sid-68355027>> 
+
+[[sid-68354943]]
 
 
 === General FAQs
 
 
-*  <<sid-8093850>> 
+*  <<sid-68354944>> 
 
 
-*  <<sid-8093848>> 
+*  <<sid-68354945>> 
 
 
-*  <<sid-8093849>> 
+*  <<sid-68354946>> 
 
-[[sid-8093850]]
 
+*  <<sid-68354947>> 
 
-==== Is Infinispan's configuration compatible with JBoss Cache?
 
-No.  But we intend to provide transformation scripts.  Keep in mind though that as long as you use custom components - custom interceptors, cache loaders, eviction policies - we will not be able to translate these and this would have to be done manually.
+*  <<sid-68454081>> 
 
-[[sid-8093848]]
+[[sid-68354944]]
 
 
 ==== What APIs does Infinispan offer?
@@ -272,34 +295,62 @@ No.  But we intend to provide transformation scripts.  Keep in mind though tha
 ==== 
 
 
-[[sid-8093849]]
+[[sid-68354945]]
 
 
 ==== Which JVMs (JDKs) does Infinispan work with?
 
 Infinispan is developed and primarily tested against Sun's Java SE 6.  It should work with most Java SE 6 implementations, including those from IBM, HP, Apple, Oracle (BEA), and IcedTea.  We expect to test on Java SE 7 once this is finalized as well.
 
-[[sid-8093851]]
+[[sid-68354946]]
+
+
+==== Is Infinispan's configuration compatible with JBoss Cache?
+
+No.  But we intend to provide transformation scripts.  Keep in mind though that as long as you use custom components - custom interceptors, cache loaders, eviction policies - we will not be able to translate these and this would have to be done manually.
+
+[[sid-68354947]]
+
+
+==== Grouping API vs Key Affinity Service
+
+ The key affinity (for keys generated with the link:$$https://docs.jboss.org/author/display/ISPN/Key+affinity+service$$[Key Affinity Service] ) might be lost during topology changes. E.g. if k1 maps to node N1 and another node is added to the system, k1 can me migrated to N2 (affinity is lost). With link:$$https://docs.jboss.org/author/display/ISPN/The+Grouping+API$$[grouping API] you have the guarantee that the same node (you don't know/control which node) hosts all the data from the same group even after topology changes. 
+
+[[sid-68454081]]
+
+
+==== Does Infinispan store data by value or by reference?
+
+By default, Infinispan stores data by reference. So once clients store some data, clients can still modify entries via original object references. This means that since client references are valid, clients can make changes to entries in the cache using those references, but these modifications are only local and you still need to call one of the cache's put/replace... methods in order for changes to replicate.
+
+ Obviously, allowing clients to modify cache contents directly, without any cache invocation, has some risks and that's why Infinispan offers the possibility to store data by value instead. The way store-by-value is enabled is by <<sid-68355106,enabling Infinispan to store data in binary format and forcing it to do these binary transformations eagerly>> . 
+
+The reason Infinispan stores data by-reference instead of by-value is performance. Storing data by reference is quicker than doing it by value because it does not have the penalty of having to transform keys and values into their binary format.
+
+[[sid-68354948]]
 
 
 === Cache Loaders and Cache Store FAQs
 
 
-*  <<sid-8093852>> 
+*  <<sid-68354949>> 
+
+
+*  <<sid-68354952>> 
 
 
-*  <<sid-8093855>> 
+*  <<sid-68354950>> 
 
 
-*  <<sid-8093853>> 
+*  <<sid-68354953>> 
 
 
-*  <<sid-8093856>> 
+*  <<sid-68354951>> 
 
 
-*  <<sid-8093854>> 
+*  <<sid-68354955>> 
 
-[[sid-8093852]]
+[[sid-68354949]]
 
 
 ==== Cache loaders and cache stores - what's the difference?
@@ -315,7 +366,7 @@ Infinispan ships with several high performance implementations of these interfac
 ==== 
 
 
-[[sid-8093855]]
+[[sid-68354952]]
 
 
 ==== Are modifications to asynchronous cache stores coalesced or aggregated?
@@ -324,57 +375,78 @@ Before 4.0.0.Beta1, cache store modifications were queued in such way that a mod
 
  Since 4.0.0.Beta1 ( link:$$https://jira.jboss.org/jira/browse/ISPN-116$$[ISPN-116] ), modifications are coalesced or aggregated for the interval that the modification processor thread is currently applying. This means that while changes are being queued, if multiple modifications are made to the same key, only the key's last state will be applied, hence reducing the number of calls to the cache store. 
 
-[[sid-8093853]]
+[[sid-68354950]]
 
 
-==== In JBoss Cache, the JDBC and File CacheLoaders had restrictions such as only being able to use Strings in Fqns.  Is this still the case in Infinispan?
+==== In JBoss Cache, the JDBC and File CacheLoaders had restrictions such as only being able to use Strings in Fqns. Is this still the case in Infinispan?
 
  No.  We have completely re-written these implementations with a much better design which allows us to use arbitrary keys (or Fqn elements if using the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/tree/TreeCache.html$$[TreeCache] API), provided they are serializable.  For details, see the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/loader/bucket/BucketBasedCacheStore.html$$[BucketBasedCacheStore] . 
 
-[[sid-8093856]]
+[[sid-68354953]]
 
 
 ==== What does the passivation flag do?
 
  Passivation is a mode of storing entries in the cache store _only when_ they are evicted from memory.  The benefit of this approach is to prevent a lot of expensive writes to the cache store if an entry is hot (frequently used) and hence _not_ evicted from memory.  The reverse process, known as _activation_ , occurs when a thread attempts to access an entry which is _not_ in memory but is in the store (i.e., a _passivated_ entry).  Activation involves loading the entry into memory, and then _removing_ it from the cache store.  With passivation enabled, the cache uses the cache store as an overflow tank, akin to link:$$http://en.wikipedia.org/wiki/Paging$$[swapping memory pages to disk] in link:$$http://en.wikipedia.org/wiki/Virtual_memory$$[virtual memory] implementations in operating systems. 
 
- If passivation is disabled, the cache store behaves as a <<sid-8094006>> (or <<sid-8094007>> if asynchronous) cache, where all entries in memory are also maintained in the cache store.  The effect of this is that the cache store will always contain a superset of what is in memory. 
+ If passivation is disabled, the cache store behaves as a <<sid-68355172>> (or <<sid-68355173>> if asynchronous) cache, where all entries in memory are also maintained in the cache store.  The effect of this is that the cache store will always contain a superset of what is in memory. 
 
-[[sid-8093854]]
+[[sid-68354951]]
 
 
 ==== What if I get IOException "Unsupported protocol version 48" with JdbcStringBasedCacheStore?
 
  You have probably set your data column type to VARCHAR , CLOB or something similar, but it should be BLOB/VARBINARY . Even though it's called JdbcStringBasedCacheStore , only the keys are required to be strings; the values can be anything, so they need to be stored in a binary column. See the link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/loaders/jdbc/AbstractNonDelegatingJdbcCacheStoreConfig.html#setDataColumnType%28java.lang.String%29$$[setDataColumnType javadoc] for more details. 
 
-[[sid-8093857]]
+[[sid-68354955]]
+
+
+==== Is there any way I can boost cache store's performance? SKIP_CACHE_LOAD
+
+If, for put operations, you don't need the previous values existing in the cache/store then the following optimisation can be made:
+
+.Skip cache store read
+
+==== 
+----
+
+cache.getAdvancedCache().withFlags(Flag.SKIP_CACHE_LOAD).put(key, value);
+
+----
+
+==== 
+ Note that in this case the value returned by cache.put is not reliable. This optimisation skips a cache store read and can have very significant performance improvement effects. 
+
+ More flags are described at link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737122$$[Per-Invocation Flags] 
+
+[[sid-68354956]]
 
 
 === Locking FAQs
 
 
-*  <<sid-8093860>> 
+*  <<sid-68354959>> 
 
 
-*  <<sid-8093861>> 
+*  <<sid-68354960>> 
 
 
-*  <<sid-8093862>> 
+*  <<sid-68354961>> 
 
 
-*  <<sid-8093858>> 
+*  <<sid-68354957>> 
 
 
-*  <<sid-8093859>> 
+*  <<sid-68354958>> 
 
-[[sid-8093860]]
+[[sid-68354959]]
 
 
 ==== Does Infinispan support distributed eager locking?
 
 Yes it does. Infinispan, by default, acquires remote locks lazily.  Locks are acquired locally on a node that runs a transaction while other cluster nodes attempt to lock cache keys involved in a transaction during two-phase prepare/commit phase. However, if desired, Infinispan can eagerly lock cache keys either explicitly or implicitly.
 
-[[sid-8093861]]
+[[sid-68354960]]
 
 
 ==== How does Infinispan support explicit eager locking?
@@ -393,7 +465,7 @@ Consider a transaction running on one of the cache nodes:
 
 ----
 
-[[sid-8093862]]
+[[sid-68354961]]
 
 
 ==== How does Infinispan support implicit eager locking?
@@ -424,31 +496,31 @@ Implicit eager locking is enabled as follows:
 
 ----
 
-[[sid-8093858]]
+[[sid-68354957]]
 
 
 ==== JBoss Cache exposed several different locking schemes - pessimistic, optimistic and MVCC.  I don't see a way to specify locking scheme in Infinispan.  Why is this?
 
 This is because Infinispan only supports MVCC.  MVCC is by far more performant, threadsafe and consistent than the other locking schemes.
 
-[[sid-8093859]]
+[[sid-68354958]]
 
 
 ==== What isolation levels does Infinispan support?
 
- Infinispan only supports the isolation levels <<sid-8094031>> and <<sid-8094032>> . 
+ Infinispan only supports the isolation levels <<sid-68355197>> and <<sid-68355198>> . 
 
- The default isolation mode is <<sid-8094031>> .  Unlike JBoss Cache, which used <<sid-8094032>> by default.  We consider <<sid-8094031>> to be good enough for most applications and hence its use as a default. 
+ The default isolation mode is <<sid-68355197>> .  Unlike JBoss Cache, which used <<sid-68355198>> by default.  We consider <<sid-68355197>> to be good enough for most applications and hence its use as a default. 
 
-[[sid-8093863]]
+[[sid-68354962]]
 
 
 === Transaction FAQs
 
 
-*  <<sid-8093864>> 
+*  <<sid-68354963>> 
 
-[[sid-8093864]]
+[[sid-68354963]]
 
 
 ==== When using Atomikos transaction manager, distributed caches are not distributing data, what is the problem?
@@ -463,21 +535,31 @@ There're two ways to get around this issue, either:
 
 .  If using Infinispan 4.2.1.CR1 or earlier, link:$$http://www.atomikos.com/Documentation/JtaProperties$$[configure Atomikos so that com.atomikos.icatch.threaded_2pc is set to false] . This results in commits happening in the same thread that made the cache operations. 
 
-[[sid-8093865]]
+[[sid-68354964]]
 
 
 === Eviction and Expiration FAQs
 
 
-*  <<sid-8093866>> 
+*  <<sid-68354968>> 
+
+
+*  <<sid-68354965>> 
+
+
+*  <<sid-68354967>> 
+
 
+*  <<sid-68354966>> 
 
-*  <<sid-8093868>> 
+[[sid-68354968]]
 
 
-*  <<sid-8093867>> 
+==== Cache's number of entries never reaches configured maxEntries, why is that?
 
-[[sid-8093866]]
+ In the current eviction design, eviction happens per map segment, so when the segment gets filled up, eviction runs in that segment. This means that the theoretical maxEntries might never be achieved, but it'll be close enough. For more information, see the <<sid-68355088,eviction documentation>> . 
+
+[[sid-68354965]]
 
 
 ==== Expiration does not work, what is the problem?
@@ -492,14 +574,14 @@ There're two ways to get around this issue, either:
 
  If you have not enabled (2), or your eviction thread wakeup interval is large and you probe jconsole before the eviction thread kicks in, you will still see the expired entry.  You can be assured that if you tried to _retrieve_ the entry via a get() or containsKey() though, you won't see the entry (and the entry will be removed). 
 
-[[sid-8093868]]
+[[sid-68354967]]
 
 
 ==== Why is cache size sometimes even higher than specified maxEntries of the eviction configuration element?
 
 Although one can specify maxEntries to be a value that is not a power of two, the underlying algorithm will size it to the value V closest to power of two that is larger than maxEntries specified. Eviction algorithms guarantee that the size of cache container will never be greater than V.
 
-[[sid-8093867]]
+[[sid-68354966]]
 
 
 ==== Why isn't there a notification for the expiration of a cache entry?
@@ -517,77 +599,90 @@ Infinispan does not guarantee that an eviction will occur immediately on timeout
 
  As the eviction is only guaranteed to happen _some time later_ than the eviction timeout has elapsed, it has been decided that it is less surprising to not provide a callback than to provide a callback at this later point. 
 
-[[sid-8093869]]
+[[sid-68354969]]
 
 
 === Cache Manager FAQs
 
 
-*  <<sid-8093871>> 
+*  <<sid-68354971>> 
+
+
+*  <<sid-68354972>> 
 
 
-*  <<sid-8093872>> 
+*  <<sid-68354973>> 
 
 
-*  <<sid-8093870>> 
+*  <<sid-68354970>> 
 
-[[sid-8093871]]
+[[sid-68354971]]
 
 
 ==== Can I create caches using different cache modes using the same cache manager?
 
 Yes.  You can create caches using different cache modes, both synchronous and asynchronous, using the same cache manager.
 
-[[sid-8093872]]
+[[sid-68354972]]
 
 
 ==== Can transactions span different Cache instances from the same cache manager?
 
 Yes.  Each cache behaves as a separate, standalone JTA resource.  Internally though, components may be shared as an optimization but this in no way affects how the caches interact with a JTA manager.
 
-[[sid-8093870]]
+[[sid-68354973]]
+
+
+==== How does multi-tenancy work?
+
+Multi-tenancy is achieved by namespacing.  A single Infinispan cluster can have several named caches (attached to the same CacheManager), and different named caches can have duplicate keys.  So this is, in effect, multi-tenancy for your key/value store.
+
+[[sid-68354970]]
 
 
 ==== Infinispan allows me to create several Caches from a single CacheManager.  Are there any reasons to create separate CacheManagers?
 
 As far as possible, internal components are shared between Cache instances.  Notably, RPC and networking components are shared.  If you need caches that have different network characteristics - such as one cache using TCP while another uses UDP - we recommend you create these using different cache managers.
 
-[[sid-8093873]]
+[[sid-68354974]]
 
 
 === Cache Mode FAQs
 
 
-*  <<sid-8093874>> 
+*  <<sid-68354975>> 
+
+
+*  <<sid-68354977>> 
 
 
-*  <<sid-8093875>> 
+*  <<sid-68354982>> 
 
 
-*  <<sid-8093880>> 
+*  <<sid-68354979>> 
 
 
-*  <<sid-8093877>> 
+*  <<sid-68354981>> 
 
 
-*  <<sid-8093879>> 
+*  <<sid-68354978>> 
 
 
-*  <<sid-8093876>> 
+*  <<sid-68354980>> 
 
 
-*  <<sid-8093878>> 
+*  <<sid-68354983>> 
 
-[[sid-8093874]]
+[[sid-68354975]]
 
 
 ==== What is the difference between a replicated cache and a distributed cache?
 
  Distribution is a new cache mode in Infinispan, in addition to replication and invalidation.  In a replicated cache all nodes in a cluster hold all keys i.e. if a key exists on one nodes, it will also exist on _all_ other mpdes.  In a distributed cache, a number of copies are maintained to provide redundancy and fault tolerance, however this is typically far fewer than the number of nodes in the cluster. A distributed cache provides a far greater degree of scalability than a replicated cache.  
 
- A distributed cache is also able to transparently locate keys across a cluster, and provides an L1 cache for fast local read access of state that is stored remotely.  You can read more in <<sid-8093951_Clusteringmodes-DistributionMode,the reference guide>> . 
+ A distributed cache is also able to transparently locate keys across a cluster, and provides an L1 cache for fast local read access of state that is stored remotely.  You can read more in <<sid-68355074_Clusteringmodes-DistributionMode,the reference guide>> . 
 
-[[sid-8093875]]
+[[sid-68354977]]
 
 
 ==== Does DIST support both synchronous and asynchronous communications?
@@ -596,76 +691,118 @@ As far as possible, internal components are shared between Cache instances.  No
 
  Now unofficially, we will add a configuration option to allow you to set your cache mode to DIST _and_ use asynchronous communications, but this would be an additional configuration option (perhaps something like break_api_contracts ) so that users are aware of what they are getting into. 
 
-[[sid-8093880]]
+[[sid-68354982]]
 
 
 ==== I have caches configured with asynchronous replication or distribution, but these caches appear to be behaving synchronously (waiting for responses), what is going on?
 
  If you have state transfer configured and you have asynchronous mode configured, caches will behave in a synchronous way. This is done so that state transfer can work as expected, but the current solution expands the synchronous calls to cache operations as well, which results in this unexpected behaivour. A better solution that will resolve this confusion is already link:$$https://issues.jboss.org/browse/ISPN-835$$[in the making] (this issue also contains currently viable workarounds). 
 
-[[sid-8093877]]
+[[sid-68354979]]
 
 
-==== I notice that when using DIST, the cache does a remote get before a write command.  Why is this?
+==== I notice that when using DIST, the cache does a remote get before a write command. Why is this?
 
- Certain methods, such as Cache.put() , are supposed to return the previous value associated with the specified key according to the java.util.Map contract.  If this is performed on an instance that does _not_ own the key in question and the key is not in L1 cache, the only way to reliably provide this return value is to do a remote GET before the put.  This GET is _always_ sync (regardless of whether the cache is configured to be sync or async) since we need to wait for that return value. 
+ Certain methods, such as Cache.put() , are supposed to return the previous value associated with the specified key according to the java.util.Map contract. If this is performed on an instance that does _not_ own the key in question and the key is not in L1 cache, the only way to reliably provide this return value is to do a remote GET before the put. This GET is _always_ sync (regardless of whether the cache is configured to be sync or async) since we need to wait for that return value. 
 
-[[sid-8093877_InoticethatwhenusingDIST%2Cthecachedoesaremotegetbeforeawritecommand.%C2%A0Whyisthis%3F-Isn%27tthatexpensive%3F%C2%A0HowcanIoptimizethisaway%3F]]
+[[sid-68354979_InoticethatwhenusingDIST%2Cthecachedoesaremotegetbeforeawritecommand.Whyisthis%3F-Isn%27tthatexpensive%3FHowcanIoptimizethisaway%3F]]
 
 
-===== Isn't that expensive?  How can I optimize this away?
+===== Isn't that expensive? How can I optimize this away?
 
- It isn't as expensive as it sounds.  A remote GET, although sync, will _not_ wait for all responses.  It will accept the first valid response and move on, thus making its performance has no relation to cluster size. 
+ It isn't as expensive as it sounds. A remote GET, although sync, will _not_ wait for all responses. It will accept the first valid response and move on, thus making its performance has no relation to cluster size. 
 
- If you feel your code has no need for these return values, then this can be disabled completely (by specifying the &lt;unsafe unreliableReturnValues="true" /&gt; configuration element for a cache-wide setting or the Flag.SKIP_REMOTE_LOOKUP for a per-invocation setting).  Note that while this will _not_ impair cache operations and accurate functioning of all public methods is still maintained. However, it _will_ break the java.util.Map interface contract by providing unreliable and inaccurate return values to certain methods, so you would need to be certain that your code does not use these return values for anything useful. 
+ If you feel your code has no need for these return values, then this can be disabled completely (by specifying the &lt;unsafe unreliableReturnValues="true" /&gt; configuration element for a cache-wide setting or the Flag.SKIP_REMOTE_LOOKUP for a per-invocation setting). Note that while this will _not_ impair cache operations and accurate functioning of all public methods is still maintained. However, it _will_ break the java.util.Map interface contract by providing unreliable and inaccurate return values to certain methods, so you would need to be certain that your code does not use these return values for anything useful. 
 
-[[sid-8093879]]
+[[sid-68354981]]
 
 
-==== I use a clustered cache.  I want the guarantees of synchronous replication with the parallelism of asynchronous replication.  What can I do?
+==== I use a clustered cache. I want the guarantees of synchronous replication with the parallelism of asynchronous replication. What can I do?
 
- Infinispan offers a new async API to provide just this.  These async methods return Futures which can be queried, causing the thread to block till you get a confirmation that any network calls succeeded.  You can link:$$http://infinispan.blogspot.com/2009/05/whats-so-cool-about-asynchronous-api.html$$[read more about it] . 
+ Infinispan offers a new async API to provide just this. These async methods return Future which can be queried, causing the thread to block till you get a confirmation that any network calls succeeded. You can link:$$http://infinispan.blogspot.com/2009/05/whats-so-cool-about-asynchronous-api.html$$[read more about it] . 
 
-[[sid-8093876]]
+[[sid-68354978]]
 
 
 ==== Is buddy replication supported?
 
  Buddy Replication is not available in Infinispan.  The new distributed cache mode solves the same problems in a far more elegant and scalable manner.  Read link:$$http://infinispan.blogspot.com/2009/08/distribution-instead-of-buddy.html$$[this blog article] for a more detailed discussion on the subject. 
 
-[[sid-8093878]]
+[[sid-68354980]]
 
 
 ==== What is the L1 cache?
 
-An L1 cache (enabled by default, can be disabled) only exists if you set your cache mode to distribution.  An L1 cache prevents unnecessary remote fetching of entries mapped to remote caches by storing them locally for a short time after the first time they are accessed.  By default, entries in L1 have a lifespan of 60,000 milliseconds (though you can configure how long L1 entries are cached for).  L1 entries are also invalidated when the entry is changed elsewhere in the cluster so you are sure you don't have stale entries cached in L1.  Caches with L1 enabled will consult the L1 cache before fetching an entry from a remote cache.
+An L1 cache (disabled by default) only exists if you set your cache mode to distribution.  An L1 cache prevents unnecessary remote fetching of entries mapped to remote caches by storing them locally for a short time after the first time they are accessed.  By default, entries in L1 have a lifespan of 60,000 milliseconds (though you can configure how long L1 entries are cached for).  L1 entries are also invalidated when the entry is changed elsewhere in the cluster so you are sure you don't have stale entries cached in L1.  Caches with L1 enabled will consult the L1 cache before fetching an entry from a remote cache.
 
  Also known as a _near cache_ in competing distributed cache products. 
 
-[[sid-8093881]]
+[[sid-68354983]]
+
+
+==== What consistency guarantees do I have with different Asynchronous processing settings ?
+
+There are 3 main configuration settings (modes of usage) that affect the behaviour of Infinispan in terms of Asynchronous processing, summarized in the following table:
+
+[options="header"]
+|===============
+| Config / Mode of usage | Description 
+| _API_ | Usage of link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737045$$[Asynchronous API] , i.e. methods of the Cache interface like e.g. putAsync(key, val) 
+| _Marshalling_ | Allowing link:$$https://docs.jboss.org/author/display/ISPN/Asynchronous+Options#AsynchronousOptions-AsynchronousMarshalling$$[Asynchronous Marshalling] , in cache configuration (via XML or programmatic configuration) 
+| _Replication_ | Configuring a clustered cache to replicate data asychronously. In Infinispan XML configuration this is done by using &lt;sync&gt; or &lt;async&gt; sub-elements under link:$$http://docs.jboss.org/infinispan/5.1/configdocs/urn_infinispan_config_5.1/complexType/configuration.clustering.html$$[&lt;clustering&gt;] element. 
+
+|===============
+
+
+Switching to asynchronous mode in each of these areas causes loss of some consistency guarrantees. The known problems are summarised here:
+
+[options="header"]
+|===============
+|API| Replication | Marshalling | Consistency problems 
+| Sync | Sync | Sync | 
+| Sync | _Async_ | Sync | _1_ - Cache entry is replicated with a delay or not at all in case of network error. _2_ - Node where the operation originated won't be notified about errors that happened on network or on the receiving side. 
+| Sync | _Async_ | _Async_ | _1, 2_ _3_ - Calling order of sync API method might not be preserved – depends on which operation finishes marshalling first in the asyncExecutor _4_ - Replication of put operation can be applied on different nodes in different order – this may result in inconsistent values 
+| _Async_ | Sync | Sync | _3_ 
+| _Async_ | _Async_ | Sync | _1, 2, 3_ 
+| _Async_ | _Async_ | _Async_ | _1, 2, 3, 4_ 
+
+|===============
+
+
+[[sid-68354984]]
 
 
 === Listener FAQs
 
 
-*  <<sid-8093882>> 
+*  <<sid-68354985>> 
+
+
+*  <<sid-68354986>> 
 
-[[sid-8093882]]
+[[sid-68354985]]
 
 
 ==== In a cache entry modified listener, can the modified value be retrieved via Cache.get() when isPre=false?
 
  No, it cannot. Use CacheEntryModifiedEvent.getValue() to retrieve the value of the entry that was modified. 
 
-[[sid-8093883]]
+[[sid-68354986]]
+
+
+==== When annotating a method with CacheEntryCreated, how do I retrieve the value of the cache entry added?
+
+ <<sid-68355087,Cache listeners>> can be defined to listen for cache entry created events by annotation methods with link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/notifications/cachelistener/annotation/CacheEntryCreated.html$$[@CacheEntryCreated] and having link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/notifications/cachelistener/event/CacheEntryCreatedEvent.html$$[CacheEntryCreatedEvent] as method parameter. link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/notifications/cachelistener/event/CacheEntryCreatedEvent.html$$[CacheEntryCreatedEvent] does not provide a method to retrieve the value that was created in the cache though. To retrieve this value, a method annotated with link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/notifications/cachelistener/annotation/CacheEntryModified.html$$[@CacheEntryModified] needs to be added because every time a cache entry is created, cache entry modified event is also fired. 
+
+[[sid-68354987]]
 
 
 === Cloud FAQs
 
 
-*  <<sid-8093884>> 
+*  <<sid-68354988>> 
 
-[[sid-8093884]]
+[[sid-68354988]]
 
 
 ==== How do you make Infinispan send replication traffic over a specific network when you don't know the IP address?
@@ -686,45 +823,45 @@ Some cloud providers charge you less for traffic over internal IP addresses comp
 
 *  NON_LOOPBACK : use the first address found on an interface (which is up), which is not a 127.x.x.x address 
 
-[[sid-8093885]]
+[[sid-68354989]]
 
 
 === Demo FAQs
 
-[[sid-8093886]]
+[[sid-68354990]]
 
 
-==== When using the GUI Demo, I've just put an entry in the cache with lifespan of -1.  Why do I see it as having a lifespan of 60,000?
+==== When using the GUI Demo, I've just put an entry in the cache with lifespan of -1. Why do I see it as having a lifespan of 60,000?
 
  This is probably a L1 caching event.  When you put an entry in the cache, the entry is mapped to specific nodes in a cluster using a consistent hashing algorithm.  This means that key K could map on to caches A  and B  (or however many owners you have configured).  If you happen to have done the cache.put(K, V) on cache C , however, K  still maps to A  and B  (and will be added to caches A  and B  with their proper lifespans), but it will also be put in cache C's L1 cache. 
 
-[[sid-8093887]]
+[[sid-68354991]]
 
 
 === Query Module FAQs
 
 
-*  <<sid-8093888>> 
+*  <<sid-68354992>> 
 
-[[sid-8093888]]
+[[sid-68354992]]
 
 
 ==== When I run an application based on the Query module, I get a ClassNotFoundException for org.slf4j.impl.StaticLoggerBinder. How do I solve it?
 
  See the SLF4J section in link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737030$$[the reference guide] . 
 
-[[sid-8093889]]
+[[sid-68354993]]
 
 
 === JBoss Application Server Integration FAQs
 
 
-*  <<sid-8093891>> 
+*  <<sid-68354995>> 
 
 
-*  <<sid-8093890>> 
+*  <<sid-68354994>> 
 
-[[sid-8093891]]
+[[sid-68354995]]
 
 
 ==== Can I run my own Infinispan cache within JBoss Application Server 5 or 4?
@@ -766,22 +903,22 @@ Yes, you can, but since Infinispan uses different JGroups jar libraries to the o
 
 ----
 
-[[sid-8093890]]
+[[sid-68354994]]
 
 
 ==== Can I run my own Infinispan cache within JBoss Application Server 6?
 
  Yes you can, it's all explained in the link:$$http://community.jboss.org/docs/16180$$[Infinispan and AS6 integration wiki] . 
 
-[[sid-8093892]]
+[[sid-68354996]]
 
 
 === Logging FAQs
 
 
-*  <<sid-8093893>> 
+*  <<sid-68354997>> 
 
-[[sid-8093893]]
+[[sid-68354997]]
 
 
 ==== How can I enable logging?
@@ -792,7 +929,7 @@ By default Infinispan uses JBoss Logging 3.0 as logging framework. JBoss Logging
 . checking whether the JBoss Log Manager is configured (e.g. Infinispan is running in JBoss Application Server 7) and if it is, using it
 
 
-.  otherwise, checking if link:$$http://logging.apache.org/log4j/1.2/index.html$$[Apache Log4j] is in the classpath (JBoss Logging checks if the classes org.apache.log4j.LogManager and org.apache.log4j.Hierarchy } are available) and if it is, using it 
+.  otherwise, checking if link:$$http://logging.apache.org/log4j/1.2/index.html$$[Apache Log4j] is in the classpath (JBoss Logging checks if the classes org.apache.log4j.LogManager and org.apache.log4j.Hierarchy are available) and if it is, using it 
 
 
 .  otherwise, checking if link:$$http://logback.qos.ch/$$[LogBack] in the classpath (JBoss Logging checks if the class ch.qos.logback.classic.Logger is available) and if it is, using it 
@@ -805,25 +942,25 @@ By default Infinispan uses JBoss Logging 3.0 as logging framework. JBoss Logging
               link:$$file:/path/to/log4j.xml$$[]
              ). 
 
-[[sid-8093894]]
+[[sid-68354998]]
 
 
 === Third Party Container FAQs
 
 
-*  <<sid-8093895>> 
+*  <<sid-68354999>> 
 
 
-*  <<sid-8093896>> 
+*  <<sid-68355000>> 
 
-[[sid-8093895]]
+[[sid-68354999]]
 
 
 ==== Can I use Infinispan on Google App Engine for Java?
 
  Not at this moment.  Due to GAE/J restricting classes that can be loaded, and restrictions around use of threads, Infinispan will not work on GAE/J.  However, we do plan to fix this - if you wish to track the progress of Infinispan on GAE/J, have a look at link:$$https://jira.jboss.org/jira/browse/ISPN-57$$[ISPN-57] . 
 
-[[sid-8093896]]
+[[sid-68355000]]
 
 
 ==== When running on Glassfish or Apache, creating a cache throws an exception saying "Unable to construct a GlobalComponentRegistry", what is it wrong?
@@ -837,62 +974,62 @@ Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());
 
 ----
 
-[[sid-8093897]]
+[[sid-68355001]]
 
 
 === Language FAQs
 
 
-*  <<sid-8093898>> 
+*  <<sid-68355002>> 
 
-[[sid-8093898]]
+[[sid-68355002]]
 
 
-==== Can I use Infinispan with Groovy?  What about Jython, Clojure, JRuby or Scala etc.?
+==== Can I use Infinispan with Groovy? What about Jython, Clojure, JRuby or Scala etc.?
 
-While we haven't extensively tested Infinispan on anything other than Java, there is no reason why it cannot be used in any other environment that sits atop a JVM.  We encourage you to try, and we'd love to hear your experiences on using Infinispan from other JVM languages.
+While we haven't extensively tested Infinispan on anything other than Java, there is no reason why it cannot be used in any other environment that sits atop a JVM. We encourage you to try, and we'd love to hear your experiences on using Infinispan from other JVM languages.
 
-[[sid-8093899]]
+[[sid-68355003]]
 
 
 === Marshalling &amp; Unmarshalling
 
 
-*  <<sid-8093905>> 
+*  <<sid-68355009>> 
 
 
-*  <<sid-8093901>> 
+*  <<sid-68355005>> 
 
 
-*  <<sid-8093906>> 
+*  <<sid-68355010>> 
 
 
-*  <<sid-8093902>> 
+*  <<sid-68355006>> 
 
 
-*  <<sid-8093903>> 
+*  <<sid-68355007>> 
 
 
-*  <<sid-8093900>> 
+*  <<sid-68355004>> 
 
 
-*  <<sid-8093904>> 
+*  <<sid-68355008>> 
 
-[[sid-8093905]]
+[[sid-68355009]]
 
 
 ==== Best practices implementing java.io.Externalizable
 
  If you decide to implement link:$$http://download.oracle.com/javase/6/docs/api/java/io/Externalizable.html$$[Externalizable] interface, please make sure that the link:$$http://download.oracle.com/javase/6/docs/api/java/io/Externalizable.html#readExternal(java.io.ObjectInput)$$[readExternal()] method is thread safe, otherwise you run the risk of potential getting corrupted data and link:$$http://download.oracle.com/javase/6/docs/api/java/lang/OutOfMemoryError.html$$[OutOfMemoryException] , as seen in link:$$http://community.jboss.org/message/609296#609296$$[this forum post] . 
 
-[[sid-8093901]]
+[[sid-68355005]]
 
 
 ==== Does Infinispan support storing Non-Serializable objects?
 
- See <<sid-8093979_Marshalling-SupportForNonSerializableObjects,the reference guide>> . 
+ See <<sid-68355106_Marshalling-SupportForNonSerializableObjects,the reference guide>> . 
 
-[[sid-8093906]]
+[[sid-68355010]]
 
 
 ==== Do Externalizer implementations need to access internal Externalizer implementations?
@@ -941,14 +1078,14 @@ public static class ABCMarshallingExternalizer implements AdvancedExternalizer<A
 }
 ----
 
-[[sid-8093902]]
+[[sid-68355006]]
 
 
 ==== Do I need to register an application cacheloader when using an isolated deployment?
 
  In JBossCache when dealing with isolated deployments, registering application cacheloader with cache was needed for replication to work. With Infinispan, there's no such need, link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737168_Marshalling-LazyDeserialization%2528storeAsBinary%2529$$[lazy deserialization] is used to get around the issue. 
 
-[[sid-8093903]]
+[[sid-68355007]]
 
 
 ==== During state transfer, the state receiver logs an EOFException when applying state saying "Read past end of file". Should I worry about this?
@@ -1006,14 +1143,14 @@ java.io.EOFException: Read past end of file
 
 The current logic is for the state receiver to back off in these scenarios and retry after a few seconds. Quite often, after the retry the state generator might have already finished dealing with the other node and hence the state receiver will be able to fully receive the state.
 
-[[sid-8093900]]
+[[sid-68355004]]
 
 
 ==== How do I get more information on marshalling &amp; unmarshalling exceptions?
 
- See <<sid-8093979,the reference guide>> . 
+ See <<sid-68355106_Marshalling-Troubleshooting,the reference guide>> . 
 
-[[sid-8093904]]
+[[sid-68355008]]
 
 
 ==== Why am I getting invalid data passed to readExternal?
@@ -1030,15 +1167,15 @@ The current logic is for the state receiver to back off in these scenarios and r
 ==== 
 
 
-[[sid-8093907]]
+[[sid-68355011]]
 
 
 === Tuning FAQs
 
 
-*  <<sid-8093908>> 
+*  <<sid-68355012>> 
 
-[[sid-8093908]]
+[[sid-68355012]]
 
 
 ==== When running Infinispan under load, I see RejectedExecutionException, how can I fix it?
@@ -1067,17 +1204,17 @@ To solve this issue, you should try any of these options:
 *  Define your own ExecutorFactory which creates an executor with a bigger queue. You can find more information about different queueing strategies in link:$$http://java.sun.com/javase/6/docs/api/java/util/concurrent/ThreadPoolExecutor.html$$[ThreadPoolExecutor javadoc] . 
 
 
-*  Disable async marshalling (see the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/config.html#ce_clustering_async$$[&lt;async ... &gt;] element for details). This would mean that an executor is _not_ used when replicating, so you will never have a RejectedExecutionException . However this means each put() will take a little longer since marshalling will now happen on the critical path. The RPC is still async though as the thread won't wait for a response from the recipient (fire-and-forget). 
+*  Disable async marshalling (see the link:$$http://docs.jboss.org/infinispan/5.1/configdocs/urn_infinispan_config_5.1/complexType/configuration.clustering.async.html$$[&lt;async ... &gt;] element for details). This would mean that an executor is _not_ used when replicating, so you will never have a RejectedExecutionException . However this means each put() will take a little longer since marshalling will now happen on the critical path. The RPC is still async though as the thread won't wait for a response from the recipient (fire-and-forget). 
 
-[[sid-8093909]]
+[[sid-68355013]]
 
 
 === JNDI FAQs
 
 
-*  <<sid-8093910>> 
+*  <<sid-68355014>> 
 
-[[sid-8093910]]
+[[sid-68355014]]
 
 
 ==== Can I bind Cache or CacheManager to JNDI?
@@ -1086,45 +1223,45 @@ To solve this issue, you should try any of these options:
 
  To find an example on how to bind Cache or CacheManager to the java: namespace, simply check link:$$https://github.com/infinispan/infinispan/blob/master/core/src/test/java/org/infinispan/jndi/BindingTest.java$$[this unit test case] . 
 
-[[sid-8093911]]
+[[sid-68355015]]
 
 
 === Hibernate 2nd Level Cache FAQs
 
 
-*  <<sid-8093915>> 
+*  <<sid-68355019>> 
 
 
-*  <<sid-8093914>> 
+*  <<sid-68355018>> 
 
 
-*  <<sid-8093912>> 
+*  <<sid-68355016>> 
 
 
-*  <<sid-8093913>> 
+*  <<sid-68355017>> 
 
-[[sid-8093915]]
+[[sid-68355019]]
 
 
 ==== Can I use Infinispan as a remote JPA or Hibernate second level cache?
 
  See link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737110$$[the reference guide] . 
 
-[[sid-8093914]]
+[[sid-68355018]]
 
 
-==== I'm adding the Infinispan 2nd level cache provider to existing servers that already use JGroups.  Should I set Infinispan to use the same JGroups cluster, or should I use two separate cluster names?
+==== I'm adding the Infinispan 2nd level cache provider to existing servers that already use JGroups. Should I set Infinispan to use the same JGroups cluster, or should I use two separate cluster names?
 
 TODO
 
-[[sid-8093912]]
+[[sid-68355016]]
 
 
 ==== Is it possible to use the Infinispan 2nd level cache outside of a J2EE server, and if so how do I set up the transaction manager lookup?
 
  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737110$$[The reference guide] provides details on configuring a transaction manager outside of Java EE. link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737126$$[The reference guide] also provides details on how to use Atomikos, JTOM and Bitronix. 
 
-[[sid-8093913]]
+[[sid-68355017]]
 
 
 ==== What are the pitfalls of not using a non-JTA transaction factory such as JDBCTransactionFactory with Hibernate when Infinispan is used as 2nd level cache provider?
@@ -1133,18 +1270,21 @@ TODO
 
 So, any work on the 2nd level cache will be done under a different transaction to the one used to commit the stuff to the database via Hibernate. In other words, your operations on the database and the 2LC are not treated as a single unit. Risks here include failures to update the 2LC leaving it with stale data while the database committed data correctly.
 
-[[sid-8093916]]
+[[sid-68355020]]
 
 
 === Cache Server FAQs
 
 
-*  <<sid-8093917>> 
+*  <<sid-68355021>> 
+
 
+*  <<sid-68355023>> 
 
-*  <<sid-8093918>> 
 
-[[sid-8093917]]
+*  <<sid-68355022>> 
+
+[[sid-68355021]]
 
 
 ==== After running a Hot Rod server for a while, I get a NullPointerException in HotRodEncoder.getTopologyResponse(), how can I get around it?
@@ -1157,19 +1297,26 @@ So, any work on the 2nd level cache will be done under a different transaction t
 
 *  Or, make sure you create a namedCache for ___hotRodTopologyCache with sync replication, state transfer, no expiration and no eviction. 
 
-[[sid-8093918]]
+[[sid-68355023]]
+
+
+==== Is there a way to do a Bulk Get on a remote cache?
+
+ There's no bulk get operation in Hot Rod, but the Java Hot Rod client has implemented via link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/client/hotrod/RemoteCache.html$$[RemoteCache] the getAsync() operation, which returns a link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/util/concurrent/NotifyingFuture.html$$[org.infinispan.util.concurrent.NotifyingFuture] (extends java.util.concurrent.Future). So, if you want to retrieve multiple keys in parallel, just call multiple times _getAsync()_ and when you need the values, just call _Future.get()_ , or attach a link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/util/concurrent/FutureListener.html$$[ _FutureListener_ ] to the _NotifyingFuture_ to get notified when the value is ready. 
+
+[[sid-68355022]]
 
 
 ==== What is the startServer.sh script used for? What is the startServer.bat script used for?
 
  These scripts are used for starting Infinispan server instances that can be talked to remotely using either our own link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=9470083$$[Hot Rod protocol] or the link:$$http://github.com/trondn/memcached/blob/master/doc/protocol.txt$$[Memcached text protocol] . See link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737146$$[Using Hot Rod Server and Client] and link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737037$$[Using Infinispan Memcached server] wikis for more information on the usage of these scripts. 
 
-[[sid-8093919]]
+[[sid-68355024]]
 
 
 === Debugging FAQs
 
-[[sid-8093920]]
+[[sid-68355025]]
 
 
 ==== How can I get Infinispan to show the full byte array? The log only shows partial contents of byte arrays...
@@ -1202,12 +1349,12 @@ version=281483566645249}]
 
 ----
 
-[[sid-8093921]]
+[[sid-68355026]]
 
 
 === Clustering Transport FAQs
 
-[[sid-8093922]]
+[[sid-68355027]]
 
 
 ==== How do I retrieve the clustering physical address?
diff --git a/documentation/src/main/asciidoc/getting_started/chapter-1-Introduction.adoc b/documentation/src/main/asciidoc/getting_started/chapter-1-Introduction.adoc
index e61f279..ef25e63 100644
--- a/documentation/src/main/asciidoc/getting_started/chapter-1-Introduction.adoc
+++ b/documentation/src/main/asciidoc/getting_started/chapter-1-Introduction.adoc
@@ -1,4 +1,4 @@
-[[sid-8093985_GettingStartedGuide-Introduction]]
+[[sid-68355130_GettingStartedGuide-Introduction]]
 
 ==  Introduction
 
diff --git a/documentation/src/main/asciidoc/getting_started/chapter-10-Using_Infinispan_in_servlet_containers_such_as_Tomcat_or_Jetty_and_other_application_servers_such_as_GlassFish_.adoc b/documentation/src/main/asciidoc/getting_started/chapter-10-Using_Infinispan_in_servlet_containers_such_as_Tomcat_or_Jetty_and_other_application_servers_such_as_GlassFish_.adoc
index 658ccda..a2a281e 100644
--- a/documentation/src/main/asciidoc/getting_started/chapter-10-Using_Infinispan_in_servlet_containers_such_as_Tomcat_or_Jetty_and_other_application_servers_such_as_GlassFish_.adoc
+++ b/documentation/src/main/asciidoc/getting_started/chapter-10-Using_Infinispan_in_servlet_containers_such_as_Tomcat_or_Jetty_and_other_application_servers_such_as_GlassFish_.adoc
@@ -1,4 +1,4 @@
-[[sid-8093985_GettingStartedGuide-UsingInfinispaninservletcontainers%28suchasTomcatorJetty%29andotherapplicationservers%28suchasGlassFish%29]]
+[[sid-68355130_GettingStartedGuide-UsingInfinispaninservletcontainers%28suchasTomcatorJetty%29andotherapplicationservers%28suchasGlassFish%29]]
 
 ==  Using Infinispan in servlet containers (such as Tomcat or Jetty) and other application servers (such as GlassFish)
 
diff --git a/documentation/src/main/asciidoc/getting_started/chapter-11-Monitoring_Infinispan.adoc b/documentation/src/main/asciidoc/getting_started/chapter-11-Monitoring_Infinispan.adoc
index 89f9173..fc2c3d6 100644
--- a/documentation/src/main/asciidoc/getting_started/chapter-11-Monitoring_Infinispan.adoc
+++ b/documentation/src/main/asciidoc/getting_started/chapter-11-Monitoring_Infinispan.adoc
@@ -1,4 +1,4 @@
-[[sid-8093985_GettingStartedGuide-MonitoringInfinispan]]
+[[sid-68355130_GettingStartedGuide-MonitoringInfinispan]]
 
 ==  Monitoring Infinispan
 
diff --git a/documentation/src/main/asciidoc/getting_started/chapter-16-Infinispan_GUI_demo.adoc b/documentation/src/main/asciidoc/getting_started/chapter-16-Infinispan_GUI_demo.adoc
index c630dfa..3558c46 100644
--- a/documentation/src/main/asciidoc/getting_started/chapter-16-Infinispan_GUI_demo.adoc
+++ b/documentation/src/main/asciidoc/getting_started/chapter-16-Infinispan_GUI_demo.adoc
@@ -1,4 +1,4 @@
-[[sid-8093986]]
+[[sid-68355134]]
 
 ==  Infinispan GUI demo
 
@@ -9,7 +9,7 @@
 NOTE: You will need either the -bin.zip or -all.zip version for this demo.
 ----
 
-[[sid-8093986_InfinispanGUIdemo-Step1%3AStartthedemoGUI]]
+[[sid-68355134_InfinispanGUIdemo-Step1%3AStartthedemoGUI]]
 
 
 === Step 1: Start the demo GUI
@@ -39,7 +39,7 @@ image::[]
 
  
 
-[[sid-8093986_InfinispanGUIdemo-Step3%3AManipulatedata]]
+[[sid-68355134_InfinispanGUIdemo-Step3%3AManipulatedata]]
 
 
 === Step 3: Manipulate data
@@ -52,7 +52,7 @@ image::[]
 
  
 
-[[sid-8093986_InfinispanGUIdemo-Step4%3AStartmorecacheinstances]]
+[[sid-68355134_InfinispanGUIdemo-Step4%3AStartmorecacheinstances]]
 
 
 === Step 4: Start more cache instances
@@ -65,7 +65,7 @@ image::[]
 
  
 
-[[sid-8093986_InfinispanGUIdemo-Step5%3AManipulatemoredata]]
+[[sid-68355134_InfinispanGUIdemo-Step5%3AManipulatemoredata]]
 
 
 === Step 5: Manipulate more data
diff --git a/documentation/src/main/asciidoc/getting_started/chapter-18-Labs.adoc b/documentation/src/main/asciidoc/getting_started/chapter-18-Labs.adoc
new file mode 100644
index 0000000..d8f913c
--- /dev/null
+++ b/documentation/src/main/asciidoc/getting_started/chapter-18-Labs.adoc
@@ -0,0 +1,952 @@
+[[sid-68355154]]
+
+==  Labs
+
+[[sid-68355155]]
+
+
+=== Lab - Getting Started with Infinispan
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Introduction]]
+
+
+==== Introduction
+
+ This lab was developed for Devoxx 2011, by Pete Muir, Mircea Markus and Sanne Grinovero. It is designed to last around 1h 45m, and has an accompanying introduction and conclusion. Full slide deck is link:$$https://docs.jboss.org/author/download/attachments/12484897/Real_world_deep_dive_into_Infinispan.ppt$$[attached] . 
+
+The lab has been updated by Galder Zamarreño for Infinispan 5.1 and has been featured in the Neuchatel JBUG and JUDCon India 2012
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Setup]]
+
+
+==== Setup
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Gettingsetuptorunthelab]]
+
+
+===== Getting setup to run the lab
+
+ _presented by Pete_ _5 minutes_ 
+
+
+* Using Infinispan 5.1.0.FINAL
+
+
+* Download the lab zip from [...]
+
+
+* Unzip the lab to your disk to a location of your choice
+
+
+* If you are a git user, you can clone the repository:
+
+
+----
+
+git clone git://github.com/infinispan/infinispan-labs.git
+
+----
+
+
+* each stage of this lab has a checkpoint which is a branch, you can check out the code for each Checkpoint using. Checkpoints are mentioned in these instructions:
+
+
+----
+
+git checkout -b checkpointX checkpointX
+
+----
+
+
+*  Download JBoss AS 7.1.0.CR1b from link:$$http://jboss.org/jbossas/downloads$$[] 
+
+
+* Unzip JBoss AS to your disk to a location of your choice
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Introductionx]]
+
+
+==== Introduction
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Usecases%2CkeyfeaturesandbenefitsofInfinispan]]
+
+
+===== Use cases, key features and benefits of Infinispan
+
+ _slides, presented by Pete_ _20 minutes_ 
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Sampleproject]]
+
+
+==== Sample project
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Explanationofsampleprojectarchitecture]]
+
+
+===== Explanation of sample project architecture
+
+ _presented by Pete_ _5 minutes_ 
+
+
+* The lab is a simple ticket allocation and booking system
+
+
+*  lab1 contains a project skeleton with the relevant dependencies available. It is a war, that can be deployed on JBoss AS 7. It also use CDI to wire together the app, and JSF for the view layer. JMS is used to provide messaging and EJB to provide a listener for messages we send via JMS. 
+
+
+*  In another console, start JBoss AS - $JBOSS_HOME/bin/standalone.sh 
+
+
+*  Deploy the project to JBoss AS 7 using mvn clean package jboss-as:deploy 
+
+
+*  visit link:$$http://localhost:8080/lab1$$[] 
+
+
+* All cache operations hidden by service layer to allow us to swap out caching impls
+
+
+* Starts with a HashMap and builds on that
+
+
+* Import the project into your IDE, we use Eclipse with m2eclipse installed.
+
+
+* Show project
+
+ _Checkpoint 1_ 
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-InterludeCachinginJavaEE]]
+
+
+==== Interlude - Caching in Java EE
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-JSR107%28JCACHE%29andJSR347%28DatagridsforJava%29]]
+
+
+===== 107 (JCACHE) and JSR-347 (Datagrids for Java)
+
+ _presented by Pete_ _5 minutes_ 
+
+Topics covered include:
+
+
+* TODO
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-JGroups%26Networks]]
+
+
+==== JGroups &amp; Networks
+
+ _presented by Sanne_ _10 minutes_ 
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Makesureyournodescanseeeachother]]
+
+
+===== Make sure your nodes can see each other
+
+
+*  In LAB_HOME/nic_test there is the the test-network script. Run it. 
+
+
+* If all goes well, you'll get two windows in which you can draw up on your screen. Draw on one, see it in both.
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-HowdoesJGroupswork%3FWhydoyouneedit%3F]]
+
+
+===== How does JGroups work? Why do you need it?
+
+Topics covered include:
+
+
+* what is JGroups? library for reliable multicasting ...
+
+
+* main features: fragmentation, retransmission, flow control, reordering, group membership (notifications)
+
+
+* LAN/WAN based: multicast or TCP for transport
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-InfinispanasalocalcacheandJMX]]
+
+
+==== Infinispan as a local cache and JMX
+
+ _presented by Sanne_ _10 minutes_ 
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-AddingInfinispantothedemo]]
+
+
+===== Adding Infinispan to the demo
+
+ _Use Case: Take advantage of the features of Infinispan_ 
+
+
+*  Uncomment the Infinispan dependencies in pom.xml 
+
+
+*  Copy in Resources.java and TicketAllocationCache.java and explain what they are doing; you will find them in LAB_HOME/lab1/src/samples/java 
+
+
+* Explain about configuring caches programmatically with qualifier
+
+
+*  Copy SimpleTicketService to InfinispanTicketService 
+
+
+*  Make SimpleTicketService an alternative 
+
+
+----
+
+private final List<TicketAllocation> tickets = new ArrayList<TicketAllocation>();
+----
+
+with
+
+
+----
+
+@Inject @TicketAllocationCache
+private Cache<String, TicketAllocation> tickets;
+
+----
+
+ to inject the Infinispan cache. Change the allocateTicket method to: 
+
+
+----
+
+TicketAllocation allocation = new TicketAllocation(allocatedTo, event);
+tickets.put(allocation.getId(), allocation);
+
+----
+
+ and change the getAllocatedTickets() method to 
+
+
+----
+
+return new ArrayList<TicketAllocation>(tickets.values());
+
+----
+
+ and change the getTicketAllocation(String id) method to: 
+
+
+----
+
+return tickets.get(id);
+
+----
+
+ Implement getNodeId() properly: 
+
+
+----
+
+if (tickets.getConfiguration().getCacheMode() != CacheMode.LOCAL)
+   return tickets.getAdvancedCache().getCacheManager().getAddress().toString();
+else
+   return "local cache";
+
+----
+
+ Implement getOwners() properly: 
+
+
+----
+
+if (tickets.getConfiguration().getCacheMode() != CacheMode.LOCAL) {
+   return asCommaSeparatedList(tickets.getAdvancedCache().getDistributionManager().locate(key));
+} else {
+   return "local";
+}
+
+----
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-ShowInfinispaninusewithbasicmonitoring]]
+
+
+===== Show Infinispan in use with basic monitoring
+
+ _Use Case: Can see how our cache is performing_ 
+
+
+*  Enable JMX - add .jmxStatistics().enable() to the fluent configuration in Resources . 
+
+
+* Redeploy, and use the app
+
+
+* We can see the cache starting in the console
+
+
+*  Run jconsole or jvisualvm , and select the "jboss-modules" process 
+
+
+*  Open up the Infinispan statistics (via MBeans tab in jvisualvm - you might need to install the MBeans plugin first) 
+
+
+* Allocate a ticket, show the stores change
+
+ _Checkpoint 2_ 
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Expiration%26Eviction]]
+
+
+==== Expiration &amp; Eviction
+
+ _presented by Mircea_ _10 minutes_ 
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-InterludeWhatisexpiration%3FWhatiseviction%3F]]
+
+
+===== Interlude - What is expiration? What is eviction?
+
+Topics covered include:
+
+
+* API
+
+
+* Configuration
+
+
+* Use cases
+
+
+* Available eviction mechanisms
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Demo]]
+
+
+===== Demo
+
+
+* Use Case: Have ticket allocations freed up after a period of time*
+
+
+*  Add expiration to allocateTicket() , so you end up with 
+
+
+----
+
+tickets.put(allocation.getId(), allocation, 10, TimeUnit.SECONDS);
+
+----
+
+
+* Run the demo, and you can see that entries disappear after 10s
+
+ _Checkpoint 3_ 
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-6.Listeners]]
+
+
+==== 6. Listeners
+
+ _presented by Mircea_ _10 minutes_ 
+
+ _Use case: Prevent known ticket touts from using the system_ 
+
+
+* First, copy in the AbuseListener in
+
+
+* Now, we need to register it
+
+Add
+
+
+----
+
+@Inject
+public void registerAbuseListener(@New AbuseListener abuseListener) {
+   tickets.addListener(abuseListener);
+}
+
+----
+
+ to the InfinispanTicketService . 
+
+
+*  this code simply creates a new abuse listener (injected by CDI with a logger!) and registers it with Infinispan. It will do it automatically when the InfinispanTicketService is created 
+
+ _Increase expiration to 3 minutes, otherwise the demo will get tiresome!_ 
+
+ _Checkpoint 4_ 
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Interlude.WhatcanyoulistentoinInfinispan%3F]]
+
+
+===== Interlude. What can you listen to in Infinispan?
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-TransactionswithInfinispan]]
+
+
+==== Transactions with Infinispan
+
+ _presented by Mircea_ _15 minutes_ 
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Transactionsinaction]]
+
+
+===== Transactions in action
+
+ _Use Case: When ticket is booked, need to atomically take payment and book ticket, and rollback if any errors_ 
+
+
+* The webapp collects all the data from the user to process the booking, and then sends the booking to the backend using JMS.
+
+
+* JBoss comes with a "test" queue, we'll abuse that so we don't have to configure messaging (not what we are here to talk about).
+
+
+* Go to the pom.xml and uncomment JMS dependency
+
+
+*  Copy the PaymentProcessor into .services 
+
+
+*  Inject JMS into InfinispanTicketService 
+
+
+----
+
+@Resource(mappedName="/ConnectionFactory")
+private ConnectionFactory cf;
+
+@Resource(mappedName = "queue/test")
+private Queue queue;
+
+----
+
+
+*  Implement the bookTicket method 
+
+
+----
+
+try {
+       Connection connection = cf.createConnection();
+       Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
+       MessageProducer publisher = session.createProducer(queue);
+       connection.start();
+       TextMessage message = session.createTextMessage("Book ticket for " + id);
+       publisher.send(message);
+       connection.close();
+       session.close();
+    } catch (JMSException e) {
+       throw new RuntimeException(e);
+    }
+
+----
+
+This code is in bookTicket.txt in the samples
+
+
+* Run the example, show it in action.
+
+ _Checkpoint 5a_ 
+
+ _Use case: Introduce XA transactions_ 
+
+
+* Add to the configuration (Resources.configureCache):
+
+
+----
+
+.transaction().transactionMode(TransactionMode.TRANSACTIONAL)
+.transaction().transactionManagerLookup(new GenericTransactionManagerLookup())
+
+----
+
+
+* Replace the injection of the Connection Factory with
+
+
+----
+
+@Resource(mappedName="/JmsXA")
+private XAConnectionFactory cf;
+
+@Resource(mappedName = "java:jboss/TransactionManager")
+private TransactionManager tm;
+
+----
+
+ finally, upgrade the bookTicket method: 
+
+
+----
+
+try {
+   XAConnection connection = null;
+   try {
+      connection = cf.createXAConnection();
+      connection.start();
+
+      XASession xaSession = connection.createXASession();
+
+      Session session = xaSession.getSession();
+      MessageProducer publisher = session.createProducer(queue);
+
+      TextMessage message = session.createTextMessage("Book ticket for " + id);
+
+      tm.begin();
+
+      tm.getTransaction().enlistResource(xaSession.getXAResource());
+
+      //following two ops need to be atomic (XA)
+      tickets.remove(id);
+      publisher.send(message);
+
+      tm.commit();
+   } finally {
+      if (connection != null) connection.close();
+   }
+} catch (Throwable e) {
+   // ignore - don't do this at home :)
+   e.printStackTrace();
+}
+
+----
+
+
+*  _Interlude - Transactions deep dive_ 
+
+Topics discussed include
+
+
+* Transaction types
+
+
+* Locking
+
+
+* Deadlock detection
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Break]]
+
+
+==== Break
+
+ _15 minutes_ 
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Distribution]]
+
+
+==== Distribution
+
+ _presented by Sanne_ _15 minutes_ 
+
+ _Use case: we have so many tickets being allocated we've run out of heap on one machine, so add some more!_ 
+
+
+* During the break we added support for distribution. Take you through the changes now
+
+
+*  Enable distribution mode in Resources 
+
+
+----
+
+.clustering()
+         .mode(CacheMode.DIST_SYNC)
+         .l1().disable()
+
+----
+
+
+* Make JGroups use the loopback interface to avoid network problems! Add
+
+
+----
+
+@Produces @ApplicationScoped
+public EmbeddedCacheManager configureCacheManager() {
+   return new DefaultCacheManager(
+      GlobalConfigurationBuilder.defaultClusteredBuilder()
+         .transport()
+            .addProperty("configurationFile", "jgroups.xml")
+         .build());
+}
+
+----
+
+
+*  Add jgroups.xml from src/sample to src/main/resources (directory needs creating) 
+
+
+*  Explain that this JGroups file is exactly as normal for UDP, except that the jgroups.bind_addr is set to the loopback interface 
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-InterludeJBossAS7]]
+
+
+==== Interlude - JBoss AS 7
+
+Topics discussed include:
+
+
+* Introduce AS7
+
+
+* Cover domain mode vs standalone
+
+
+* Domain mode a great way to stand up a cluster of nodes!
+
+
+* Explain management options (CLI, web, maven plugin, XML, filesystem)
+
+
+* Talk about Infinispan as managed service in AS7 vs embedded - we could have used either, but to get started quickly it's easy to embed!
+
+
+*  Show 5 servers configured in $JBOSS_HOME/domain/configuration/host.xml - explain about port bindings. If you are following along, add only these servers 
+
+.$JBOSS_HOME/domain/configuration/host.xml
+
+==== 
+----
+
+<servers>
+    <server name="server-one" group="main-server-group">
+        <!-- server-one inherits the default socket-group declared in the server-group -->
+    </server>
+
+    <server name="server-two" group="main-server-group" auto-start="true">
+        <!-- server-two avoids port conflicts by incrementing the ports in
+             the default socket-group declared in the server-group -->
+        <socket-binding-group ref="standard-sockets" port-offset="100"/>
+    </server>
+
+    <server name="server-three" group="main-server-group" auto-start="true">
+        <!-- server-two avoids port conflicts by incrementing the ports in
+             the default socket-group declared in the server-group -->
+        <socket-binding-group ref="standard-sockets" port-offset="200"/>
+    </server>
+
+    <server name="server-four" group="main-server-group" auto-start="true">
+        <!-- server-two avoids port conflicts by incrementing the ports in
+             the default socket-group declared in the server-group -->
+        <socket-binding-group ref="standard-sockets" port-offset="300"/>
+    </server>
+
+    <server name="server-five" group="rest-server-group" auto-start="true">
+        <!-- server-two avoids port conflicts by incrementing the ports in
+             the default socket-group declared in the server-group -->
+        <socket-binding-group ref="standard-sockets" port-offset="1000"/>
+    </server>
+</servers>
+
+----
+
+==== 
+
+* Now, define the server groups. We'll also add server group for the REST interface which we'll see in a minute:
+
+.$JBOSS_HOME/domain/configuration/domain.xml
+
+==== 
+----
+
+<server-groups>
+    <server-group name="main-server-group" profile="default">
+        <jvm name="default">
+            <heap size="64m" max-size="512m"/>
+            <permgen size="128m"/>
+        </jvm>
+        <socket-binding-group ref="standard-sockets"/>
+    </server-group>
+    <server-group name="rest-server-group" profile="default">
+        <jvm name="default">
+            <heap size="64m" max-size="512m"/>
+            <permgen size="128m"/>
+        </jvm>
+        <socket-binding-group ref="standard-sockets"/>
+    </server-group>
+</server-groups>
+
+----
+
+==== 
+
+* Note that nodes don't get much memory by default, we need to increase it
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Showthecacherunningindistributedmode]]
+
+
+===== Show the cache running in distributed mode
+
+
+*  Start up 4 JBoss AS 7 nodes with domain.sh . Why? See the link:$$https://docs.jboss.org/author/display/AS7/Getting+Started+Guide#GettingStartedGuide-JBossApplicationServer7Configurations$$[JBoss 7 Getting Started guide] 
+
+
+*  Build latest using mvn package and in another terminal change into the project and bring up JBoss AS CLI $JBOSS_HOME/bin/jboss-admin.sh --connect 
+
+
+*  Deploy app from console using deploy target/lab1.war --server-groups=main-server-group 
+
+
+* App now deployed to each node
+
+
+* bring up all 4 nodes in a web browser (port offset 100)
+
+
+* show each node starting in the console log
+
+
+* the contents list now just shows whats locally in the cache
+
+
+* explain that as each node comes up, the entries are rehashed to distribute the contents, so we see entries disappear from a node
+
+
+* show that we can still find any entry, it's just not local any more
+
+
+* show that we can put an entry, and then find it in one of the caches in Infinispan (10 mins)
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-InterludeWhatmodescanInfinispanrunin%3FWhenwouldyouwanttousethem%3F]]
+
+
+===== Interlude - What modes can Infinispan run in? When would you want to use them?
+
+Topics discussed include:
+
+
+* What are the different modes?
+
+
+* When would you use the modes?
+
+
+* How does distribution work?
+
+
+* Explain CH, benefits and problems
+
+
+* Talk about vnodes to even distribution
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-L1cache]]
+
+
+==== L1 cache
+
+ _presented by Sanne_ _5 minutes_ 
+
+
+* Explain benefits (TODO)
+
+
+*  Start up 4 JBoss AS 7 nodes with $JBOSS_HOME/bin/domain.sh 
+
+
+*  Build latest using mvn package and in another terminal change into the project and bring up JBoss AS CLI jboss-admin.sh --connect 
+
+
+*  Deploy app from console using deploy target/lab1.war --server-groups=main-server-group 
+
+
+* App now deployed to each node
+
+
+* bring up all 4 nodes in a web browser (port offset 100)
+
+
+* Just like before, except that nodes 1 &amp; 2 are still showing all entries locally (they kept them in their cache)
+
+
+* Find a node that doesn't have all entries, and query for an entry that isn't on that node. Then hit refresh. Show that this time it's now local (L1 cache)
+
+
+* Show the same for putting a new entry - keep adding until you get one that isn't owned by the current node - show that it is in the local node still.
+
+ _Checkpoint 6_ 
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-ClientServerModes]]
+
+
+==== Client Server Modes
+
+ _presented by Mircea_ _10 minutes_ 
+
+
+* We have a server group set up in JBoss AS 7 that contains a single server. We'll use this for the rest server - no need to have one on each node!
+
+
+* Enter jboss admin console and connect to the local server: $JBOSS_HOME/bin/jboss-admin.sh. The type "connect".
+
+
+*  Deploy infinispan-server-rest.war from the lab to JBoss AS 7 using the JBoss AS 7 CLI deploy &lt;path/to/&gt;infinispan-server-rest.war --server-groups=rest-server-group 
+
+
+* REST server actually joins the Infinispan cluster as a node, and it needs to know which caches to use, so we added this to the war, and we also needed to add the domain class* * * Visit a couple of the UIs to seed data and start caches
+
+
+*  check that connection REST is correctly deployed: link:$$http://localhost:8080/infinispan-server-rest/$$[] 
+
+
+*  Use a rest client to GET link:$$http://localhost:9080/infinispan-server-rest/rest/ticketAllocationCache/manik-Best%20of%20Abba$$[] 
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-InterludewhatclientservermodesdoesInfinispanoffer%3F]]
+
+
+===== Interlude - what client-server modes does Infinispan offer?
+
+Topics discussed include:
+
+
+* various server endpoints
+
+
+* benefits of Hot Rod
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-CacheStores]]
+
+
+==== CacheStores
+
+ _presented by Mircea_ _10 minutes_ 
+
+ _Use case: Persist your data to disk in case of node restart_ 
+
+
+*  paste the JDBC cache config method from src/sample/java/jdbc.txt 
+
+
+* Walk through the JDBC cache store set up code
+
+
+* Add this to the configuration:
+
+
+----
+
+.loaders()
+   .shared(true)
+   .addCacheLoader()
+      .cacheLoader(new JdbcStringBasedCacheStore())
+      .addProperty("connectionFactoryClass", "org.infinispan.loaders.jdbc.connectionfactory.ManagedConnectionFactory")
+      .addProperty("datasourceJndiLocation", "java:jboss/datasources/ExampleDS")
+      .addProperty("idColumnType", "VARCHAR(255)")
+      .addProperty("idColumnName", "ID_COLUMN")
+      .addProperty("dataColumnType", "BINARY")
+      .addProperty("dataColumnName", "DATA_COLUMN")
+      .addProperty("timestampColumnName", "TIMESTAMP_COLUMN")
+      .addProperty("timestampColumnType", "BIGINT")
+      .addProperty("stringsTableNamePrefix", "persistentStore")
+      .addProperty("userName", "sa")
+      .addProperty("password", "sa")
+      .async().threadPoolSize(10)
+
+----
+
+
+*  Run mvn clean package 
+
+
+*  Deploy the app using deploy lab1/target/lab1.war --server-groups=main-server-group 
+
+
+*  Explain we are using the JBoss AS 7 built in example data source for H2 - configuration found in domain.xml . 
+
+
+* Vist a node or two to setup some caches and data
+
+
+*  Explain we are using the h2console.war. Needed a couple of changes to make it run, documentation coming soon 
+.TODO Gliffy image title empty
+image::[]
+
+ 
+
+
+*  Deploy it using deploy h2console.war --server-groups=main-server-group - each node in the cluster owns some data, each h2 database will back that up 
+
+
+*  Visit link:$$http://localhost:9080/h2console/$$[] 
+
+
+*  Log in sa with password sa 
+
+
+*  execute select * from persistentstore_ticketallocationcache 
+
+ _Checkpoint 7_ 
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-InterludeWhatCacheStoresareavailable%3FInwhatscenarioscantheybeused%3F]]
+
+
+===== Interlude - What Cache Stores are available? In what scenarios can they be used?
+
+Topics discussed include:
+
+
+* Modes of cache store usage
+
+
+* CacheStores available as built in
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Bonustopics]]
+
+
+==== Bonus topics
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-QueryingInfinispan]]
+
+
+===== Querying Infinispan
+
+ _presented by Sanne_ _8 minutes_ 
+
+Topics discussed include:
+
+
+* TODO
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-HibernateOGM]]
+
+
+===== Hibernate OGM
+
+ _presented by Sanne_ _2 minutes_ 
+
+Topics discussed include:
+
+
+* TODO
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-MapReduce]]
+
+
+===== Reduce
+
+ _presented by Pete_ _5 minutes_ 
+
+Topics discussed include:
+
+
+* TODO
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Benchmarkingdatagirds%5CRadargun]]
+
+
+===== Benchmarking data girds - Radargun
+
+Introducing project Radargun
+
+ _presented by Mircea_ _5 minutes_ 
+
+[[sid-68355155_Lab-GettingStartedwithInfinispan-Conclusion]]
+
+
+==== Conclusion
+
+ _presented by Pete_ _10 minutes_ 
+
diff --git a/documentation/src/main/asciidoc/getting_started/chapter-2-Downloading_and_installing_Infinispan.adoc b/documentation/src/main/asciidoc/getting_started/chapter-2-Downloading_and_installing_Infinispan.adoc
index 368f8f3..0d7c912 100644
--- a/documentation/src/main/asciidoc/getting_started/chapter-2-Downloading_and_installing_Infinispan.adoc
+++ b/documentation/src/main/asciidoc/getting_started/chapter-2-Downloading_and_installing_Infinispan.adoc
@@ -1,4 +1,4 @@
-[[sid-8093985_GettingStartedGuide-DownloadingandinstallingInfinispan]]
+[[sid-68355130_GettingStartedGuide-DownloadingandinstallingInfinispan]]
 
 ==  Downloading and installing Infinispan
 
diff --git a/documentation/src/main/asciidoc/getting_started/chapter-3-Infinispan_in_action_GUIDemo.adoc b/documentation/src/main/asciidoc/getting_started/chapter-3-Infinispan_in_action_GUIDemo.adoc
index 6c76132..2901a17 100644
--- a/documentation/src/main/asciidoc/getting_started/chapter-3-Infinispan_in_action_GUIDemo.adoc
+++ b/documentation/src/main/asciidoc/getting_started/chapter-3-Infinispan_in_action_GUIDemo.adoc
@@ -1,4 +1,4 @@
-[[sid-8093985_GettingStartedGuide-InfinispaninactionGUIDemo]]
+[[sid-68355130_GettingStartedGuide-InfinispaninactionGUIDemo]]
 
 ==  Infinispan in action - GUIDemo
 
diff --git a/documentation/src/main/asciidoc/getting_started/chapter-4-Using_Infinispan_as_an_embedded_cache_in_Java_SE.adoc b/documentation/src/main/asciidoc/getting_started/chapter-4-Using_Infinispan_as_an_embedded_cache_in_Java_SE.adoc
index 6e1138c..64ad464 100644
--- a/documentation/src/main/asciidoc/getting_started/chapter-4-Using_Infinispan_as_an_embedded_cache_in_Java_SE.adoc
+++ b/documentation/src/main/asciidoc/getting_started/chapter-4-Using_Infinispan_as_an_embedded_cache_in_Java_SE.adoc
@@ -1,4 +1,4 @@
-[[sid-8093985_GettingStartedGuide-UsingInfinispanasanembeddedcacheinJavaSE]]
+[[sid-68355130_GettingStartedGuide-UsingInfinispanasanembeddedcacheinJavaSE]]
 
 ==  Using Infinispan as an embedded cache in Java SE
 
@@ -8,13 +8,13 @@ Running Infinispan in embedded mode is very easy. First, we'll set up a project,
 [TIP]
 .embedded-cache quickstart
 ==== 
-All the code discussed in this tutorial is available in the embedded-cache quickstart.
+ All the code discussed in this tutorial is available in the link:$$https://github.com/infinispan/infinispan-quickstart/tree/master/embedded-cache$$[embedded-cache quickstart] . 
 
 
 ==== 
 
 
-[[sid-8093985_GettingStartedGuide-CreatinganewInfinispanproject]]
+[[sid-68355130_GettingStartedGuide-CreatinganewInfinispanproject]]
 
 
 === Creating a new Infinispan project
@@ -26,11 +26,11 @@ The only thing you need to set up Infinispan is add it's dependencies to your pr
 ==== 
 ----
 
-013.   ~ This software is distributed in the hope that it will be useful,
-014.   ~ but WITHOUT ANY WARRANTY; without even the implied warranty of
-015.   ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-016.   ~ Lesser General Public License for more details.
-017.   ~
+053.       <dependency>
+054.          <groupId>org.infinispan</groupId>
+055.          <artifactId>infinispan-core</artifactId>
+056.          <version>${infinispan.version}</version>
+057.       </dependency>
 
 ----
 
@@ -54,45 +54,45 @@ You'll also need to enable the JBoss Maven repository. We recommend adding a pro
 ==== 
 ----
 
-022.   -->
-023. <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-024.    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-025.    <modelVersion>4.0.0</modelVersion>
-026.    <groupId>org.infinispan.quickstart</groupId>
-027.    <artifactId>embedded-cache-quickstart</artifactId>
-028.    <version>1.0.0-SNAPSHOT</version>
-029. 
-030.    <name>Infinispan Embedded Cache Quickstart</name>
-031.    <description>This quickstart demonstrates embedded cache running on a single node in Java SE.</description>
-032. 
-033.    <url>http://jboss.org/infinispan</url>
-034.    <licenses>
-035.       <license>
-036.          <name>GNU Lesser General Public License</name>
-037.          <url>http://www.gnu.org/copyleft/lesser.html</url>
-038.          <distribution>repo</distribution>
-039.       </license>
-040.    </licenses>
-041. 
-042.    <properties>
-043.       <!-- Explicitly declaring the source encoding eliminates the following 
-044.          message: -->
-045.       <!-- [WARNING] Using platform encoding (UTF-8 actually) to copy filtered 
-046.          resources, i.e. build is platform dependent! -->
-047.       <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-048. 
-049.       <infinispan.version>5.1.0.CR2</infinispan.version>
-050.    </properties>
-051. 
-052.    <dependencies>
-053.       <dependency>
-054.          <groupId>org.infinispan</groupId>
-055.          <artifactId>infinispan-core</artifactId>
-056.          <version>${infinispan.version}</version>
-057.       </dependency>
-058.    </dependencies>
-059. 
-060.    <build>
+076.       <profile>
+077.          <id>jboss-public-repository</id>
+078.          <activation>
+079.             <property>
+080.                <name>jboss-public-repository</name>
+081.                <value>!false</value>
+082.             </property>
+083.          </activation>
+084.          <repositories>
+085.             <repository>
+086.                <id>jboss-public-repository-group</id>
+087.                <name>JBoss Public Maven Repository Group</name>
+088.                <url>http://repository.jboss.org/nexus/content/groups/public</url>
+089.                <releases>
+090.                   <enabled>true</enabled>
+091.                   <updatePolicy>never</updatePolicy>
+092.                </releases>
+093.                <snapshots>
+094.                   <enabled>true</enabled>
+095.                   <updatePolicy>never</updatePolicy>
+096.                </snapshots>
+097.             </repository>
+098.          </repositories>
+099.          <pluginRepositories>
+100.             <pluginRepository>
+101.                <id>jboss-public-repository-group</id>
+102.                <name>JBoss Public Maven Repository Group</name>
+103.                <url>http://repository.jboss.org/nexus/content/groups/public</url>
+104.                <releases>
+105.                   <enabled>true</enabled>
+106.                   <updatePolicy>never</updatePolicy>
+107.                </releases>
+108.                <snapshots>
+109.                   <enabled>false</enabled>
+110.                   <updatePolicy>never</updatePolicy>
+111.                </snapshots>
+112.             </pluginRepository>
+113.          </pluginRepositories>
+114.       </profile>
 
 ----
 
@@ -101,15 +101,27 @@ You'll also need to enable the JBoss Maven repository. We recommend adding a pro
 
  If you are using Ant, or another build system which doesn't provide declarative dependency management, then the Infinispan distribution zip contains a lib/ directory. Add the contents of this to the build classpath. 
 
-[[sid-8093985_GettingStartedGuide-RunningInfinispanonasinglenode]]
+[[sid-68355130_GettingStartedGuide-RunningInfinispanonasinglenode]]
 
 
 === Running Infinispan on a single node
 
  In order to run Infinispan, we're going to create a main method in the Quickstart class. Infinispan comes configured to run out of the box; once you have set up your dependencies, all you need to do to start using Infinispan is to create a new cache manager and get a handle on the default cache. 
 
-Code Snippet error: Unable to retrieve the URL: https://github.com/infinispan/infinispan-quickstart/raw/master/embedded-cache/src/main/java/Quickstart.java status code: 404.
+.Quickstart.java
+
+==== 
+----
+
+28. public class Quickstart {
+29. 
+30.    public static void main(String args[]) throws Exception {
+31.       Cache<Object, Object> c = new DefaultCacheManager().getCache();
+32.    }
+
+----
 
+==== 
 We now need a way to run the main method! If you are using Maven, the best approach is to copy all the project dependencies to a directory, and at the same time compile the java classes from our project:
 
 
@@ -132,32 +144,88 @@ You should see Infinispan start up, and the version in use logged to the console
 
 Congratulations, you now have Infinispan running as a local cache!
 
-[[sid-8093985_GettingStartedGuide-Usethedefaultcache]]
+[[sid-68355130_GettingStartedGuide-Usethedefaultcache]]
 
 
 === Use the default cache
 
 Infinispan exposes a Map-like, JSR-107-esque interface for accessing and mutating the data stored in the cache. For example:
 
-Code Snippet error: Unable to retrieve the URL: https://github.com/infinispan/infinispan-quickstart/raw/master/embedded-cache/src/main/java/DefaultCacheQuickstart.java status code: 404.
+.DefaultCacheQuickstart.java
+
+==== 
+----
 
+37.       
+38.       // Add a entry
+39.       cache.put("key", "value");
+40.       // Validate the entry is now in the cache
+41.       assertEqual(1, cache.size());
+42.       assertTrue(cache.containsKey("key"));
+43.       // Remove the entry from the cache
+44.       Object v = cache.remove("key");
+45.       // Validate the entry is no longer in the cache
+46.       assertEqual("value", v);
+
+----
+
+==== 
 Infinispan offers a thread-safe data-structure:
 
-Code Snippet error: Unable to retrieve the URL: https://github.com/infinispan/infinispan-quickstart/raw/master/embedded-cache/src/main/java/DefaultCacheQuickstart.java status code: 404.
+.DefaultCacheQuickstart.java
+
+==== 
+----
+
+48. 
+49.       // Add an entry with the key "key"
+50.       cache.put("key", "value");
+51.       // And replace it if missing
+52.       cache.putIfAbsent("key", "newValue");
+53.       // Validate that the new value was not added
+
+----
 
+==== 
 By default entries are immortal but you can override this on a per-key basis and provide lifespans.
 
-Code Snippet error: Unable to retrieve the URL: https://github.com/infinispan/infinispan-quickstart/raw/master/embedded-cache/src/main/java/DefaultCacheQuickstart.java status code: 404.
+.DefaultCacheQuickstart.java
 
-[[sid-8093985_GettingStartedGuide-Useacustomcache]]
+==== 
+----
+
+58. 
+59.       //By default entries are immortal but we can override this on a per-key basis and provide lifespans.
+60.       cache.put("key", "value", 5, SECONDS);
+61.       assertTrue(cache.containsKey("key"));
+62.       Thread.sleep(10000);
+
+----
+
+==== 
+[[sid-68355130_GettingStartedGuide-Useacustomcache]]
 
 
 === Use a custom cache
 
 Each cache in Infinispan can offer a different set of features (for example transaction support, different replication modes or support for eviction), and you may want to use different caches for different classes of data in your application. To get a custom cache, you need to register it with the manager first:
 
-Code Snippet error: Unable to retrieve the URL: https://github.com/infinispan/infinispan-quickstart/raw/master/embedded-cache/src/main/java/CustomCacheQuickstart.java status code: 404.
+.CustomCacheQuickstart.java
+
+==== 
+----
 
+33. 
+34.    public static void main(String args[]) throws Exception {
+35.       EmbeddedCacheManager manager = new DefaultCacheManager();
+36.       manager.defineConfiguration("custom-cache", new ConfigurationBuilder()
+37.             .eviction().strategy(LIRS).maxEntries(10)
+38.             .build());
+39.       Cache<Object, Object> c = manager.getCache("custom-cache");
+
+----
+
+==== 
 The example above uses Infinispan's fluent configuration, which offers the ability to configure your cache programmatically. However, should you prefer to use XML, then you may. We can create an identical cache to the one created with a programmatic configuration:
 
 .infinispan.xml
@@ -181,5 +249,15 @@ The example above uses Infinispan's fluent configuration, which offers the abili
 ==== 
 We then need to load the configuration file, and use the programmatically defined cache:
 
-Code Snippet error: Unable to retrieve the URL: https://github.com/infinispan/infinispan-quickstart/raw/master/embedded-cache/src/main/java/XmlConfiguredCacheQuickstart.java status code: 404.
+.XmlConfiguredCacheQuickstart.java
 
+==== 
+----
+
+29. 
+30.    public static void main(String args[]) throws Exception {
+31. 	   Cache<Object, Object> c = new DefaultCacheManager("infinispan.xml").getCache("xml-configured-cache");
+
+----
+
+==== 
diff --git a/documentation/src/main/asciidoc/getting_started/chapter-5-Using_Infinispan_as_an_embedded_data_grid_in_Java_SE.adoc b/documentation/src/main/asciidoc/getting_started/chapter-5-Using_Infinispan_as_an_embedded_data_grid_in_Java_SE.adoc
index 9db6d52..9479ed2 100644
--- a/documentation/src/main/asciidoc/getting_started/chapter-5-Using_Infinispan_as_an_embedded_data_grid_in_Java_SE.adoc
+++ b/documentation/src/main/asciidoc/getting_started/chapter-5-Using_Infinispan_as_an_embedded_data_grid_in_Java_SE.adoc
@@ -1,4 +1,4 @@
-[[sid-8093985_GettingStartedGuide-UsingInfinispanasanembeddeddatagridinJavaSE]]
+[[sid-68355130_GettingStartedGuide-UsingInfinispanasanembeddeddatagridinJavaSE]]
 
 ==  Using Infinispan as an embedded data grid in Java SE
 
@@ -34,7 +34,7 @@ Cache<Object, Object> cache3 = cm.getCache("invalidationSyncCache");
 ==== 
 
 
-[[sid-8093985_GettingStartedGuide-RunningInfinispaninacluster]]
+[[sid-68355130_GettingStartedGuide-RunningInfinispaninacluster]]
 
 
 === Running Infinispan in a cluster
@@ -99,7 +99,7 @@ $> java -cp target/classes/:target/dependency/* org.infinispan.quickstart.cluste
 
 You should see JGroups and Infinispan start up on both consoles, and after about 15s see the 10 entries added by third node distributed to the first and second nodes.
 
-[[sid-8093985_GettingStartedGuide-clusteredcachequickstartarchitecture]]
+[[sid-68355130_GettingStartedGuide-clusteredcachequickstartarchitecture]]
 
 
 ==== clustered-cache quickstart architecture
@@ -110,38 +110,50 @@ You should see JGroups and Infinispan start up on both consoles, and after about
 ==== 
 An easy way to see what is going on with your cache is to log mutated entries. An Infinispan listener is notified of any mutations:
 
-.LoggingListener.java
 
-==== 
 ----
 
-18.  * You should have received a copy of the GNU Lesser General Public
-19.  * License along with this software; if not, write to the Free
-20.  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-21.  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-22.  */
-23. package org.infinispan.quickstart.clusteredcache.util;
-24. 
-25. import org.infinispan.notifications.Listener;
-26. import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;
-27. import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;
-28. import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;
-29. import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;
-30. import org.infinispan.util.logging.Log;
-31. import org.infinispan.util.logging.LogFactory;
-32. 
-33. /**
+import org.infinispan.notifications.Listener;
+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;
+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;
+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;
+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;
+import org.infinispan.util.logging.Log;
+import org.infinispan.util.logging.LogFactory;
+
+/**
+ * An Infinispan listener that simply logs cache entries being created and
+ * removed
+ * 
+ * @author Pete Muir
+ */
+@Listener
+public class LoggingListener {
+
+   private Log log = LogFactory.getLog(LoggingListener.class);
+
+   @CacheEntryCreated
+   public void observeAdd(CacheEntryCreatedEvent<?, ?> event) {
+      if (!event.isPre()) // So that message is only logged after operation succeeded
+         log.infof("Cache entry with key %s added in cache %s", event.getKey(), event.getCache());
+   }
+
+   @CacheEntryRemoved
+   public void observeRemove(CacheEntryRemovedEvent<?, ?> event) {
+      log.infof("Cache entry with key %s removed in cache %s", event.getKey(), event.getCache());
+   }
+
+}
 
 ----
 
-==== 
 Listeners methods are declared using annotations, and receive a payload which contains metadata about the notification. Listeners are notified of any changes. Here, the listeners simply log any entries added or removed.
 
 
 ==== 
 
 
- The replication mode example contains two nodes, each of which are started in a separate process. The nodes are very simple, Node0 starts up, registers a listener that logs any changes, and waits for the cluster to form. Node1 starts up, waits for the cluster to form, and then adds an entry. The interesting work happens in the common super class, examined in <<sid-8093985_GettingStartedGuide-Configuringareplicateddatagrid,Configuring a replicated data-grid>> . 
+ The replication mode example contains two nodes, each of which are started in a separate process. The nodes are very simple, Node0 starts up, registers a listener that logs any changes, and waits for the cluster to form. Node1 starts up, waits for the cluster to form, and then adds an entry. The interesting work happens in the common super class, examined in <<sid-68355130_GettingStartedGuide-Configuringareplicateddatagrid,Configuring a replicated data-grid>> . 
 
 
 [IMPORTANT]
@@ -153,25 +165,24 @@ Listeners methods are declared using annotations, and receive a payload which co
 ==== 
 
 
- The distribution mode example contains three nodes, each of which are started in a separate process. The nodes are very simple, Node0 and Node1 start up, register listeners that logs any changes, and wait for the cluster to form. Node2 starts up, waits for the cluster to form, and then adds 20 entries. Each entry get's distributed to it's owners, and you will see some entries add on Node0 and some on Node1 .  You'll notice that Node2 gets _notified_ of all adds - this is just because it is the node which adds the entry, it doesn't reflect that the fact that all these entries are stored there! The interesting work happens in the common super class, examined in <<sid-8093985_GettingStartedGuide-Configuringadistributeddatagrid,Configuring a distributed data-grid>> . 
+ The distribution mode example contains three nodes, each of which are started in a separate process. The nodes are very simple, Node0 and Node1 start up, register listeners that logs any changes, and wait for the cluster to form. Node2 starts up, waits for the cluster to form, and then adds 20 entries. Each entry get's distributed to it's owners, and you will see some entries add on Node0 and some on Node1 .  You'll notice that Node2 gets _notified_ of all adds - this is just because it is the node which adds the entry, it doesn't reflect that the fact that all these entries are stored there! The interesting work happens in the common super class, examined in <<sid-68355130_GettingStartedGuide-Configuringadistributeddatagrid,Configuring a distributed data-grid>> . 
 
-[[sid-8093985_GettingStartedGuide-Configuringthecluster]]
+[[sid-68355130_GettingStartedGuide-Configuringthecluster]]
 
 
 === Configuring the cluster
 
 First, we need to ensure that Infinispan is cluster aware. Infinispan provides a default configuration for a clustered cache:
 
-.AbstractNode.java snippet
 
-==== 
 ----
 
-16.  * Lesser General Public License for more details.
+new ConfigurationBuilder()
+   .clustering().cacheMode(CacheMode.REPL_SYNC)
+   .build()
 
 ----
 
-==== 
 
 [TIP]
 ==== 
@@ -181,26 +192,22 @@ First, we need to ensure that Infinispan is cluster aware. Infinispan provides a
 ==== 
 
 
-[[sid-8093985_GettingStartedGuide-Tweakingtheclusterconfigurationforyournetwork]]
+[[sid-68355130_GettingStartedGuide-Tweakingtheclusterconfigurationforyournetwork]]
 
 
 ==== Tweaking the cluster configuration for your network
 
  Depending on your network setup, you may need to tweak your JGroups set up. JGroups is configured via an XML file; the file to use can be specified via the GlobalConfiguration : 
 
-.AbstractNode.java snippet
 
-==== 
 ----
 
-17.  *
-18.  * You should have received a copy of the GNU Lesser General Public
-19.  * License along with this software; if not, write to the Free
-20.  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+GlobalConfigurationBuilder.defaultClusteredBuilder()
+   .transport().addProperty("configurationFile", "jgroups.xml")
+   .build()
 
 ----
 
-==== 
 
 [TIP]
 ==== 
@@ -217,23 +224,20 @@ TODO - add more tips!
 
 You can also configure the JGroups properties to use in Infinispan's XML configuration:
 
-.infinispan.xml
 
-==== 
 ----
 
-20.   ~ License along with this software; if not, write to the Free
-21.   ~ Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-22.   ~ 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-23.   -->
-24. <infinispan xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-25.    xsi:schemaLocation="urn:infinispan:config:5.1 http://www.infinispan.org/schemas/infinispan-config-5.1.xsd"
-26.    xmlns="urn:infinispan:config:5.1">
+<global>
+   <transport>
+      <properties>
+         <property name="configurationFile" value="jgroups.xml"/>
+      </properties>
+   </transport>
+</global>
 
 ----
 
-==== 
-[[sid-8093985_GettingStartedGuide-Configuringareplicateddatagrid]]
+[[sid-68355130_GettingStartedGuide-Configuringareplicateddatagrid]]
 
 
 === Configuring a replicated data-grid
@@ -242,73 +246,54 @@ In replicated mode, Infinispan will store every entry on every node in the grid.
 
 The cache should be configured to work in replication mode (either synchronous or asynchronous), and can otherwise be configured as normal. For example, if you want to configure the cache programatically:
 
-.AbstractNode.java snippet
 
-==== 
 ----
 
-15.  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-16.  * Lesser General Public License for more details.
-17.  *
-18.  * You should have received a copy of the GNU Lesser General Public
-19.  * License along with this software; if not, write to the Free
-20.  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-21.  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-22.  */
-23. package org.infinispan.quickstart.clusteredcache.replication;
-24. 
-25. import org.infinispan.configuration.cache.CacheMode;
-26. import org.infinispan.configuration.cache.ConfigurationBuilder;
-
+private static EmbeddedCacheManager createCacheManagerProgramatically() {
+   return new DefaultCacheManager(
+      GlobalConfigurationBuilder.defaultClusteredBuilder()
+         .transport().addProperty("configurationFile", "jgroups.xml")
+         .build(),
+      new ConfigurationBuilder()
+         .clustering().cacheMode(CacheMode.REPL_SYNC)
+         .build()
+   );
+}
 ----
 
-==== 
 You can configure an identical cache using XML:
 
 cfg.xml:
 
-.infinispan.xml
 
-==== 
 ----
 
-16.   ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-17.   ~ Lesser General Public License for more details.
-18.   ~
-19.   ~ You should have received a copy of the GNU Lesser General Public
-20.   ~ License along with this software; if not, write to the Free
-21.   ~ Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-22.   ~ 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-23.   -->
-24. <infinispan xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-25.    xsi:schemaLocation="urn:infinispan:config:5.1 http://www.infinispan.org/schemas/infinispan-config-5.1.xsd"
-26.    xmlns="urn:infinispan:config:5.1">
-27.     
-28.    <global>
-29.       <transport>
-30.          <properties>
-31.             <property name="configurationFile" value="jgroups.xml"/>
-32.          </properties>
-33.       </transport>
-34.    </global>
-35.     
-36.    <default>
-
+<infinispan xsi:schemaLocation="urn:infinispan:config:5.1 http://www.infinispan.org/schemas/infinispan-config-5.1.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:infinispan:config:5.1">
+   <global>
+      <transport>
+         <properties>
+            <property name="configurationFile" value="jgroups.xml"/>
+         </properties>
+      </transport>
+   </global>
+   <default>
+      <!-- Configure a synchronous replication cache -->
+      <clustering mode="replication">
+         <sync/>
+      </clustering>
+   </default>
+</infinispan>
 ----
 
-==== 
-.AbstractNode.java snippet
 
-==== 
 ----
 
-30. import org.infinispan.quickstart.clusteredcache.util.ClusterValidation;
-31. 
-32. import java.io.IOException;
+private static EmbeddedCacheManager createCacheManagerFromXml() throws IOException {
+   return new DefaultCacheManager("infinispan-replication.xml");
+}
 
 ----
 
-==== 
 
 [TIP]
 ==== 
@@ -318,7 +303,7 @@ cfg.xml:
 ==== 
 
 
-[[sid-8093985_GettingStartedGuide-Configuringadistributeddatagrid]]
+[[sid-68355130_GettingStartedGuide-Configuringadistributeddatagrid]]
 
 
 === Configuring a distributed data-grid
@@ -329,70 +314,31 @@ cfg.xml:
 
 The cache should be configured to work in distibuted mode (either synchronous or asynchronous), and can otherwise be configured as normal. For example, if you want to configure the cache programatically:
 
-.AbstractNode.java snippet
 
-==== 
 ----
 
-15.  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-16.  * Lesser General Public License for more details.
-17.  *
-18.  * You should have received a copy of the GNU Lesser General Public
-19.  * License along with this software; if not, write to the Free
-20.  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-21.  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-22.  */
-23. package org.infinispan.quickstart.clusteredcache.distribution;
-24. 
-25. import org.infinispan.configuration.cache.CacheMode;
-26. import org.infinispan.configuration.cache.ConfigurationBuilder;
+new ConfigurationBuilder()
+   .clustering()
+      .cacheMode(CacheMode.DIST_SYNC)
+      .hash().numOwners(2)
+   .build()
 
 ----
 
-==== 
 You can configure an identical cache using XML:
 
 cfg.xml:
 
-.infinispan.xml
-
-==== 
-----
-
-16.   ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-17.   ~ Lesser General Public License for more details.
-18.   ~
-19.   ~ You should have received a copy of the GNU Lesser General Public
-20.   ~ License along with this software; if not, write to the Free
-21.   ~ Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-22.   ~ 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-23.   -->
-24. <infinispan xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-25.    xsi:schemaLocation="urn:infinispan:config:5.1 http://www.infinispan.org/schemas/infinispan-config-5.1.xsd"
-26.    xmlns="urn:infinispan:config:5.1">
-27.     
-28.    <global>
-29.       <transport transportClass="org.infinispan.remoting.transport.jgroups.JGroupsTransport">
-30.          <properties>
-31.             <property name="configurationFile" value="jgroups.xml"/>
-32.          </properties>
-33.       </transport>
-34.    </global>
-35.    
-36.    <default>
-
-----
-
-==== 
-.AbstractNode.java snippet
 
-==== 
 ----
 
-29. import org.infinispan.manager.EmbeddedCacheManager;
-30. import org.infinispan.quickstart.clusteredcache.util.ClusterValidation;
-31. 
+<default>
+   <!-- Configure a synchronous replication cache -->
+   <clustering mode="distribution">
+      <sync/>
+      <hash numOwners="2"/>
+   </clustering>
+</default>
 
 ----
 
-==== 
diff --git a/documentation/src/main/asciidoc/getting_started/chapter-6-Creating_your_own_Infinispan_project.adoc b/documentation/src/main/asciidoc/getting_started/chapter-6-Creating_your_own_Infinispan_project.adoc
index 64ec2f1..cb74582 100644
--- a/documentation/src/main/asciidoc/getting_started/chapter-6-Creating_your_own_Infinispan_project.adoc
+++ b/documentation/src/main/asciidoc/getting_started/chapter-6-Creating_your_own_Infinispan_project.adoc
@@ -1,4 +1,4 @@
-[[sid-8093985_GettingStartedGuide-CreatingyourownInfinispanproject]]
+[[sid-68355130_GettingStartedGuide-CreatingyourownInfinispanproject]]
 
 ==  Creating your own Infinispan project
 
diff --git a/documentation/src/main/asciidoc/getting_started/chapter-7-Using_Infinispan_as_a_second_level_cache_for_Hibernate.adoc b/documentation/src/main/asciidoc/getting_started/chapter-7-Using_Infinispan_as_a_second_level_cache_for_Hibernate.adoc
index 3669822..06c35cc 100644
--- a/documentation/src/main/asciidoc/getting_started/chapter-7-Using_Infinispan_as_a_second_level_cache_for_Hibernate.adoc
+++ b/documentation/src/main/asciidoc/getting_started/chapter-7-Using_Infinispan_as_a_second_level_cache_for_Hibernate.adoc
@@ -1,4 +1,4 @@
-[[sid-8093985_GettingStartedGuide-UsingInfinispanasasecondlevelcacheforHibernate]]
+[[sid-68355130_GettingStartedGuide-UsingInfinispanasasecondlevelcacheforHibernate]]
 
 ==  Using Infinispan as a second level cache for Hibernate
 
diff --git a/documentation/src/main/asciidoc/getting_started/chapter-8-Accessing_an_Infinispan_data_grid_remotely.adoc b/documentation/src/main/asciidoc/getting_started/chapter-8-Accessing_an_Infinispan_data_grid_remotely.adoc
index f6a8976..7d929f2 100644
--- a/documentation/src/main/asciidoc/getting_started/chapter-8-Accessing_an_Infinispan_data_grid_remotely.adoc
+++ b/documentation/src/main/asciidoc/getting_started/chapter-8-Accessing_an_Infinispan_data_grid_remotely.adoc
@@ -1,22 +1,22 @@
-[[sid-8093985_GettingStartedGuide-AccessinganInfinispandatagridremotely]]
+[[sid-68355130_GettingStartedGuide-AccessinganInfinispandatagridremotely]]
 
 ==  Accessing an Infinispan data grid remotely
 
-[[sid-8093985_GettingStartedGuide-UsingHotRodtoaccessanInfinispandatagrid]]
+[[sid-68355130_GettingStartedGuide-UsingHotRodtoaccessanInfinispandatagrid]]
 
 
 === Using Hot Rod to access an Infinispan data-grid
 
 TODO
 
-[[sid-8093985_GettingStartedGuide-UsingRESTtoaccessanInfinipsandatagrid]]
+[[sid-68355130_GettingStartedGuide-UsingRESTtoaccessanInfinipsandatagrid]]
 
 
 === Using REST to access an Infinipsan data-grid
 
 TODO
 
-[[sid-8093985_GettingStartedGuide-UsingmemcachedtoaccessanInfinispandatagrid]]
+[[sid-68355130_GettingStartedGuide-UsingmemcachedtoaccessanInfinispandatagrid]]
 
 
 === Using memcached to access an Infinispan data-grid
diff --git a/documentation/src/main/asciidoc/getting_started/chapter-9-Using_Infinispan_in_JBoss_AS_7.adoc b/documentation/src/main/asciidoc/getting_started/chapter-9-Using_Infinispan_in_JBoss_AS_7.adoc
index fe8e74a..8741e83 100644
--- a/documentation/src/main/asciidoc/getting_started/chapter-9-Using_Infinispan_in_JBoss_AS_7.adoc
+++ b/documentation/src/main/asciidoc/getting_started/chapter-9-Using_Infinispan_in_JBoss_AS_7.adoc
@@ -1,4 +1,4 @@
-[[sid-8093985_GettingStartedGuide-UsingInfinispaninJBossAS7]]
+[[sid-68355130_GettingStartedGuide-UsingInfinispaninJBossAS7]]
 
 ==  Using Infinispan in JBoss AS 7
 
diff --git a/documentation/src/main/asciidoc/upgrading/chapter-1-Upgrading_from_5_0_to_5_1.adoc b/documentation/src/main/asciidoc/upgrading/chapter-1-Upgrading_from_5_0_to_5_1.adoc
new file mode 100644
index 0000000..525cb6a
--- /dev/null
+++ b/documentation/src/main/asciidoc/upgrading/chapter-1-Upgrading_from_5_0_to_5_1.adoc
@@ -0,0 +1,274 @@
+[[sid-68355206]]
+
+==  Upgrading from 5.0 to 5.1
+
+Please find below tips and recommendations when upgrading from Infinispan 5.0 to 5.1:
+
+[[sid-68355206_Upgradingfrom5.0to5.1-API]]
+
+
+=== API
+
+
+.  The cache and cache manager hierarchies have changed slightly in 5.1 with the introduction of 
+                link:$$https://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/api/BasicCache.html$$[BasicCache]
+               and 
+                link:$$https://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/api/BasicCacheContainer.html$$[BasicCacheContainer]
+               , which are parent classes of existing 
+                link:$$https://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/Cache.html$$[Cache]
+               and 
+                link:$$https://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/CacheContainer.html$$[CacheContainer]
+               classes respectively. What's important is that Hot Rod clients must now code against 
+                link:$$https://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/api/BasicCache.html$$[BasicCache]
+               and 
+                link:$$https://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/api/BasicCacheContainer.html$$[BasicCacheContainer]
+               rather than 
+                link:$$https://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/Cache.html$$[Cache]
+               and 
+                link:$$https://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/CacheContainer.html$$[CacheContainer]
+               . So previous code that was written like this will no longer compile. 
+
+
+----
+import org.infinispan.Cache;
+import org.infinispan.manager.CacheContainer;
+import org.infinispan.client.hotrod.RemoteCacheManager;
+...
+CacheContainer cacheContainer = new RemoteCacheManager();
+Cache cache = cacheContainer.getCache();
+----
+
+Instead, if Hot Rod clients want to continue using interfaces higher up the hierarchy from the remote cache/container classes, they'll have to write:
+
+
+----
+import org.infinispan.BasicCache;
+import org.infinispan.manager.BasicCacheContainer;
+import org.infinispan.client.hotrod.RemoteCacheManager;
+...
+BasicCacheContainer cacheContainer = new RemoteCacheManager();
+BasicCache cache = cacheContainer.getCache();
+----
+
+Previous code that interacted against the RemoteCache and RemoteCacheManager should work as it used to:
+
+
+----
+import org.infinispan.client.hotrod.RemoteCache;
+import org.infinispan.client.hotrod.RemoteCacheManager;
+...
+RemoteCacheManager cacheContainer = new RemoteCacheManager();
+RemoteCache cache = cacheContainer.getCache();
+----
+
+[[sid-68355206_Upgradingfrom5.0to5.1-EvictionandExpiration]]
+
+
+=== Eviction and Expiration
+
+
+.  The eviction XML element no longer defines the wakeUpInterval attribute. This is now configured via the expiration element: 
+
+
+----
+<expiration wakeUpInterval="60000"... />
+----
+
+
+.  Eviction's maxEntries is used as guide for the entire cache, but eviction happens on a per cache segment, so when the segment is full, the segment is evicted. That's why maxEntries is a theoretical limit but in practical terms, it'll be a bit less than that. This is done for performance reasons. 
+
+[[sid-68355206_Upgradingfrom5.0to5.1-Transactions]]
+
+
+=== Transactions
+
+
+.  A cache marked as TRANSACTIONAL cannot be accessed outside of a transaction, and a NON_TRANSACTIONAL cache cannot be accessed within a transaction. In 5.0, a transactional cache would support non-transactional calls as well.  This change was done to be in-line with expectations set out in link:$$https://github.com/jsr107$$[JSR-107] as well as to provide more consistent behavior. 
+
+
+. In 5.0, commit and rollback phases were asynchronous by default. Starting with 5.1, these are now synchronous by default, to provide the guarantees required by a single lock-owner model.
+
+[[sid-68355206_Upgradingfrom5.0to5.1-Statetransfer]]
+
+
+=== State transfer
+
+One of the big changes we made in 5.1 was to use the same push-based state transfer we introduced in 5.0 both for rehashing in distributed mode and for state retrieval in replicated mode. We even borrow the consistent hash concept in replicated mode to transfer state from all previous cache members at once in order to speed up transfer.
+
+ As a consequence we've unified the state transfer configuration as well, there is now a stateTransfer element holding a simplified state transfer configuration. The corresponding attributes in the stateRetrieval and hash elements have been deprecated, as have been some attributes that are no longer used. 
+
+[[sid-68355206_Upgradingfrom5.0to5.1-Configuration]]
+
+
+=== Configuration
+
+If you use XML to configure Infinispan, you shouldn't notice any change, except a much faster startup, courtesy of the Stax based parser. However, if you use programmatic configuration, read on for the important differences.
+
+Configuration is now packaged in org.infinispan.configuration, and you must use a builder style:
+
+
+----
+
+Configuration c1 = new ConfigurationBuilder()  
+   // Adjust any configuration defaults you want  
+   .clustering()  
+      .l1()  
+         .disable()  
+      .mode(DIST_SYNC)  
+      .hash()  
+         .numOwners(5)  
+   .build();  
+
+----
+
+The old bean style configuration is now deprecated and will be removed in a later version.
+
+Configuration properties which can be safely changed at runtime are mutable, and all others are immutable.
+
+To copy a configuration, use the read() method on the builder, for example:
+
+
+----
+
+Configuration c2 = new ConfigurationBuilder()  
+   // Read in C1 to provide defaults  
+   .read(c1)  
+   .clustering()  
+      .l1()  
+         .enable()  
+   // This cache is DIST_SYNC, will have 5 owners, with L1 cache enabled  
+   .build();  
+
+----
+
+ This completely replaces the old system of defining a set of overrides on bean properties. Note that this means the behaviour of Infinispan configuration is somewhat different when used programmatically. Whilst before, you could define a default configuration, and any overrides would be applied on top of _your_ defaults when defined, now you must explicitly read in your defaults to the builder. This allows for much greater flexibility in your code (you can have a as many "default" configurations as you want), and makes your code more explicit and type safe (finding references works). 
+
+The schema is unchanged from before. Infinispan 4.0 configurations are currently not being parsed. To upgrade, just change the schema definition from:
+
+
+----
+
+<infinispan  
+     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
+     xsi:schemaLocation="urn:infinispan:config:4.1 http://www.infinispan.org/schemas/infinispan-config-4.1.xsd"  
+     xmlns="urn:infinispan:config:4.1">  
+
+----
+
+to
+
+
+----
+
+<infinispan  
+     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
+     xsi:schemaLocation="urn:infinispan:config:5.1 http://www.infinispan.org/schemas/infinispan-config-5.1.xsd"  
+     xmlns="urn:infinispan:config:5.1">  
+
+----
+
+The schema documentation has changed format, as it is now produced using the standard tool xsddoc. This should be a significant improvement, as better navigation is offered. Some elements and attributes are missing docs right now, we are working on adding this. As an added benefit, your IDE should now show documentation when an xsd referenced (as above)
+
+We are in the process of adding in support for this configuration style for modules (such as cache stores). In the meantime, please use the old configuration or XML if you require support for cache store module configuration.
+
+[[sid-68355206_Upgradingfrom5.0to5.1-FlagsandClassLoaders]]
+
+
+=== Flags and ClassLoaders
+
+The Flags and ClassLoaders API has changed. In the past, the following would work:
+
+ cache.withFlags(f1, f2); cache.withClassLoader(cl); cache.put(k, v); 
+
+In 5.1.0, these withX() methods return a new instance and not the cache itself, so thread locals are avoided and the code above will not work. If used in a fluent manner however, things still work:
+
+
+----
+
+cache.withFlags(f1, f2).withClassLoader(cl).put(k, v);
+
+----
+
+The above pattern has always been the intention of this API anyway.
+
+[[sid-68355206_Upgradingfrom5.0to5.1-JGroupsBindAddress]]
+
+
+=== JGroups Bind Address
+
+ Since upgrading to JGroups 3.x, -Dbind.address is ignored. This should be replaced with -Djgroups.bind_addr . 
+
+[[sid-68355207]]
+
+
+=== Configuration changes from 5.0 to 5.1
+
+If you use XML to configure Infinispan, you shouldn't notice any change, except a much faster startup, courtesy of the Stax based parser. However, if you use programmatic configuration, read on for the important differences.
+
+Configuration is now packaged in org.infinispan.configuration, and you must use a builder style:
+
+
+----
+
+Configuration c1 = new ConfigurationBuilder()  
+   // Adjust any configuration defaults you want  
+   .clustering()  
+      .l1()  
+         .disable()  
+      .mode(DIST_SYNC)  
+      .hash()  
+         .numOwners(5)  
+   .build();  
+
+----
+
+The old bean style configuration is now deprecated and will be removed in a later version.
+
+Configuration properties which can be safely changed at runtime are mutable, and all others are immutable.
+
+To copy a configuration, use the read() method on the builder, for example:
+
+
+----
+
+Configuration c2 = new ConfigurationBuilder()  
+   // Read in C1 to provide defaults  
+   .read(c1)  
+   .clustering()  
+      .l1()  
+         .enable()  
+   // This cache is DIST_SYNC, will have 5 owners, with L1 cache enabled  
+   .build();  
+
+----
+
+ This completely replaces the old system of defining a set of overrides on bean properties. Note that this means the behaviour of Infinispan configuration is somewhat different when used programmatically. Whilst before, you could define a default configuration, and any overrides would be applied on top of _your_ defaults when defined, now you must explicitly read in your defaults to the builder. This allows for much greater flexibility in your code (you can have a as many "default" configurations as you want), and makes your code more explicit and type safe (finding references works). 
+
+The schema is unchanged from before. Infinispan 4.0 configurations are currently not being parsed. To upgrade, just change the schema definition from:
+
+
+----
+
+<infinispan  
+     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
+     xsi:schemaLocation="urn:infinispan:config:4.1 http://www.infinispan.org/schemas/infinispan-config-4.1.xsd"  
+     xmlns="urn:infinispan:config:4.1">  
+
+----
+
+to
+
+
+----
+
+<infinispan  
+     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
+     xsi:schemaLocation="urn:infinispan:config:5.1 http://www.infinispan.org/schemas/infinispan-config-5.1.xsd"  
+     xmlns="urn:infinispan:config:5.1">  
+
+----
+
+The schema documentation has changed format, as it is now produced using the standard tool xsddoc. This should be a significant improvement, as better navigation is offered. Some elements and attributes are missing docs right now, we are working on adding this. As an added benefit, your IDE should now show documentation when an xsd referenced (as above)
+
+We are in the process of adding in support for this configuration style for modules (such as cache stores). In the meantime, please use the old configuration or XML if you require support for cache store module configuration.
+
diff --git a/documentation/src/main/asciidoc/upgrading/chapter-2-Upgrading_from_5_1_to_5_2.adoc b/documentation/src/main/asciidoc/upgrading/chapter-2-Upgrading_from_5_1_to_5_2.adoc
new file mode 100644
index 0000000..694abb5
--- /dev/null
+++ b/documentation/src/main/asciidoc/upgrading/chapter-2-Upgrading_from_5_1_to_5_2.adoc
@@ -0,0 +1,62 @@
+[[sid-68355208]]
+
+==  Upgrading from 5.1 to 5.2
+
+[[sid-68355208_Upgradingfrom5.1to5.2-Declarativeconfiguration]]
+
+
+=== Declarative configuration
+
+In order to use all of the latest features, make sure you change the namespace declaration at the top of your XML configuration files as follows:
+
+
+----
+
+<infinispan xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:infinispan:config:5.2 http://www.infinispan.org/schemas/infinispan-config-5.2.xsd" xmlns="urn:infinispan:config:5.2">
+   ...
+</infinispan>
+
+----
+
+[[sid-68355208_Upgradingfrom5.1to5.2-Transaction]]
+
+
+=== Transaction
+
+ The default transaction enlistment model has changed ( link:$$https://issues.jboss.org/browse/ISPN-1284$$[ISPN-1284] ) from link:$$http://docs.oracle.com/javase/1.4.2/docs/api/javax/transaction/xa/XAResource.html$$[XAResounce] to link:$$http://docs.oracle.com/javaee/5/api/javax/transaction/Synchronization.html$$[Synchronization] . Also now, if the link:$$http://docs.oracle.com/javase/1.4.2/docs/api/javax/transaction/xa/XAResource.html$$[XAResounce] enlistment is used, then link:$$https://docs.jboss.org/author/display/ISPN/Transaction+recovery$$[recovery] is enabled by default. 
+
+In practical terms, if you were using the default values, this should not cause any backward compatibility issues but an increase in performance of about 5-7%. However in order to use the old configuration defaults, you need to configure the following:
+
+
+----
+
+<transaction useSynchronization="false">
+   <recovery enabled="false"/>
+</transaction>
+
+----
+
+or the programmatic configuration equivalent:
+
+
+----
+
+ConfigurationBuilder builder = new ConfigurationBuilder();
+builder.transaction().useSynchronization(false).recovery().enabled(false)
+
+----
+
+[[sid-68355208_Upgradingfrom5.1to5.2-CacheLoaderandStoreconfiguration]]
+
+
+=== Cache Loader and Store configuration
+
+ Cache Loader and Store configuration has changed greatly in Infinispan 5.2. Please refer to the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737103$$[Cache Loaders and Stores] documentation. 
+
+[[sid-68355208_Upgradingfrom5.1to5.2-VirtualNodes%3ESegments]]
+
+
+=== Virtual Nodes &gt; Segments
+
+ The concept of Virtual Nodes doesn't exist anymore in Infinispan 5.2 and has been replaced by Segments. Please refer to the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737115$$[Clustering modes] documentation 
+
diff --git a/documentation/src/main/asciidoc/upgrading/chapter-3-Upgrading_from_5_2_to_5_3.adoc b/documentation/src/main/asciidoc/upgrading/chapter-3-Upgrading_from_5_2_to_5_3.adoc
new file mode 100644
index 0000000..8a7ada0
--- /dev/null
+++ b/documentation/src/main/asciidoc/upgrading/chapter-3-Upgrading_from_5_2_to_5_3.adoc
@@ -0,0 +1,6 @@
+[[sid-68355209]]
+
+==  Upgrading from 5.2 to 5.3
+
+This page documents the code / configuration changes required when upgrading from Infinispan 5.2 to 5.3
+
diff --git a/documentation/src/main/asciidoc/upgrading/upgrading.adoc b/documentation/src/main/asciidoc/upgrading/upgrading.adoc
new file mode 100644
index 0000000..5282c79
--- /dev/null
+++ b/documentation/src/main/asciidoc/upgrading/upgrading.adoc
@@ -0,0 +1,4 @@
+
+include::chapter-1-Upgrading_from_5_0_to_5_1.adoc\[\]
+include::chapter-2-Upgrading_from_5_1_to_5_2.adoc\[\]
+include::chapter-3-Upgrading_from_5_2_to_5_3.adoc\[\]
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-1-New_in_Infinispan_4_1_0.adoc b/documentation/src/main/asciidoc/user_guide/chapter-1-New_in_Infinispan_4_1_0.adoc
index 0e9a094..056066e 100644
--- a/documentation/src/main/asciidoc/user_guide/chapter-1-New_in_Infinispan_4_1_0.adoc
+++ b/documentation/src/main/asciidoc/user_guide/chapter-1-New_in_Infinispan_4_1_0.adoc
@@ -1,4 +1,4 @@
-[[sid-8093923_UserGuide-NewinInfinispan4.1.0]]
+[[sid-68355028_UserGuide-NewinInfinispan4.1.0]]
 
 ==  New in Infinispan 4.1.0
 
@@ -12,7 +12,7 @@
 . Hot Rod
 
 
-.  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=5931578$$[Protocol specification (version 1)] 
+.  <<sid-68355113,Protocol specification (version 1)>> 
 
 
 .  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737146$$[Using the Hot Rod server module] 
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-10-Using_Infinispan_Memcached_Server.adoc b/documentation/src/main/asciidoc/user_guide/chapter-10-Using_Infinispan_Memcached_Server.adoc
new file mode 100644
index 0000000..c63666a
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-10-Using_Infinispan_Memcached_Server.adoc
@@ -0,0 +1,151 @@
+[[sid-68355035]]
+
+==  Using Infinispan Memcached Server
+
+[[sid-68355035_UsingInfinispanMemcachedServer-Introduction]]
+
+
+=== Introduction
+
+ Starting with version 4.1, the Infinispan distribution contains a server module that implements the link:$$http://github.com/memcached/memcached/blob/master/doc/protocol.txt$$[Memcached text protocol] . This allows Memcached clients to talk to one or serveral Infinispan backed Memcached servers. These servers could either be working standalone just like Memcached does where each server acts independently and does not communicate with the rest, or they could be clustered where servers replicate or distribute their contents to other Infinispan backed Memcached servers, thus providing clients with failover capabilities. 
+
+[[sid-68355035_UsingInfinispanMemcachedServer-StartinganInfinispanMemcachedserver]]
+
+
+=== Starting an Infinispan Memcached server
+
+ The simplest way to start up an Infinispan memcached server is to simply unzip the all distribution and either run the startServer.bat or startServer.sh script passing memcached as the protocol to run. For example: 
+
+
+----
+$ ./bin/startServer.sh -r memcached
+----
+
+ When the script is called without any further parameters, the started Infinispan Memcached server binds to _port 11211 on localhost_ (127.0.0.1) and uses a local (unclustered) Infinispan cache instance configured with default values underneath. 
+
+[[sid-68355035_UsingInfinispanMemcachedServer-CommandLineOptions]]
+
+
+=== Command Line Options
+
+ You can optionally pass a set of parameters to the Infinispan Memcached server that allow you to configure different parts of the server. You can find detailed information in the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737161$$[server command line options article] . 
+
+Please note that, since the Memcached protocol does not allow specifying a cache to use, the mapping between Infinispan Memcached server instances and Infinispan Cache instances is 1 to 1. Therefore, when passing an Infinispan configuration file to the Infinispan Memcache server, either define a named cache with name "memcachedCache" or modify the default cache configuration.
+
+[[sid-68355035_UsingInfinispanMemcachedServer-EnablingStatistics]]
+
+
+=== Enabling Statistics
+
+ The memcached module makes use of the JMX statistics in the cache configuration. For example: 
+
+
+----
+<default>
+   ...
+   <jmxStatistics enabled="true"/>
+   ...
+</default>
+
+----
+
+Infinispan Memcached server has jmx statistics enabled by default.
+
+[[sid-68355035_UsingInfinispanMemcachedServer-CommandClarifications]]
+
+
+=== Command Clarifications
+
+[[sid-68355035_UsingInfinispanMemcachedServer-FlushAll]]
+
+
+==== Flush All
+
+ Even in a clustered environment, flush_all command leads to the clearing of the Infinispan Memcached server where the call lands. There's no attempt to propagate this flush to other nodes in the cluster. This is done so that flush_all with delay use case can be reproduced with the Infinispan Memcached server. The aim of passing a delay to flush_all is so that different Memcached servers in a full can be flushed at different times, and hence avoid overloading the database with requests as a result of all Memcached servers being empty. For more info, check the link:$$http://github.com/memcached/memcached/blob/master/doc/protocol.txt$$[Memcached text protocol section on flush_all] . 
+
+[[sid-68355035_UsingInfinispanMemcachedServer-UnsupportedFeatures]]
+
+
+=== Unsupported Features
+
+This section explains those parts of the memcached text protocol that for one reason or the other, are not currently supported by the Infinispan based memcached implementation.
+
+[[sid-68355035_UsingInfinispanMemcachedServer-IndividualStats]]
+
+
+==== Individual Stats
+
+Due to difference in nature between the original memcached implementation which is C/$$C++$$ based and the Infinispan implementation which is Java based, there're some general purpose stats that are not supported. For these unsupported stats, Infinispan memcached server always returns 0.
+
+Here's the list of currently unsupported stats:
+
+
+*  pid 
+
+
+*  pointer_size 
+
+
+*  rusage_user 
+
+
+*  rusage_system 
+
+
+*  bytes 
+
+
+*  curr_connections 
+
+
+*  total_connections 
+
+
+*  connection_structures 
+
+
+*  auth_cmds 
+
+
+*  auth_errors 
+
+
+*  limit_maxbytes 
+
+
+*  threads 
+
+
+*  conn_yields 
+
+
+*  reclaimed 
+
+[[sid-68355035_UsingInfinispanMemcachedServer-StatisticSettings]]
+
+
+==== Statistic Settings
+
+The settings statistics section of the text protocol has not been implemented due to its volatility.
+
+[[sid-68355035_UsingInfinispanMemcachedServer-SettingswithArgumentsParameter]]
+
+
+==== Settings with Arguments Parameter
+
+ Since the arguments that can be send to the Memcached server are not documented, Infinispan Memcached server does not support passing any arguments to stats command. If any parameters are passed, the Infinispan Memcached server will respond with a CLIENT_ERROR . 
+
+[[sid-68355035_UsingInfinispanMemcachedServer-DeleteHoldTimeParameter]]
+
+
+==== Delete Hold Time Parameter
+
+Memcached does no longer honor the optional hold time parameter to delete command and so the Infinispan based memcached server does not implement such feature either.
+
+[[sid-68355035_UsingInfinispanMemcachedServer-VerbosityCommand]]
+
+
+==== Verbosity Command
+
+Verbosity command is not supported since Infinispan logging cannot be simplified to defining the logging level alone.
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-11-Asynchronous_API.adoc b/documentation/src/main/asciidoc/user_guide/chapter-11-Asynchronous_API.adoc
new file mode 100644
index 0000000..bba18ec
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-11-Asynchronous_API.adoc
@@ -0,0 +1,74 @@
+[[sid-68355036]]
+
+==  Asynchronous API
+
+ In addition to synchronous API methods like link:$$http://java.sun.com/javase/6/docs/api/java/util/Map.html#put%28K,%20V%29$$[Cache.put()] , link:$$http://java.sun.com/javase/6/docs/api/java/util/Map.html#remove%28java.lang.Object%29$$[Cache.remove()] , etc., Infinispan also has an asynchronous, non-blocking API where you can achieve the same results in a non-blocking fashion. 
+
+ These methods are named in a similar fashion to their blocking counterparts, with "Async" appended.  E.g., link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html#putAsync%28K,%20V%29$$[Cache.putAsync()] , link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html#removeAsync%28java.lang.Object%29$$[Cache.removeAsync()] , etc.  These asynchronous counterparts return a link:$$http://download.oracle.com/javase/6/docs/api/java/util/concurrent/Future.html$$[Future] containing the actual result of the operation. 
+
+For example, in a cache paramerized as Cache&lt;String, String&gt;, Cache.put(String key, String value) returns a String.  Cache.putAsync(String key, String value) would return a Future&lt;String&gt;.
+
+[[sid-68355036_AsynchronousAPI-WhyusesuchanAPI%3F]]
+
+
+=== Why use such an API?
+
+Non-blocking APIs are powerful in that they provide all of the guarantees of synchronous communications - with the ability to handle communication failures and exceptions - with the ease of not having to block until a call completes.  This allows you to better harness parallelism in your system.  For example:
+
+
+----
+Set<Future<?>> futures = new HashSet<Future<?>>();
+futures.add(cache.putAsync(key1, value1)); // does not block
+futures.add(cache.putAsync(key2, value2)); // does not block
+futures.add(cache.putAsync(key3, value3)); // does not block
+
+// the remote calls for the 3 puts will effectively be executed
+// in parallel, particularly useful if running in distributed mode
+// and the 3 keys would typically be pushed to 3 different nodes
+// in the cluster
+
+// check that the puts completed successfully
+for (Future<?> f: futures) f.get();
+
+----
+
+[[sid-68355036_AsynchronousAPI-Whichprocessesactuallyhappenasynchronously%3F]]
+
+
+=== Which processes actually happen asynchronously?
+
+ There are 4 things in Infinispan that can be considered to be on the critical path of a typical write operation.  These are, in terms of cost, network calls, marshalling, writing to a cache store (optional), and locking.  As of Infinispan 4.0, using the async methods will take the network calls and marshalling off the critical path.  For various technical reasons, writing to a cache store and acquiring locks, however, still happens in the caller's thread.  In future, we plan to take these offline as well.  See link:$$http://lists.jboss.org/pipermail/infinispan-dev/2010-January/002219.html$$[this developer mail list thread] about this topic. 
+
+[[sid-68355036_AsynchronousAPI-Notifyingfutures]]
+
+
+=== Notifying futures
+
+ Strictly, these methods do not return JDK Futures, but rather a sub-interface known as a link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/util/concurrent/NotifyingFuture.html$$[NotifyingFuture] .  The main difference is that you can attach a listener to a NotifyingFuture such that you could be notified when the future completes.  Here is an example of making use of a notifying future: 
+
+
+----
+
+FutureListener futureListener = new FutureListener() {
+
+   public void futureDone(Future future) {
+      try {
+         future.get();
+      } catch (Exception e) {
+         // Future did not complete successfully
+         System.out.println("Help!");
+      }
+   }
+};
+      
+cache.putAsync("key", "value").attachListener(futureListener);
+
+----
+
+[[sid-68355036_AsynchronousAPI-Furtherreading]]
+
+
+=== Further reading
+
+ The Javadocs on the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html$$[Cache] interface has some examples on using the asynchronous API, as does link:$$http://infinispan.blogspot.com/2009/05/whats-so-cool-about-asynchronous-api.html$$[this article] by Manik Surtani introducing the API. 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-12-Tree_API_Module.adoc b/documentation/src/main/asciidoc/user_guide/chapter-12-Tree_API_Module.adoc
new file mode 100644
index 0000000..b1a3610
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-12-Tree_API_Module.adoc
@@ -0,0 +1,280 @@
+[[sid-68355037]]
+
+==  Tree API Module
+
+[[sid-68355037_TreeAPIModule-Introduction]]
+
+
+=== Introduction
+
+ link:$$http://docs.jboss.org/infinispan/4.2/apidocs/org/infinispan/tree/package-summary.html$$[Infinispan's tree API module] offers clients the possibility of storing data using a tree-structure like API. This API is similar to the one link:$$http://docs.jboss.org/jbosscache/3.2.1.GA/apidocs/org/jboss/cache/package-summary.html$$[provided by JBoss Cache] , hence the tree module is perfect for those users wanting to migrate their applications from JBoss Cache to Infinispan, who want to limit changes their codebase as part of the migration. Besides, it's important to understand that Infinispan provides this tree API much more efficiently than JBoss Cache did, so if you're a user of the tree API in JBoss Cache, you should consider migrating to Infinispan. 
+
+[[sid-68355037_TreeAPIModule-WhatisTreeAPIabout%3F]]
+
+
+=== What is Tree API about?
+
+ The aim of this API is to store information in a hierarchical way. The hierarchy is defined using paths represented as link:$$http://docs.jboss.org/infinispan/4.2/apidocs/org/infinispan/tree/Fqn.html$$[Fqn or fully qualified names] , for example: _/this/is/a/fqn/path_ or _/another/path_ . In the hierarchy, there's an special path called root which represents the starting point of all paths and it's represented as: _/_ 
+
+ Each FQN path is represented as a node where users can store data using a key/value pair style API (i.e. a Map). For example, in _/persons/john_ , you could store information belonging to John, for example: surname=Smith, birthdate=05/02/1980...etc. 
+
+Please remember that users should not use root as a place to store data. Instead, users should define their own paths and store data there. The following sections will delve into the practical aspects of this API.
+
+[[sid-68355037_TreeAPIModule-UsingTreeAPI]]
+
+
+=== Using Tree API
+
+[[sid-68355037_TreeAPIModule-Dependencies]]
+
+
+==== Dependencies
+
+ For your application to use the tree API, you need to import infinispan-tree.jar which can be located in the Infinispan binary distributions, or you can simply add a dependency to this module in your pom.xml: 
+
+
+----
+
+<dependencies>
+  ...
+  <dependency>
+    <groupId>org.infinispan</groupId>
+    <artifactId>infinispan-tree</artifactId>
+    <version>$put-infinispan-version-here</version>
+  </dependency>
+  ...
+</dependencies>
+
+----
+
+[[sid-68355037_TreeAPIModule-CreatingaTreeCache]]
+
+
+==== Creating a Tree Cache
+
+ The first step to use the tree API is to actually create a tree cache. To do so, you need to link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737143$$[create an Infinispan Cache as you'd normally do] , and using the link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/TreeCacheFactory.html$$[TreeCacheFactory] , create an instance of link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/TreeCache.html$$[TreeCache] . A very important note to remember here is that the Cache instance passed to the factory must be configured with link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737131$$[invocation batching] . For example: 
+
+
+----
+import org.infinispan.config.Configuration;
+import org.infinispan.tree.TreeCacheFactory;
+import org.infinispan.tree.TreeCache;
+...
+Configuration config = new Configuration();
+config.setInvocationBatchingEnabled(true);
+Cache cache = new DefaultCacheManager(config).getCache();
+TreeCache treeCache = TreeCacheFactory.createTreeCache(cache);
+
+----
+
+[[sid-68355037_TreeAPIModule-ManipulatingdatainaTreeCache]]
+
+
+==== Manipulating data in a Tree Cache
+
+The Tree API effectively provides two ways to interact with the data:
+
+
+.  Via link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/TreeCache.html$$[TreeCache] convenience methods: These methods are located within the TreeCache interface and enable users to link:$$http://docs.jboss.org/infinispan/4.2/apidocs/org/infinispan/tree/TreeCache.html#put(java.lang.String, K, V)$$[store] , link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/TreeCache.html#get(org.infinispan.tree.Fqn, K)$$[retrieve] , link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/TreeCache.html#move(org.infinispan.tree.Fqn, org.infinispan.tree.Fqn)$$[move] , link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/TreeCache.html#remove(org.infinispan.tree.Fqn, K)$$[remove] ...etc data with a single call that takes the link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/Fqn.html$$[Fqn] , in String or Fqn format, and the data involved in the call. For example: 
+
+
+----
+treeCache.put("/persons/john", "surname", "Smith");
+----
+
+Or:
+
+
+----
+import org.infinispan.tree.Fqn;
+...
+Fqn johnFqn = Fqn.fromString("persons/john");
+Calendar calendar = Calendar.getInstance();
+calendar.set(1980, 5, 2);
+treeCache.put(johnFqn, "birthdate", calendar.getTime()));
+
+----
+
+
+.  Via link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/Node.html$$[Node] API: It allows finer control over the individual nodes that form the FQN, allowing manipulation of nodes relative to a particular node. For example: 
+
+
+----
+import org.infinispan.tree.Node;
+...
+TreeCache treeCache = ...
+Fqn johnFqn = Fqn.fromElements("persons", "john"); 
+Node<String, Object> john = treeCache.getRoot().addChild(johnFqn);
+john.put("surname", "Smith");
+
+----
+
+Or:
+
+
+----
+Node persons = treeCache.getRoot().addChild(Fqn.fromString("persons"));
+Node<String, Object> john = persons.addChild(Fqn.fromString("john"));
+john.put("surname", "Smith");
+
+----
+
+Or even:
+
+
+----
+Fqn personsFqn = Fqn.fromString("persons");
+Fqn johnFqn = Fqn.fromRelative(personsFqn, Fqn.fromString("john"));
+Node<String, Object> john = treeCache.getRoot().addChild(johnFqn);
+john.put("surname", "Smith");
+
+----
+
+ A node also provides the ability to access its link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/Node.html#getParent()$$[parent] or link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/Node.html#getChildren()$$[children] . For example: 
+
+
+----
+Node<String, Object> john = ...
+Node persons = john.getParent();
+
+----
+
+Or:
+
+
+----
+Set<Node<String, Object>> personsChildren = persons.getChildren();
+----
+
+[[sid-68355037_TreeAPIModule-CommonOperations]]
+
+
+==== Common Operations
+
+In the previous section, some of the most used operations, such as addition and retrieval, have been shown. However, there are other important operations that are worth mentioning, such as remove:
+
+ You can for example remove an entire node, i.e. _/persons/john_ , using: 
+
+
+----
+treeCache.removeNode("/persons/john");
+----
+
+Or remove a child node, i.e. persons that a child of root, via:
+
+
+----
+treeCache.getRoot().removeChild(Fqn.fromString("persons"));
+----
+
+You can also remove a particular key/value pair in a node:
+
+
+----
+Node john = treeCache.getRoot().getChild(Fqn.fromElements("persons", "john"));
+john.remove("surname");
+----
+
+Or you can remove all data in a node with:
+
+
+----
+Node john = treeCache.getRoot().getChild(Fqn.fromElements("persons", "john"));
+john.clearData();
+----
+
+Another important operation supported by Tree API is the ability to move nodes around in the tree. Imagine we have a node called "john" which is located under root node. The following example is going to show how to we can move "john" node to be under "persons" node:
+
+Current tree structure:
+
+
+----
+
+   /persons
+   /john
+
+----
+
+Moving trees from one FQN to another:
+
+
+----
+
+Node john = treeCache.getRoot().addChild(Fqn.fromString("john"));
+Node persons = treeCache.getRoot().getChild(Fqn.fromString("persons"));
+treeCache.move(john.getFqn(), persons.getFqn());
+
+----
+
+Final tree structure:
+
+
+----
+
+   /persons/john
+
+----
+
+[[sid-68355037_TreeAPIModule-LockingInTreeAPI]]
+
+
+=== Locking In Tree API
+
+Understanding when and how locks are acquired when manipulating the tree structure is important in order to maximise the performance of any client application interacting against the tree, while at the same time maintaining consistency.
+
+Locking on the tree API happens on a per node basis. So, if you're putting or updating a key/value under a particular node, a write lock is acquired for that node. In such case, no write locks are acquired for parent node of the node being modified, and no locks are acquired for children nodes.
+
+If you're adding or removing a node, the parent is not locked for writing. In JBoss Cache, this behaviour was configurable with the default being that parent was not locked for insertion or removal.
+
+Finally, when a node is moved, the node that's been moved and any of its children are locked, but also the target node and the new location of the moved node and its children. To understand this better, let's look at an example:
+
+Imagine you have a hierarchy like this and we want to move c/ to be underneath b/:
+
+
+----
+        /
+      --|--
+     /     \
+     a     c
+     |     |
+     b     e
+     |
+     d
+
+----
+
+The end result would be something like this:
+
+
+----
+        /
+        |          
+        a     
+        |     
+        b     
+      --|--
+     /     \
+     d     c
+           |
+           e
+
+----
+
+To make this move, locks would have been acquired on:
+
+
+*  _/a/b_ - because it's the parent underneath which the data will be put 
+
+
+*  _/c_ and _/c/e_ - because they're the nodes that are being moved 
+
+
+*  _/a/b/c_ and _/a/b/c/e_ - because that's new target location for the nodes being moved 
+
+[[sid-68355037_TreeAPIModule-Listenersfortreecacheevents]]
+
+
+=== Listeners for tree cache events
+
+ The current Infinispan listeners have been designed with key/value store notifications in mind, and hence they do not map to tree cache events correctly. Tree cache specific listeners that map directly to tree cache events (i.e. adding a child...etc) are desirable but these are not yet available. If you're interested in this type of listeners, please follow link:$$https://issues.jboss.org/browse/ISPN-1935$$[this issue] to find out about any progress in this area. 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-13-Infinispan_as_a_storage_for_Lucene_indexes.adoc b/documentation/src/main/asciidoc/user_guide/chapter-13-Infinispan_as_a_storage_for_Lucene_indexes.adoc
new file mode 100644
index 0000000..060d71f
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-13-Infinispan_as_a_storage_for_Lucene_indexes.adoc
@@ -0,0 +1,217 @@
+[[sid-68355039]]
+
+==  Infinispan as a storage for Lucene indexes
+
+ Infinispan is including a highly scalable distributed _Apache Lucene Directory_ implementation. 
+
+This directory closely mimicks the same semantics of the traditional filesystem and RAM-based directories, being able to work as a drop-in replacement for existing applications using Lucene and providing reliable index sharing and other features of Infinispan like node autodiscovery, automatic failover and rebalancing, optionally transactions, and can be backed by traditional storage solutions as filesystem, databases or cloud store engines.
+
+ The implementation extends Lucene's _org.apache.lucene.store.Directory_ so it can be used to _store_ the index in a cluster-wide shared memory, making it easy to distribute the index. Compared to rsync-based replication this solution is suited for use cases in which your application makes frequent changes to the index and you need them to be quickly distributed to all nodes, having configurable consistency levels, synchronicity and guarantees, total elasticity and autodiscovery; also changes applied to the index can optionally participate in a JTA transaction; since version 5 supporting XA transactions with recovery. 
+
+ Two different _LockFactory_ implementations are provided to guarantee only one _IndexWriter_ at a time will make changes to the index, again implementing the same semantics as when opening an index on a local filesystem. As with other Lucene Directories, you can override the _LockFactory_ if you prefer to use an alternative implementation. 
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-AdditionalLinks]]
+
+
+=== Additional Links
+
+ Javadoc: link:$$http://docs.jboss.org/infinispan/5.3/apidocs/org/infinispan/lucene/InfinispanDirectory.html$$[] Issue tracker: link:$$https://jira.jboss.org/browse/ISPN/component/12312732$$[] Source code: link:$$http://www.jboss.org/infinispan/sourcecode.html$$[] 
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-Lucenecompatibility]]
+
+
+=== Lucene compatibility
+
+ Current version was developed and compiled against both _Lucene 3.6.2_ and _Lucene 4.3.0_ (separately and then assembled in a single jar for your convenience as most code is shared). It is also regularly tested to work with Lucene versions from 3.0.x to 3.5.0, version 2.9.x, the older 2.4.1 and newer version 4.0, 4.1, 4.2. 
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-Howtouseit]]
+
+
+=== How to use it
+
+To create a Directory instance:
+
+
+----
+import org.apache.lucene.store.Directory;
+import org.infinispan.lucene.directory.DirectoryBuilder;
+import org.infinispan.Cache;
+
+Cache cache = // create an Infinispan cache, configured as you like
+Directory indexDir = DirectoryBuilder.newDirectoryInstance(cache, cache, cache, indexName)
+                                     .create();
+
+----
+
+ The _indexName_ is a unique key to identify your index. It takes the same role as the path did on filesystem based indexes: you can create several different indexes giving them different names. When you use the same _indexName_ in another instance connected to the same network (or instantiated on the same machine, useful for testing) they will join, form a cluster and share all content. Using a different _indexName_ allows you to store different indexes in the same set of Caches. 
+
+ The _cache_ is passed three times in this example, as that is ok for a quick demo, but as the API suggests it's a good idea to tune each cache separately as they will be used in different ways. More details provided below. 
+
+New nodes can be added or removed dynamically, making the service administration very easy and also suited for cloud environments: it's simple to react to load spikes, as adding more memory and CPU power to the search system is done by just starting more nodes.
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-Limitations]]
+
+
+=== Limitations
+
+ As when using an _IndexWriter_ on a filesystem based _Directory_ , even on the clustered edition only one _IndexWriter_ can be opened across the whole cluster. 
+
+ As an example, link:$$http://search.hibernate.org$$[Hibernate Search] , which includes integration with this Lucene Directory since version 3.3, sends index change requests across a JMS queue, or a _JGroups_ channel. Other valid approaches are to proxy the remote _IndexWriter_ or just design your application in such a way that only one node attempts to write it. 
+
+Reading (searching) is of course possible in parallel, from any number of threads on each node; changes applied to the single IndexWriter are affecting results of all threads on all nodes in a very short time, or guaranteed to be visible after a commit when using transactions.
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-Configuration]]
+
+
+=== Configuration
+
+ Infinispan can be configured as LOCAL clustering mode, in which case it will disable clustering features and serve as a cache for the index, or any clustering mode. A transaction manager is not mandatory, but when enabled the changes to the index can participate in transactions. 
+
+Batching was required in previous versions, it's not strictly needed anymore.
+
+ As better explained in the javadocs of _org.infinispan.lucene.InfinispanDirectory_ , it's possible for it to use more than a single cache, using specific configurations for different purposes. When using readlocks, make sure to not enable transactions on this cache. 
+
+Any Infinispan configuration should work fine as long as caches are not configured to remove entries after thresholds.
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-Demo]]
+
+
+=== Demo
+
+ There is a simple command-line demo of it's capabilities distributed with Infinispan under demos/lucene-directory; make sure you grab the _"Binaries, server and demos"_ package from link:$$http://www.jboss.org/infinispan/downloads$$[download page] , which contains all demos. 
+
+Start several instances, then try adding text in one instance and searching for it on the other. The configuration is not tuned at all, but should work out-of-the box without any changes. If your network interface has multicast enabled, it will cluster across the local network with other instances of the demo.
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-Mavendependencies]]
+
+
+=== Maven dependencies
+
+ All you need is _org.infinispan:infinispan-lucene-directory_ : 
+
+
+----
+<dependency>
+   <groupId>org.infinispan</groupId>
+   <artifactId>infinispan-lucene-directory</artifactId>
+   <version>5.3.0.Beta1</version>
+</dependency>
+
+----
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-UsingaCacheLoader]]
+
+
+=== Using a CacheLoader
+
+ Using a CacheLoader you can have the index content backed up to a permanent storage; you can use a shared store for all nodes or one per node, see <<sid-68355053>> for more details. 
+
+ When using a CacheLoader to store a Lucene index, to get best write performance you would need to configure the CacheLoader with _async=true_ . 
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-Storingtheindexinadatabase]]
+
+
+==== Storing the index in a database
+
+ It might be useful to store the Lucene index in a relational database; this would be very slow but Infinispan can act as a cache between the application and the JDBC interface, making this configuration useful in both clustered and non-clustered configurations. When storing indexes in a JDBC database, it's suggested to use the _JdbcStringBasedCacheStore_ , which will need this attribute: 
+
+
+----
+
+<property name="key2StringMapperClass" value="org.infinispan.lucene.LuceneKey2StringMapper" />
+
+----
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-LoadinganexistingLuceneIndex]]
+
+
+==== Loading an existing Lucene Index
+
+ The _org.infinispan.lucene.cachestore.LuceneCacheLoader_ is an Infinispan CacheLoader able to have Infinispan directly load data from an existing Lucene index into the grid. Currently this supports reading only. 
+
+[options="header"]
+|===============
+|Property|Description|Default
+| _location_ |The path where the indexes are stored. Subdirectories (of first level only) should contain the indexes to be loaded, each directory matching the index name attribute of the InfinispanDirectory constructor.|none (mandatory)
+| _autoChunkSize_ |A threshold in bytes: if any segment is larger than this, it will be transparently chunked in smaller cache entries up to this size.|32MB
+
+|===============
+
+
+ It's worth noting that the IO operations are delegated to Lucene's standard _org.apache.lucene.store.FSDirectory_ , which will select an optimal approach for the running platform. 
+
+Implementing write-through should not be hard: you're welcome to try implementing it.
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-Architecturallimitations]]
+
+
+=== Architectural limitations
+
+ This Directory implementation makes it possible to have almost real-time reads across multiple nodes. A fundamental limitation of the Lucene design is that only a single IndexWriter is allowed to make changes on the index: a pessimistic lock is acquired by the writer; this is generally ok as a single IndexWriter _instance_ is very fast and accepts update requests from multiple threads. When sharing the Directory across Infinispan nodes the IndexWriter limitation is not lifted: since you can have only one instance, that reflects in your application as having to apply all changes on the same node. There are several strategies to write from multiple nodes on the same index: 
+
+
+* One node writes, the other delegate to it sending messages
+
+
+* Each node writes on turns
+
+
+* You application makes sure it will only ever apply index writes on one node
+
+ The _Infinispan Lucene Directory_ protects its content by implementing a distributed locking strategy, though this is designed as a last line of defense and is not to be considered an efficient mechanism to coordinate multiple writes: if you don't apply one of the above suggestions and get high write contention from multiple nodes you will likely get timeout exception. 
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-Suggestionsforoptimalperformance]]
+
+
+=== Suggestions for optimal performance
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-JGroups%26Neworkingstack]]
+
+
+==== JGroups &amp; Neworking stack
+
+ JGroups manages all network IO and as such it is a critical component to tune for your specific environment. Make sure to read the link:$$http://jgroups.org/manual-3.x/html/index.html$$[JGroups reference documentation] , and play with the performance tests included in JGroups to make sure your network stack is setup appropriately. Don't forget to check also operating system level parameters, for example buffer sizes dedicated for networking. JGroups will log warning when it detects something wrong, but there is much more you can look into. 
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-UsingaCacheStore]]
+
+
+==== Using a CacheStore
+
+ Currently all CacheStore implementations provided by Infinispan have a significant slowdown; we hope to resolve that soon but for the time being if you need high performance on writes with the Lucene Directory the best option is to disable any CacheStore; the second best option is to configure the CacheStore as _async_ . If you only need to load a Lucene index from read-only storage, see the above description for _org.infinispan.lucene.cachestore.LuceneCacheLoader_ . 
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-ApplystandardLucenetuning]]
+
+
+==== Apply standard Lucene tuning
+
+ All known options of Lucene apply to the Infinispan Lucene Directory as well; of course the effect might be less significant in some cases, but you should definitely read the link:$$http://lucene.apache.org/core/index.html$$[Apache Lucene documentation] . 
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-Disablebatchingandtransactions]]
+
+
+==== Disable batching and transactions
+
+Early versions required Infinispan to have batching or transactions enabled. This is no longer a requirement, and in fact disabling them should provide little improvement in performance.
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-Settherightchunksize]]
+
+
+==== Set the right chunk size
+
+ The chunk size is an optional parameter to be passed to the Directory builder. While it's optional, its default is suited only for testing and small demos, while setting a larger size can have a dramatic effect on performance especially when running on multiple nodes. To correctly set this variable you need to estimate what the expected size of your segments is; generally this is trivial by looking at the file size of the index segments generated by your application when it's using the standard FSDirectory. You then have to consider: 
+
+
+* The chunk size affects the size of internally created buffers, so you don't want an outrageously large array as you're going to waste precious JVM memory. Also consider that during index writing such arrays are frequently allocated.
+
+
+* If a segment doesn't fit in the chunk size, it's going to be fragmented. When searching on a fragmented segment performance can't peak.
+
+ Using the _org.apache.lucene.index.IndexWriterConfig_ you can tune your index writing to _approximately_ keep your segment size to a reasonable level, from there then tune the chunksize, after having defined the chunksize you might want to revisit your network configuration settings. 
+
+[[sid-68355039_InfinispanasastorageforLuceneindexes-UsededicatedCacheinstances]]
+
+
+==== Use dedicated Cache instances
+
+ When constructing the Directory instance you have the option to specify different caches. The _metadataCache_ is going to be accessed frequently by all nodes and its content is very small, so it's best to use _$$REPL_SYNC$$_ . The _chunksCache_ contains the raw byte arrays of your index segments otherwise stored on filesystem, so - assuming your system is read-mostly - you might also want to use replication on this cache, but you have to consider if you have enough memory to store all the data replicated on all nodes; if not, you might be better off using _$$DIST_SYNC$$_ , optionally enabling L1. The _distLocksCache_ cache is similar to the _chunksCache_ , just that it doesn't need a CacheStore even if you want to persist the index. 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-14-Infinispan_Server_Modules.adoc b/documentation/src/main/asciidoc/user_guide/chapter-14-Infinispan_Server_Modules.adoc
new file mode 100644
index 0000000..5f56f41
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-14-Infinispan_Server_Modules.adoc
@@ -0,0 +1,155 @@
+[[sid-68355040]]
+
+==  Infinispan Server Modules
+
+[[sid-68355040_InfinispanServerModules-Introduction]]
+
+
+=== Introduction
+
+Traditionally, clients have interacted with Infinispan in a peer-to-peer (p2p) fashion where Infinispan and the client code that accessed it lived within the same VM. When Infinispan is queried in this way, it is considered to be accessed in an embedded fashion, as shown in the screenshot below
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+[[sid-68355040_InfinispanServerModules-ClientServeroverPeertoPeer]]
+
+
+==== Client-Server over Peer-to-Peer
+
+ However, there are situations when accessing Infinispan in a client-server mode might make more sense than accessing it via p2p. For example, when trying to _access Infinispan from a non-JVM environment_ . Since Infinispan is written in Java, if someone had a $$C++$$ application that wanted to access it, it couldn't just do it in a p2p way. On the other hand, client-server would be perfectly suited here assuming that a language neutral protocol was used and the corresponding client and server implementations were available. 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ In other situations, Infinispan users want to have an _elastic application tier_ where you start/stop business processing servers very regularly. Now, if users deployed Infinispan configured with distribution or state transfer, startup time could be greatly influenced by the shuffling around of data that happens in these situations. So in the following diagram, assuming Infinispan was deployed in p2p mode, the app in the second server could not access Infinispan until state transfer had completed. 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+This effectively means that bringing up new application-tier servers is impacted by things like state transfer because applications cannot access Infinispan until these processes have finished and if the state being shifted around is large, this could take some time. This is undesirable in an elastic environment where you want quick application-tier server turnaround and predictable startup times. Problems like this can be solved by accessing Infinispan in a client-server mode because starting a new application-tier server is just a matter of starting a lightweight client that can connect to the backing data grid server. No need for rehashing or state transfer to occur and as a result server startup times can be more predictable which is very important for modern cloud-based deployments where elasticity in your application tier is important.
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ Other times, it's common to find multiple applications needing access to data storage. In this cases, you could in theory deploy an Infinispan instance per each of those applications but this could be wasteful and difficult to maintain. Thing about databases here, you don't deploy a database alongside each of your applications, do you? So, alternatively you could deploy Infinispan in client-server mode keeping a pool of Infinispan data grid nodes acting as a _shared storage tier for your applications_ . 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+Deploying Infinispan in this way also allows you to manage each tier independently, for example, you can upgrade you application or app server without bringing down your Infinispan data grid nodes.
+
+[[sid-68355040_InfinispanServerModules-PeertoPeeroverClientServer]]
+
+
+==== to-Peer over Client-Server
+
+Before talking about individual Infinispan server modules, it's worth mentioning that in spite of all the benefits, client-server Infinispan still has disadvantages over p2p. Firstly, p2p deployments are simpler than client-server ones because in p2p, all peers are equals to each other and hence this simplifies deployment. So, if this is the first time you're using Infinispan, p2p is likely to be easier for you to get going compared to client-server.
+
+Client-server Infinispan requests are likely to take longer compared to p2p requests, due to the serialization and network cost in remote calls. So, this is an important factor to take in account when designing your application. For example, with replicated Infinispan caches, it might be more performant to have lightweight HTTP clients connecting to a server side application that accesses Infinispan in p2p mode, rather than having more heavyweight client side apps talking to Infinispan in client-server mode, particularly if data size handled is rather large. With distributed caches, the difference might not be so big because even in p2p deployments, you're not guaranteed to have all data available locally.
+
+Environments where application tier elasticity is not so important, or where server side applications access state-transfer-disabled, replicated Infinispan cache instances are amongst scenarios where Infinispan p2p deployments can be more suited than client-server ones.
+
+[[sid-68355040_InfinispanServerModules-ServerModules]]
+
+
+=== Server Modules
+
+So, now that it's clear when it makes sense to deploy Infinispan in client-server mode, what are available solutions? All Infinispan server modules are based on the same pattern where the server backend creates an embedded Infinispan instance and if you start multiple backends, they can form a cluster and share/distribute state if configured to do so. The server types below primarily differ in the type of listener endpoint used to handle incoming connections. Here's a brief look at each of them:
+
+[[sid-68355040_InfinispanServerModules-RESTServerModule]]
+
+
+==== REST Server Module
+
+
+*  link:$$http://community.jboss.org/docs/14095$$[This module] , which is distributed as a WAR file, can be deployed in any servlet container to allow Infinispan to be accessed via link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737132$$[a RESTful HTTP interface] . 
+
+
+* To connect to it, you can use any HTTP client out there and there're tons of different client implementations available out there for pretty much any language or system.
+
+
+* This module is particularly recommended for those environments where HTTP port is the only access method allowed between clients and servers.
+
+
+*  Clients wanting to load balance or failover between different Infinispan REST servers can do so using any standard HTTP load balancer such as link:$$http://www.jboss.org/mod_cluster$$[mod_cluster] . It's worth noting though these load balancers maintain a static view of the servers in the backend and if a new one was to be added, it would require manual update of the load balancer. 
+
+[[sid-68355040_InfinispanServerModules-MemcachedServerModule]]
+
+
+==== Memcached Server Module
+
+
+*  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737037$$[This module] is an implementation of the link:$$http://github.com/memcached/memcached/blob/master/doc/protocol.txt$$[Memcached text protocol] backed by Infinispan. 
+
+
+*  To connect to it, you can use any of the link:$$http://code.google.com/p/memcached/wiki/Clients$$[existing Memcached clients] which are pretty diverse. 
+
+
+* As opposed to Memcached servers, Infinispan based Memcached servers can actually be clustered and hence they can replicate or distribute data using consistent hash algorithms around the cluster. So, this module is particularly of interest to those users that want to provide failover capabilities to the data stored in Memcached servers.
+
+
+* In terms of load balancing and failover, there're a few clients that can load balance or failover given a static list of server addresses (perl's Cache::Memcached for example) but any server addition or removal would require manual intervention.
+
+[[sid-68355040_InfinispanServerModules-HotRodServerModule]]
+
+
+==== Hot Rod Server Module
+
+
+*  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737146$$[This module] is an implementation of the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=9470083$$[Hot Rod binary protocol] backed by Infinispan which allows clients to do dynamic load balancing and failover and smart routing. 
+
+
+*  So far, a single link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737142$$[Java client] , which is the reference implementation, has been fully developed. A beta version of the Python client is link:$$http://infinispan.blogspot.com/2011/02/infinispan-python-client-beta-for-hot.html$$[available] , and a link:$$https://github.com/noelo/hotrod-jruby$$[JRuby] and link:$$https://github.com/torquebox/infinispan-ruby-client$$[pure Ruby] clients are in the making. 
+
+
+* If you're clients are running Java, this should be your defacto server module choice because it allows for dynamic load balancing and failover. This means that Hot Rod clients can dynamically detect changes in the topology of Hot Rod servers as long as these are clustered, so when new nodes join or leave, clients update their Hot Rod server topology view. On top of that, when Hot Rod servers are configured with distribution, clients can detect where a particular key resides and so they can route requests smartly.
+
+
+* Load balancing and failover is dynamically provided by Hot Rod client implementations using information provided by the server.
+
+[[sid-68355040_InfinispanServerModules-WebSocketServerModule]]
+
+
+==== WebSocket Server Module
+
+
+*  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737036$$[This module] enables Infinispan to be exposed over a link:$$http://en.wikipedia.org/wiki/WebSockets$$[Websocket] interface via a Javascript API. 
+
+
+* This module is very specifically designed for Javascript clients and so that is the only client implementation available.
+
+
+* This module is particularly suited for developers wanting to enable access to Infinispan instances from their Javascript codebase.
+
+
+* Since websockets work on the same HTTP port, any HTTP load balancer would do to load balance and failover.
+
+[[sid-68355040_InfinispanServerModules-ServerComparisonSummary]]
+
+
+=== Server Comparison Summary
+
+Here's a table comparing and summarizing the capabilities of distinct server modules:
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-15-Management_Tooling.adoc b/documentation/src/main/asciidoc/user_guide/chapter-15-Management_Tooling.adoc
new file mode 100644
index 0000000..f49e9b9
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-15-Management_Tooling.adoc
@@ -0,0 +1,358 @@
+[[sid-68355041]]
+
+==  Management Tooling
+
+[[sid-68355041_ManagementTooling-Introduction]]
+
+
+=== Introduction
+
+Management of Infinispan instances is all about exposing as much relevant statistical information that allows administrators to get view of the state of each Infinispan instance. Taking in account that a single installation could be made up of several tens or hundreds Infinispan instances, providing clear and concise information in an efficient manner is imperative. The following sections dive into the range of management tooling that Infinispan provides.
+
+[[sid-68355041_ManagementTooling-JMX]]
+
+
+=== JMX
+
+ Over the years, link:$$http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/$$[JMX] has become the de facto standard for management and administration of middleware and as a result, the Infinispan team has decided to standarize on this technology for the exposure of management or statistical information. 
+
+[[sid-68355041_ManagementTooling-EnablingJMXStatistics]]
+
+
+==== Enabling JMX Statistics
+
+JMX reporting can be enabled at 2 different levels:
+
+1. CacheManager level: The CacheManager is the entity that governs all the cache instances that have been created from it. Details on the information exposed at the CacheManager level can be found below. For the moment, let's just focus on how to enable the CacheManager to report management data via JMX.
+
+
+* If configuring the CacheManager via XML, make sure you add the following XML under the &lt;global&gt; element:
+
+
+----
+<globalJmxStatistics enabled="true"/>
+----
+
+
+* If configuring the CacheManager programmatically, simply add the following code:
+
+
+----
+GlobalConfiguration globalConfiguration = ...
+globalConfiguration.setExposeGlobalJmxStatistics(true);
+
+----
+
+2. Cache level: At this level, you will receive management information generated by individual cache instances. Details on the information exposed at the Cache level are explained below. For the moment, let's just focus on how to enable the Cache to report management data via JMX:
+
+
+* If configuring the Cache via XML, make sure you add the following XML under the either &lt;default&gt;, if you're configuring the default Cache instance, or under the corresponding &lt;namedCache&gt;:
+
+
+----
+<jmxStatistics enabled="true"/>
+----
+
+
+* If configuring the Cache programmatically, simply add the following code:
+
+
+----
+Configuration configuration = ...
+configuration.setExposeJmxStatistics(true);
+
+----
+
+Understanding The MBeans
+
+ Once you have enabled JMX reporting at either the CacheManager or Cache level, you should be able to connect to VM(s) where Infinispan is running using a standard JMX GUI such as link:$$http://java.sun.com/developer/technicalArticles/J2SE/jconsole.html$$[JConsole] or link:$$http://java.sun.com/javase/6/docs/technotes/guides/visualvm/$$[VisualVM] , and you should find the following MBeans: 
+
+[[sid-68355041_ManagementTooling-Infinispan4.1orearlier]]
+
+
+===== Infinispan 4.1 or earlier
+
+
+*  If you enabled CacheManager level JMX statistics, you should see an MBean called infinispan:cache-name=[global],jmx-resource=CacheManager with link:$$http://docs.jboss.org/infinispan/4.0/apidocs/jmxComponents.html#CacheManager$$[properties specified by the CacheManager MBean] . 
+
+
+* If you enabled Cache level JMX statistics, you should see several different MBeans depending on which configuration options have been enabled. For example, if you have configured a write behind cache store, you should see an MBean exposing properties belonging to the cache store component. All Cache level MBeans will follow the same format though which is the following: infinispan:cache-name=&lt;name-of-cache&gt;(&lt;cache-mode&gt;),jmx-resource=&lt;component-name&gt; where: 
+
+
+* &lt;name-of-cache&gt; has been substituted by the actual cache name. If this cache represents the default cache, its name will be "___defaultcache".
+
+
+*  &lt;cache mode&gt; has been substituted by the cache mode of the cache. The cache mode is represented by the lower case version of the possible enumeration values shown link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/config/Configuration.CacheMode.html$$[here] . 
+
+
+*  &lt;component-name&gt; has been substituted by one of the JMX component names in the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/jmxComponents.html$$[JMX reference documentation] . 
+
+For example, the cache store JMX component MBean for a default cache configured with synchronous distribution would have the following name:infinispan:cache-name=___defaultcache(dist_sync),jmx-resource=CacheStore
+
+Please note that any cache names that contain ':' or '=' characters will be substituted by '_' character. Infinispan does this because ':' and '=' are control characters for JMX object names.
+
+[[sid-68355041_ManagementTooling-Infinispan4.2orlater]]
+
+
+===== Infinispan 4.2 or later
+
+
+*  If you enabled CacheManager level JMX statistics, without further configuration, you should see an MBean called _org.infinispan:type=CacheManager,name="DefaultCacheManager"_ with link:$$http://docs.jboss.org/infinispan/4.2/apidocs/jmxComponents.html#CacheManager$$[properties specified by the CacheManager MBean] . 
+
+
+*  Using the cacheManagerName attribute in globalJmxStatistics XML element, or using the corresponding GlobalConfiguration.setCacheManagerName() call, you can name the cache manager in such way that the name is used as part of the JMX object name. So, if the name had been "Hibernate2LC", the JMX name for the cache manager would have been: _org.infinispan:type=CacheManager,name="Hibernate2LC"_ . This offers a nice and clean way to manage environments where multiple cache managers are deployed, which follows link:$$http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/best-practices.jsp$$[JMX best practices] . 
+
+
+*  If you enabled Cache level JMX statistics, you should see several different MBeans depending on which configuration options have been enabled. For example, if you have configured a write behind cache store, you should see an MBean exposing properties belonging to the cache store component. All Cache level MBeans follow the same format though which is the following: _org.infinispan:type=Cache,name="&lt;name-of-cache&gt;(&lt;cache-mode&gt;)",manager="&lt;name-of-cache-manager&gt;",component=&lt;component-name&gt;_ where: 
+
+
+*  &lt;name-of-cache&gt; has been substituted by the actual cache name. If this cache represents the default cache, it's name will be _"_ _ _defaultCache"_ . 
+
+
+* &lt;cache-mode&gt; has been substituted by the cache mode of the cache. The cache mode is represented by the lower case version of the possible enumeration values shown here.
+
+
+* &lt;name-of-cache-manager&gt; has been substituted by the name of the cache manager to which this cache belongs. The name is derived from the cacheManagerName attribute value in globalJmxStatistics element.
+
+
+*  &lt;component-name&gt; has been substituted by one of the JMX component names in the link:$$http://docs.jboss.org/infinispan/4.2/apidocs/jmxComponents.html$$[JMX reference documentation] . 
+
+ For example, the cache store JMX component MBean for a default cache configured with synchronous distribution would have the following name: _org.infinispan:type=Cache,name="_ _ _$$defaultcache(dist_sync)", manager="DefaultCacheManager",component=CacheStore$$_ 
+
+Please note that cache and cache manager names are quoted to protect against illegal characters being used in these user-defined names.
+
+[[sid-68355041_ManagementTooling-MultipleJMXDomains]]
+
+
+==== Multiple JMX Domains
+
+There can be situations where several CacheManager instances are created in a single VM, or Cache names belonging to different CacheManagers under the same VM clash.
+
+[[sid-68355041_ManagementTooling-Infinispan4.1orearlierx]]
+
+
+===== Infinispan 4.1 or earlier
+
+In order to cope with such situations, Infinispan enabled users to define a particular JMX domain prefix for their MBeans. For example, either of these two options could be used to configure a JMX domain prefix called "myInfinispan" for the CacheManager JMX statistics:
+
+
+* Via XML:
+
+
+----
+<globalJmxStatistics enabled="true" jmxDomain="myInfinispan"/>
+----
+
+
+* Programmatically:
+
+
+----
+GlobalConfiguration globalConfiguration = ...
+globalConfiguration.setExposeGlobalJmxStatistics(true);
+globalConfiguration.setJmxDomain("myInfinispan");
+
+----
+
+ Using either of these options should result on the CacheManager MBean name being: _myInfinispan:cache-name=[global],jmx-resource=CacheManager_ 
+
+ As you probably have guessed by now, the default JMX domain prefix is called " _infinispan_ ". 
+
+ Another related configuration option for both CacheManager and Cache JMX statistics allows for duplicate JMX domains to be discovered. Internally, when duplicates are allowed, Infinispan takes the duplicating JMX domain prefix, adds an index that starts at number 2 to the existing prefix and uses that JMX prefix from then onwards. So, for example, if two CacheManagers were started with global JMX statistics enabled, no particular JMX domain was configured, and JMX domain duplicates were allowed, the first CacheManager would be registered under " _infinispan..._ ", whereas the second one would be registered under: " _infinispan2..._ ". To allow JMX duplicate domains, do the following: 
+
+
+* Via XML:
+
+
+----
+<globalJmxStatistics enabled="true" allowDuplicateDomains="true"/>
+----
+
+
+* Programmatically:
+
+
+----
+GlobalConfiguration globalConfiguration = ...
+globalConfiguration.setExposeGlobalJmxStatistics(true);
+globalConfiguration.setAllowDuplicateDomains(true)
+
+----
+
+Remember that by default, duplicate domains are disallowed.
+
+[[sid-68355041_ManagementTooling-Infinispan4.2orlaterx]]
+
+
+===== Infinispan 4.2 or later
+
+Using different JMX domains for multi cache manager environments should be last resort. Instead, as mentioned in previous section, it's now possible to name a cache manager in such way that it can easily be identified and used by monitoring tools such as RHQ. For example:
+
+
+* Via XML:
+
+
+----
+<globalJmxStatistics enabled="true" cacheManagerName="Hibernate2LC"/>
+----
+
+
+* Programmatically:
+
+
+----
+GlobalConfiguration globalConfiguration = ...
+globalConfiguration.setExposeGlobalJmxStatistics(true);
+globalConfiguration.setCacheManagerName("Hibernate2LC");
+
+----
+
+Using either of these options should result on the CacheManager MBean name being: org.infinispan:type=CacheManager,name="Hibernate2LC"
+
+ Please note as well that since 4.2, the default domain names has changed from "infinispan" to "org.infinispan", as per link:$$http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/best-practices.jsp$$[JMX best practices] . 
+
+For the time being, you can still set your own jmxDomain if you need to and we also allow duplicate domains, or rather duplicate JMX names, but these should be limited to very special cases where different cache managers within the same JVM are named equally.
+
+[[sid-68355041_ManagementTooling-RegisteringMBeansInNonDefaultMBeanServers]]
+
+
+==== Registering MBeans In Non-Default MBean Servers
+
+ To finish up with this JMX section, let's quickly discuss where Infinispan registers all these MBeans. By default, Infinispan registers them in the link:$$http://java.sun.com/j2se/1.5.0/docs/api/java/lang/management/ManagementFactory.html#getPlatformMBeanServer()$$[standard JVM MBeanServer plattform] . However, users might want to register these MBeans in a different MBeanServer instance. For example, an application server might work with a different MBeanServer instance to the default plattform one. In such cases, users should implement the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/jmx/MBeanServerLookup.html$$[MBeanServerLookup interface] provided by Infinispan so that the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/jmx/MBeanServerLookup.html#getMBeanServer()$$[getMBeanServer() method] returns the MBeanServer under which Infinispan should register the management MBeans. You can find an example in the default link:$$http://anonsvn.jboss.org/repos/infinispan/tags/4.0.0.FINAL/core/src/main/java/org/infinispan/jmx/PlatformMBeanServerLookup.java$$[PlatformMBeanServerLookup class] used by Infinispan. So, once you have your implementation ready, simply configure Infinispan with the fully qualified name of this class. For example: 
+
+
+* Via XML:
+
+
+----
+<globalJmxStatistics enabled="true" mBeanServerLookup="com.acme.MyMBeanServerLookup"/>
+----
+
+
+* Programmatically:
+
+
+----
+GlobalConfiguration globalConfiguration = ...
+globalConfiguration.setExposeGlobalJmxStatistics(true);
+globalConfiguration.setMBeanServerLookup("com.acme.MyMBeanServerLookup")
+
+----
+
+MBean additions in Infinispan 5.0
+
+There has been a couple of noticeable additions in Infinispan 5.0 in terms of MBean exposed:
+
+
+.  MBeans related to Infinispan servers are now available that for the moment focus on the transport layer. So, if the Infinispan servers are configured with global JMX statistics, a brand new MBean in _org.infinispan:type=Server,name=&lt;Memcached|Hotrod&gt;,component=Transport_ is now available which offers information such as: host name, port, bytes read, byte written, number of worker threads...etc. 
+
+
+.  When global JMX statistics are enabled, JGroups MBeans are also registered automatically, so you can get key information of the group communication transport layer that's used to cluster Infinispan instances. To find out more about the information provided, check the link:$$http://community.jboss.org/docs/10938$$[JGroups JMX documentation] . 
+
+[[sid-68355041_ManagementTooling-RHQ]]
+
+
+=== RHQ
+
+The preferred way to manage multiple Infinispan instances spread accross different servers is to use RHQ, which is JBoss' enterprise management solution. Thanks to RHQ's agent and auto discovery capabilities, monitoring both Cache Manager and Cache instances is a very simple task. With RHQ, administrators have access to graphical views of key runtime parameters or statistics and can also be notified be these exceed or go below certain limits. The Infinispan specific statistics shown by RHQ are a reflection of the JMX information exposed by Infinispan which has been formatted for consumption by RHQ. Please follow these steps to get started with RHQ and have Infinispan instances monitored with it:
+
+
+.  Firstly, download and install an RHQ server and install and start at least one RHQ agent. The job of the RHQ agent is to send information about the Infinispan instance back to the server which is the one that shows the information via a nice GUI. You can find detailed information on the installation process in link:$$http://support.rhq-project.org/display/JOPR2/Installation$$[RHQ's installation guide] and you can find information on how to run an agent in the link:$$http://support.rhq-project.org/display/JOPR2/Running+the+RHQ+Agent$$[RHQ agent guide] . 
+
+
+[NOTE]
+.Careful with H2 database installation
+==== 
+ If you're just building a demo or testing RHQ server, you can avoid the need to install a fully fledged database and use an in-memory H2 database instead. However, you might encounter issues after testing database connection as shown link:$$https://fedorahosted.org/pipermail/rhq-users/2010-June/000045.html$$[here] . Simply repeating the installation avoiding testing the connection should work. 
+
+
+==== 
+
+
+
+[TIP]
+.Where do I install the RHQ agent?
+==== 
+The most common set up is to have the RHQ agent installed in the same machine where Infinispan is running. If you have multiple machines, an agent can be installed in each machine.
+
+
+==== 
+
+
+
+.  By now, you should have an RHQ server and agent running. It's time now to download the latest Infinispan binary distribution (*-bin.zip or *-all.zip should do) from the link:$$http://www.jboss.org/infinispan/downloads.html$$[downloads] section and locate the RHQ plugin jar file which should be named something like infinispan-rhq-plugin.jar . This is located under the modules/rhq-plugin directory. 
+
+
+.  The link:$$http://rhq-project.org/display/JOPR2/Adding+and+Updating+Agent+Plugins$$[adding and updating plugins section] on the RHQ guide contains some more detailed information on how to update both RHQ servers and agents with new plugins, but essentially, this process involves uploading a new plugin to the RHQ server and then pushing the plugin to one, or several, RHQ agents. 
+
+
+[TIP]
+.Speeding up plugin installation
+==== 
+ If you're simply demoing or testing and you only have a single agent, once the plugin has been uploaded to the server, simply go to the agent command line interface and type: plugins update .This will force the agent to retrieve the latest plugins from the server. Doing this can be considerably faster than some of the other alternatives. 
+
+
+==== 
+
+
+
+. At this point, RHQ is ready to start monitoring Infinispan instances, but before firing them up, make sure you start them with the following system properties so that RHQ agents can discover them:
+
+
+----
+-Dcom.sun.management.jmxremote.port=6996 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false
+----
+
+
+[TIP]
+.Remote JMX port value
+==== 
+The actual port value used does not really matter here, but what matters is that a port is given, otherwise Infinispan instances cannot be located. So, you can easily start multiple Infinispan instances in a single machine, each with a different remote JMX port, and a locally running agent will be able to discover them all without any problems.
+
+
+==== 
+
+
+
+.  Once Infinispan instances have been discovered, you should see a new resource for each of the cache manager running appearing in the link:$$http://rhq-project.org/display/JOPR2/Initial+Auto-discovery+and+Import$$[Inventory/Discovery Queue] of the RHQ server. Simply import it now and you should see each cache manager appearing with as many child cache resources as caches are running in each cache manager. You're now ready to monitor Infinispan! 
+
+[[sid-68355041_ManagementTooling-RHQmonitoringtips]]
+
+
+==== RHQ monitoring tips
+
+This section focuses on the lessons learned while developing the Infinispan RHQ plugin that are likely to be useful to anyone using RHQ.
+
+
+* By default, at least in version 2.3.1 of RHQ, the RHQ agent sends an availability report of any managed resources every 5 minutes. The problem with this is that if you're testing whether your Infinispan instance is automatically discovered by the RHQ server, it can take up to 5 minutes to do so! Also, it can take 5 minutes for the RHQ server to figure out that you've shutdown your Infinispan instance. You can change this setting by the following property (default value is 300 seconds) in rhq-agent/conf/agent-configuration.xml. For example, if you wanted the availability to be sent every 1 minute, simply change the value to 60:
+
+
+----
+<entry key="rhq.agent.plugins.availability-scan.period-secs" value="60"/>
+----
+
+
+[NOTE]
+.Careful with agent configuration changes
+==== 
+ Please bear in mind the instructions given in the link:$$http://support.rhq-project.org/display/JOPR2/RHQ+Agent+Installation$$[RHQ agent installation] and more specifically the paragraph below with regards to changes made to properties in agent-configuration.xml: 
+
+[quote]
+____
+Once the agent is configured, it persists its configuration in the Java Preferences backing store. Once this happens, agent-configuration.xml is no longer needed or used. Editing agent-configuration.xml will no longer have any effect on the agent, even if you restart the agent. If you want the agent to pick up changes you make to agent-configuration.xml, you must either restart the agent with the "--cleanconfig" command line option or use the "config --import" agent prompt command.
+
+
+____
+
+
+
+==== 
+
+
+[[sid-68355041_ManagementTooling-Writingpluginsforothermanagementtools]]
+
+
+=== Writing plugins for other management tools
+
+As mentioned in the previous section, RHQ consumes the JMX data exposed by Infinispan, and in similar fashion, plugins could be written for other 3rd party management tools that were able to transform these data into the correct representation in these tools, for example graphs,...etc.
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-16-Asynchronous_Options.adoc b/documentation/src/main/asciidoc/user_guide/chapter-16-Asynchronous_Options.adoc
new file mode 100644
index 0000000..86e0fe9
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-16-Asynchronous_Options.adoc
@@ -0,0 +1,80 @@
+[[sid-68355043]]
+
+==  Asynchronous Options
+
+[[sid-68355043_AsynchronousOptions-Introduction]]
+
+
+=== Introduction
+
+ When Infinispan instances are clustered, regardless of the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737115$$[clustering mode] , data can be propagated to other nodes in a synchronous or asynchronous way. When synchronous, the sender waits for replies from the receivers and when asynchronous, the sender sends the data and does not wait for replies from other nodes in the cluster. 
+
+With asynchronous modes, speed is more important than consistency and this is particularly advantageous in use cases such as HTTP session replication with sticky sessions enabled. In these scenarios, data, or in this case a particular session, is always accessed on the same cluster node and only in case of failure is data accessed in a different node. This type of architectures allow consistency to be relaxed in favour of increased performance.
+
+In order to choose the asynchronous configuration that best suits your application, it's important to understand the following configuration settings:
+
+[[sid-68355043_AsynchronousOptions-AsynchronousCommunications]]
+
+
+=== Asynchronous Communications
+
+ Whenever you add link:$$http://docs.jboss.org/infinispan/5.1/configdocs/urn_infinispan_config_5.1/complexType/configuration.clustering.async.html$$[&lt;async&gt;] element within &lt;clustering&gt;, you're telling the underlying JGroups layer in Infinispan to use asynchronous communication. What this means is that JGroups will send any replication/distribution/invalidation request to the wire but will not wait for a reply from the receiver. 
+
+[[sid-68355043_AsynchronousOptions-AsynchronousMarshalling]]
+
+
+=== Asynchronous Marshalling
+
+ This is a configurable boolean property of link:$$http://docs.jboss.org/infinispan/5.1/configdocs/urn_infinispan_config_5.1/complexType/configuration.clustering.async.html$$[&lt;async&gt;] element that indicates whether the actual call from Infinispan to the JGroups layer is done on a separate thread or not. When set to true, once Infinispan has figured out that a request needs to be sent to another node, it submits it to the async transport executor so that it can talk to the underlying JGroups layer. 
+
+With asynchronous marshalling, Infinispan requests can return back to the client quicker compared to when async marshalling is set to false. The downside though is that client requests can be reordered before they have reached the JGroups layer. In other words, JGroups provides ordering guarantees even for async messages but with async marshalling turned on, requests can reach the JGroups in a different order in which they're called. This can effectively lead to data consistency issues in applications making multiple modifications on the same key/value pair. For example, with async marshalling turned on:
+
+App calls:
+
+
+----
+cache.put("car", "bmw");
+cache.remove("car");
+
+----
+
+Other nodes could receive these operations in this order:
+
+
+----
+cache.remove("car");
+cache.put("car", "bmw");
+
+----
+
+ The end result is clearly different which is often not desirable. So, if your application makes multiple modifications on the same key, you should either: turned off asynchronous marshalling, or set link:$$http://docs.jboss.org/infinispan/4.1/apidocs/config.html#ce_global_asyncTransportExecutor$$[&lt;asyncTransportExecutor&gt;] element's maxThreads to 1. The first modification only applies to a particular named cache, whereas the second option affects all named caches in configuration file that are configured with async marshalling. It's worth noting though that having this type of executor configured with a single thread would defeat its purpose adding unnecessary contention point. It'd be better to simply switch off async marshalling. 
+
+On the contrary, if your application only ever makes one modification per key/value pair and there's no happens-before relationship between them, then async marshalling is a very valid optimization that can increase performance of your application without data consistency risks.
+
+ If you have async marshalling turned on and see exceptions related to java.util.concurrent.RejectedExecutionException , as explained in the <<sid-68354942,technical faq page>> , you should also consider switching off async marshalling. 
+
+ Back in Infinispan 4.0, when &lt;async&gt; element was used, this property was set to true by default. However due to reordering risks mentioned earlier, the default has changed to false from Infinispan 4.1 onwards. 
+
+[[sid-68355043_AsynchronousOptions-ReplicationQueue]]
+
+
+=== Replication Queue
+
+The aim of the replication queue is to batch the individual cache operations and send them as one, as opposed to sending each cache operation individually. As a result, replication queue enabled configurations perform generally better compared to those that have it switched off because less RPC messages are sent, fewer envelopes are used...etc. The only real trade off to the replication queue is that the queue is flushed periodically (based on time or queue size) and hence it might take longer for the replication/distribution/invalidation to be realised across the cluster. When replication queue is turned off, data is placed directly on the wire and hence it takes less for data to arrive to other nodes.
+
+Until Infinispan 4.1.0.CR2, replication queue always flushed data with async marshalling turned on, which meant that there was a small gap where flush calls could be reordered. Since 4.1.0.CR3, async marshalling configuration is taken into account, and decides whether the flush calls goes directly to the JGroups layer, or whether an intermediate handing over to a different thread occurs. The advantages of using async marshalling with replication queue are less than clear because replication queue itself already makes client requests return faster, so it's generally recommended to have async marshalling turned off, or &lt;asyncTransportExecutor&gt; element's maxThreads set to 1, when replication queue is turned on.
+
+[[sid-68355043_AsynchronousOptions-AsynchronousAPI]]
+
+
+=== Asynchronous API
+
+ Finally, the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737045$$[asynchronous API] can be used to emulate non-blocking APIs, whereby calls are handed over to a different thread and asynchronous API calls return to the client immediately. Similar to async marshalling, using this API can lead to reordering, so you should avoid calling modifying asynchronous methods on the same keys. 
+
+[[sid-68355043_AsynchronousOptions-ReturnValues]]
+
+
+=== Return Values
+
+ Regardless of the asynchronous option used, the return values of cache operations are reliable. If talking about return values of cache operations that return previous value, the correctness of these returns are guaranteed as well regardless of the clustering mode. With replication, the previous value is already available locally, and with distribution, regardless of whether it's asynchronous or synchronous, Infinispan sends a synchronous request to get the previous value if not present locally. If on the other hand the asynchronous API is used, client code needs to get hold of the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/util/concurrent/NotifyingFuture.html$$[NotifiyngFuture] returned by the async operation in order to be able to query the previous value. 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-17-Infinispan_as_Hibernate_2nd_Level_Cache_in_JBoss_AS_5_x.adoc b/documentation/src/main/asciidoc/user_guide/chapter-17-Infinispan_as_Hibernate_2nd_Level_Cache_in_JBoss_AS_5_x.adoc
new file mode 100644
index 0000000..add0d2e
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-17-Infinispan_as_Hibernate_2nd_Level_Cache_in_JBoss_AS_5_x.adoc
@@ -0,0 +1,54 @@
+[[sid-68355044]]
+
+==  Infinispan as Hibernate 2nd-Level Cache in JBoss AS 5.x
+
+A JBoss AS 5.x application can be configured to use Infinispan 4.x as the Hibernate 2nd-level cache, replacing JBoss Cache.
+
+
+. Add the attached jar files to the ear lib directory. These include the core 4.1.0.GA Infinispan jar (infinispan-core.jar), the Hibernate/Infinispan integration jar back-ported from Hibernate 3.5 (hibernate-infinispan-3.3.2.GA_CP03.jar), the JGroups jar required by Infinispan 4.1.0 (jgroups-2.10.0.GA.jar), and other required 3rd party jars (river-1.2.3.GA.jar, marshalling-api-1.2.3.GA.jar)
+
+
+. Isolate the classloading to be ear-scoped by adding META-INF/jboss-classloading.xml
+
+
+. 
+----
+<classloading xmlns="urn:jboss:classloading:1.0" domain="simple-scoped" parent-first="false" />
+----
+
+
+. Configure persistence.xml to use Infinispan instead of JBoss Cache:
+
+
+----
+<?xml version="1.0" encoding="UTF-8"?>
+<persistence xmlns="http://java.sun.com/xml/ns/persistence"
+   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+   xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"
+   version="1.0">
+<persistence-unit name="jpa-test">
+    <jta-data-source>java:/PostgresDS</jta-data-source>
+        <properties>
+            <property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect" />
+
+            <property name="hibernate.session_factory_name" value="SessionFactories/infinispan" />
+
+            <property name="hibernate.cache.use_query_cache" value="true" />
+            <property name="hibernate.cache.use_second_level_cache" value="true" />
+            <property name="hibernate.generate_statistics" value="true" />
+            <property name="hibernate.cache.use_structured_entries" value="true" />
+
+            <property name="hibernate.cache.region_prefix" value="infinispan" />
+
+            <property name="hibernate.show_sql" value="true" />
+
+            <property name="hibernate.hbm2ddl.auto" value="validate" />
+            
+            <!-- Infinispan second level cache configuration -->
+            <property name="hibernate.cache.region.factory_class" value="org.hibernate.cache.infinispan.InfinispanRegionFactory" />
+        </properties>
+    </persistence-unit>
+</persistence>
+
+----
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-18-Clustered_Configuration_QuickStart.adoc b/documentation/src/main/asciidoc/user_guide/chapter-18-Clustered_Configuration_QuickStart.adoc
new file mode 100644
index 0000000..e02390d
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-18-Clustered_Configuration_QuickStart.adoc
@@ -0,0 +1,130 @@
+[[sid-68355047]]
+
+==  Clustered Configuration QuickStart
+
+ Infinispan ships with _pre-configured_ JGroups stacks that make it easy for you to jump-start a clustered configuration. 
+
+[[sid-68355047_ClusteredConfigurationQuickStart-UsinganexternalJGroupsfile]]
+
+
+=== Using an external JGroups file
+
+ If you are configuring your cache programmatically, all you need to do is: 
+
+
+----
+// ...
+GlobalConfiguration gc = new GlobalConfigurationBuilder().transport().addProperty("configurationFile", "jgroups.xml").build();
+// ...
+
+----
+
+ and if you happen to use an XML file to configure Infinispan, just use: 
+
+
+----
+<infinispan>
+  <global>
+    <transport>
+      <properties>
+        <property name="configurationFile" value="jgroups.xml" />
+      </properties>
+    </transport>
+  </global>
+
+  ...
+
+</infinispan>
+
+----
+
+ In both cases above, Infinispan looks for _jgroups.xml_ first in your classpath, and then for an absolute path name if not found in the classpath. 
+
+[[sid-68355047_ClusteredConfigurationQuickStart-UseoneofthepreconfiguredJGroupsfiles]]
+
+
+=== Use one of the pre-configured JGroups files
+
+Infinispan ships with a few different JGroups files (packaged in infinispan-core.jar) which means they will already be on your classpath by default.  All you need to do is specify the file name, e.g., instead of jgroups.xml above, specify jgroups-tcp.xml.
+
+The configurations available are:
+
+
+*  jgroups-udp.xml - Uses UDP as a transport, and UDP multicast for discovery.  Usually suitable for larger (over 100 nodes) clusters _or_ if you are using link:$$http://community.jboss.org/docs/DOC-14853#replicated$$[replication or invalidation] .  Minimises opening too many sockets. 
+
+
+*  jgroups-tcp.xml - Uses TCP as a transport and UDP multicast for discovery.  Better for smaller clusters (under 100 nodes) _only if_ you are using link:$$http://community.jboss.org/docs/DOC-14853#distribution$$[distribution] , as TCP is more efficient as a point-to-point protocol 
+
+
+*  jgroups-ec2.xml - Uses TCP as a transport and link:$$http://community.jboss.org/docs/DOC-15925$$[S3_PING] for discovery.  Suitable on link:$$http://$$[Amazon EC2] nodes where UDP multicast isn't available. 
+
+[[sid-68355047_ClusteredConfigurationQuickStart-FinetuningJGroupssettings]]
+
+
+==== tuning JGroups settings
+
+The settings above can be further tuned without editing the XML files themselves.  Passing in certain system properties to your JVM at startup can affect the behaviour of some of these settings.  The table below shows you which settings can be configured in this way.  E.g.,
+
+
+----
+$ java -cp ... -Djgroups.tcp.port=1234 -Djgroups.tcp.address=10.11.12.13
+----
+
+[[sid-68355047_ClusteredConfigurationQuickStart-jgroupsudp.xml]]
+
+
+===== jgroups-udp.xml
+
+
+|===============
+| _System Property_ | _Description_ | _Default_ | _Required?_ 
+|jgroups.udp.mcast_addr| IP address to use for multicast (both for communications and discovery).  Must be a valid link:$$http://compnetworking.about.com/od/workingwithipaddresses/l/aa042400b.htm$$[Class D] IP address, suitable for IP multicast. |228.6.7.8|No
+|jgroups.udp.mcast_port|Port to use for multicast socket|46655|No
+|jgroups.udp.ip_ttl|Specifies the time-to-live (TTL) for IP multicast packets. The value here refers to the number of network hops a packet is allowed to make before it is dropped|2|No
+
+|===============
+
+
+[[sid-68355047_ClusteredConfigurationQuickStart-jgroupstcp.xml]]
+
+
+===== jgroups-tcp.xml
+
+
+|===============
+| _System Property_ | _Description_ | _Default_ | _Required?_ 
+|jgroups.tcp.address|IP address to use for the TCP transport.|127.0.0.1|No
+|jgroups.tcp.port|Port to use for TCP socket|7800|No
+|jgroups.udp.mcast_addr| IP address to use for multicast (for discovery).  Must be a valid link:$$http://compnetworking.about.com/od/workingwithipaddresses/l/aa042400b.htm$$[Class D] IP address, suitable for IP multicast. |228.6.7.8|No
+|jgroups.udp.mcast_port|Port to use for multicast socket|46655|No
+|jgroups.udp.ip_ttl|Specifies the time-to-live (TTL) for IP multicast packets. The value here refers to the number of network hops a packet is allowed to make before it is dropped|2|No
+
+|===============
+
+
+[[sid-68355047_ClusteredConfigurationQuickStart-jgroupsec2.xml]]
+
+
+===== jgroups-ec2.xml
+
+
+|===============
+| _System Property_ | _Description_ | _Default_ | _Required?_ 
+|jgroups.tcp.address|IP address to use for the TCP transport.|127.0.0.1|No
+|jgroups.tcp.port|Port to use for TCP socket|7800|No
+|jgroups.s3.access_key|The Amazon S3 access key used to access an S3 bucket| |No
+|jgroups.s3.secret_access_key|The Amazon S3 secret key used to access an S3 bucket| |No
+|jgroups.s3.bucket|Name of the Amazon S3 bucket to use.  Must be unique and must already exist| |No
+
+|===============
+
+
+[[sid-68355047_ClusteredConfigurationQuickStart-Furtherreading]]
+
+
+=== Further reading
+
+ JGroups also supports more system property overrides, details of which can be found on this page: link:$$http://community.jboss.org/docs/12352$$[SystemProps] 
+
+ In addition, the JGroups configuration files shipped with Infinispan are intended as a jumping off point to getting something up and running, and working.  More often than not though, you will want to fine-tune your JGroups stack further to extract every ounce of performance from your network equipment.  For this, your next stop should be the JGroups manual which has a link:$$http://jgroups.org/manual/html/protlist.html$$[detailed section] on configuring each of the protocols you see in a JGroups configuration file. 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-19-Locking_and_Concurrency.adoc b/documentation/src/main/asciidoc/user_guide/chapter-19-Locking_and_Concurrency.adoc
new file mode 100644
index 0000000..7da31cf
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-19-Locking_and_Concurrency.adoc
@@ -0,0 +1,240 @@
+[[sid-68355049]]
+
+==  Locking and Concurrency
+
+ Infinispan makes use of multi-versioned concurrency control ( link:$$http://en.wikipedia.org/wiki/Multiversion_concurrency_control$$[MVCC] ) - a concurrency scheme popular with relational databases and other data stores. MVCC offers many advantages over coarse-grained Java synchronization and even JDK Locks for access to shared data, including: 
+
+
+* allowing concurrent readers and writers
+
+
+* readers and writers do not block one another
+
+
+* write skews can be detected and handled
+
+
+* internal locks can be striped
+
+The rest of this wiki page is broken down into the following sections:
+
+[[sid-68355049_LockingandConcurrency-MVCCimplementationdetails]]
+
+
+=== MVCC implementation details
+
+ Infinispan's MVCC implementation makes use of minimal locks and synchronizations, leaning heavily towards lock-free techniques such as link:$$http://en.wikipedia.org/wiki/Compare-and-swap$$[compare-and-swap] and lock-free data structures wherever possible, which helps optimize for multi-CPU and multi-core environments. 
+
+In particular, Infinispan's MVCC implementation is heavily optimized for readers.  Reader threads do not acquire explicit locks for entries, and instead directly read the entry in question.
+
+ Writers, on the other hand, need to acquire a write lock.  This ensures only one concurrent writer per entry, causing concurrent writers to queue up to change an entry.  To allow concurrent reads, writers make a copy of the entry they intend to modify, by wrapping the entry in a link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/container/entries/MVCCEntry.html$$[MVCCEntry] .  This copy isolates concurrent readers from seeing partially modified state.  Once a write has completed, MVCCEntry.commit() will flush changes to the data container and subsequent readers will see the changes written. 
+
+[[sid-68355049_LockingandConcurrency-Isolationlevels]]
+
+
+=== Isolation levels
+
+ Infinispan offers two isolation levels - link:$$http://en.wikipedia.org/wiki/Isolation_level#READ_COMMITTED$$[READ_COMMITTED] (the default) and link:$$http://en.wikipedia.org/wiki/Isolation_level#REPEATABLE_READ$$[REPEATABLE_READ] , configurable via the link:$$http://docs.jboss.org/infinispan/5.1/configdocs/urn_infinispan_config_5.1/complexType/configuration.locking.html$$[&lt;locking /&gt;] configuration element.  These isolation levels determine when readers see a concurrent write, and are implemented using different subclasses of link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/container/entries/MVCCEntry.html$$[MVCCEntry] , which have different behaviour in how state is committed back to the data container. 
+
+Here's a more detailed example that should help understand the difference between READ_COMMITTED and REPEATABLE_READ in the context of Infinispan. With read committed, if between two consecutive read calls on the same key, the key has been updated by another transaction, the second read will return the new updated value:
+
+
+. Thread1: tx.begin()
+
+
+. Thread1: cache.get(k) returns v
+
+
+. Thread2: tx.begin()
+
+
+. Thread2: cache.get(k) returns v
+
+
+. Thread2: cache.put(k, v2)
+
+
+. Thread2: tx.commit()
+
+
+. Thread1: cache.get(k) returns v2!
+
+With REPEATABLE_READ, step 7 will still return v. So, if you're gonna retrieve the same key multiple times within a transaction, you should use REPEATABLE_READ.
+
+[[sid-68355049_LockingandConcurrency-TheLockManager]]
+
+
+=== The LockManager
+
+The LockManager is a component that is responsible for locking an entry for writing.  The LockManager makes use of a LockContainer to locate/hold/create locks.  LockContainers come in two broad flavours, with support for lock striping and with support for one lock per entry.
+
+[[sid-68355049_LockingandConcurrency-Lockstriping]]
+
+
+=== Lock striping
+
+Lock striping entails the use of a fixed-size, shared collection of locks for the entire cache, with locks being allocated to entries based on the entry's key's hash code.  Similar to the way the JDK's ConcurrentHashMap allocates locks, this allows for a highly scalable, fixed-overhead locking mechanism in exchange for potentially unrelated entries being blocked by the same lock.
+
+ The alternative is to disable lock striping - which would mean a _new_ lock is created per entry.  This approach _may_ give you greater concurrent throughput, but it will be at the cost of additional memory usage, garbage collection churn, etc. 
+
+
+[IMPORTANT]
+.Default lock stripping settings
+==== 
+Since Infinispan 5.0, lock striping is disabled by default, due to potential deadlocks that can happen if locks for different keys end up in the same lock stripe. Previously, in Infinispan 4.x lock striping used to be enabled by default.
+
+
+==== 
+
+
+ The size of the shared lock collection used by lock striping can be tuned using the concurrencyLevel attribute of the link:$$http://docs.jboss.org/infinispan/5.1/configdocs/urn_infinispan_config_5.1/complexType/configuration.locking.html$$[&lt;locking /&gt;] configuration element. 
+
+[[sid-68355049_LockingandConcurrency-Concurrencylevels]]
+
+
+=== Concurrency levels
+
+In addition to determining the size of the striped lock container, this concurreny level is also used to tune any JDK ConcurrentHashMap based collections where related, such as internal to DataContainers.  Please refer to the JDK ConcurrentHashMap Javadocs for a detailed discussion of concurrency levels, as this parameter is used in exactly the same way in Infinispan.
+
+[[sid-68355049_LockingandConcurrency-Explicitandimplicitdistributedeagerlocking]]
+
+
+=== Explicit and implicit distributed eager locking
+
+Infinispan, by default, acquires remote locks lazily.  Locks are acquired locally on a node that runs a transaction while other cluster nodes attempt to lock cache keys involved in a transaction during two-phase prepare/commit phase. However, if desired, Infinispan can eagerly lock cache keys either explicitly or implicitly.
+
+Infinispan cache interface exposes lock API that allows cache users to explicitly lock set of cache keys eagerly during a transaction. Lock call attempts to lock specified cache keys across all cluster nodes and it either succeeds or fails. All locks are released during commit or rollback phase.
+
+ Consider a transaction running on one of the cache nodes: 
+
+
+----
+tx.begin()
+cache.lock(K)    // acquire cluster wide lock on K
+cache.put(K,V5)  // guaranteed to succeed
+tx.commit()      // releases locks
+
+----
+
+Implicit locking goes one step ahead and locks cache keys behind the scene as keys are accessed for modification operations.
+
+ Consider a transaction running on one of the cache nodes: 
+
+
+----
+tx.begin()
+cache.put(K,V)    // acquire cluster wide lock on K
+cache.put(K2,V2)  // acquire cluster wide lock on K2
+cache.put(K,V5)   // no-op, we already own cluster wide lock for K
+tx.commit()       // releases locks
+
+----
+
+Implicit eager locking locks cache keys across cluster nodes only if it is necessary to do so. In a nutshell, if implicit eager locking is turned on then for each modification Infinispan checks if cache key is locked locally. If it is then a global cluster wide lock has already been obtained, otherwise a cluster wide lock request is sent and lock is acquired.
+
+Implicit eager locking is enabled as follows:
+
+
+----
+<transaction useEagerLocking="true" />
+----
+
+[[sid-68355049_LockingandConcurrency-Lockingasingleremotenode]]
+
+
+=== Locking a single remote node
+
+Starting with 4.2, Infinispan allows eagerLockSingleNode configuration option. This only applies for DIST modes. Having this enabled would make the number of remote locks acquired to be always 1, disregarding the configured numOwners. Following diagrams are intended to explain better this option. All diagrams represent an cluster having 5 nodes, with numOwners=2.
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+Above diagram shows the situation where eagerLockSingleNode=false (default configuration). On each lock request, numOwners remote calls are performed (in our example 2).
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+Above diagram shows how lock on the same key are acquired when eagerLockSingleNode=true. The number of remote calls being performed is always 1, disregarding numOwners values (it can actually be 0, as we'll see later on).
+
+In this scenario, if the lock owner fails (Node_C) then the transaction that holds the lock, which originated on Node_A is marked for rollback.
+
+ Combining eagerLockSingleNode with the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737123$$[KeyAffinityService] can bring some interesting advantages. The next diagram shows this: 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ By using link:$$http://$$[KeyAffinityService] one can generate keys that would always map to the local node. If eagerLockSingleNode=true, then the remote lock acquisition happens locally: this way one can benefit from eager locking semantics and having the same performance as non eager locking. The optimisation is affected by cluster topology changes, so keys might get relocated. But for clusters where topology changes are rather rare this can bring  a lot of value. 
+
+The following xml snippet shows how can be configured:
+
+
+----
+
+      <transaction
+            transactionManagerLookupClass="org.infinispan.transaction.lookup.GenericTransactionManagerLookup"
+            syncRollbackPhase="false"
+            syncCommitPhase="false"
+            useEagerLocking="true" eagerLockSingleNode="true"/>
+
+----
+
+
+----
+
+      <transaction
+            transactionManagerLookupClass="org.infinispan.transaction.lookup.GenericTransactionManagerLookup"
+            syncRollbackPhase="false"
+            syncCommitPhase="false"
+            useEagerLocking="true" eagerLockSingleNode="true"/>
+
+----
+
+Note that the configuration is ignored if eager locking is disabled or cache mode is not DIST.
+
+[[sid-68355049_LockingandConcurrency-Consistency]]
+
+
+==== Consistency
+
+The fact that a single owner is locked (as opposed to all owners being locked) does not break the following consistency guarantee: if key K is hashed to nodes {A, B} and transaction TX1 acquires a lock for K, let's say on A. If another transaction, TX2, is started on B (or any other node) and TX2 tries to lock K then it will fail with a timeout as the lock is already held by TX1. The reason for this is the that the lock for a key K is always, deterministically, acquired on the same node of the cluster, regardless of where the transaction originates.
+
+[[sid-68355049_LockingandConcurrency-Nontransactionalcachesandconcurrentupdates]]
+
+
+=== transactional caches and concurrent updates
+
+This configuration refers to non-transactional distributed and local caches only (doesn't apply to replicated caches) and was added in Infinispan 5.2. Depending on whether one needs to support concurrent updates (e.g. two threads concurrently writing the same key), the following configuration option can be used:
+
+
+----
+
+<locking supportsConcurrentUpdates="true"/>
+
+----
+
+ When enabled (default == true), the _supportConcurrentUpdates_ adds internal support for concurrent writes: a locking interceptor that would serialize writes to the same key and a delegation layer, that designates a lock owner and uses it in order to coordinate the writes to a key. 
+
+ More specific, when a thread running on node A writes on key _k_ that mapps according to the consistent hash to nodes {B, C} 
+
+ (given _numOwners_ ==2): 
+
+
+* A forwards (RPC) the write to the primary owner. The primary owner is the first node in the list of owners, in our example B
+
+
+*  B acquires a lock on _k._ Once the lock successfully acquired,_ _it forwards (RPC) the request to the rest of owners (in this example C) that apply it locally 
+
+
+* B applies the result locally, releases the lock and then it returns to A
+
+ Reasoning about the performance: in order to assure consistency under concurrent update, we do 2 RPCs: from operation originator to main owner and from main owner to the rest of the owners. That's one more than when _supportConcurrentUpdates == false_ : in this case the operation originator does a single (multicast) RPC to all the owners. This induces a performance cost and whenever one uses the cache in non-concurrent manner, it is recommended that this configuration to be set to false in order to increase the performance. When using Infinispan in client/server mode with a Hot Rod client, this would use the main data owner in order to write data, so in this scenario there should not be any performance cost when supporting concurrent updates. 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-2-New_in_Infinispan_4_2_0.adoc b/documentation/src/main/asciidoc/user_guide/chapter-2-New_in_Infinispan_4_2_0.adoc
index 111c4c4..347013e 100644
--- a/documentation/src/main/asciidoc/user_guide/chapter-2-New_in_Infinispan_4_2_0.adoc
+++ b/documentation/src/main/asciidoc/user_guide/chapter-2-New_in_Infinispan_4_2_0.adoc
@@ -1,4 +1,4 @@
-[[sid-8093923_UserGuide-NewinInfinispan4.2.0]]
+[[sid-68355028_UserGuide-NewinInfinispan4.2.0]]
 
 ==  New in Infinispan 4.2.0
 
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-20-Configuring_Cache_declaratively.adoc b/documentation/src/main/asciidoc/user_guide/chapter-20-Configuring_Cache_declaratively.adoc
new file mode 100644
index 0000000..bd17ef9
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-20-Configuring_Cache_declaratively.adoc
@@ -0,0 +1,38 @@
+[[sid-68355050]]
+
+==  Configuring Cache declaratively
+
+ One of the major goals of Infinispan is to aim for zero configuration. A simple XML configuration file containing nothing more than a single infinispan element is enough to get you started. The configuration file listed below provides sensible defaults and is perfectly valid. 
+
+
+----
+
+<infinispan />
+
+----
+
+However, that would only give you the most basic, local mode, non-clustered cache. Non basic configurations are very likely to use customized global and default cache elements.
+
+ Declarative configuration is the most common approach to configuring Infinispan cache instances. In order to read XML configuration files one would typically construct an instance of CacheManager by pointing to an XML file containing Infinispan configuration. Once configuration file is read you can obtain reference to the default cache instance. 
+
+
+----
+
+CacheManager manager = new DefaultCacheManager("my-config-file.xml");
+Cache defaultCache = manager.getCache();
+
+----
+
+ or any other named instance specified in "my-config-file.xml". 
+
+
+----
+
+Cache someNamedCache = manager.getCache("someNamedCache");
+
+----
+
+Every time you define &lt;namedCache&gt; element in XML configuration file, in addition to &lt;default&gt; cache element, you are effectively configuring additional caches whose settings are inheriting and/or overriding the default cache.
+
+ Refer to Infinispan configuration link:$$http://docs.jboss.org/infinispan/5.1/configdocs$$[reference] for more details. If you are using XML editing tools for configuration writing you can use provided Infinispan link:$$http://www.infinispan.org/schemas/infinispan-config-5.1.xsd$$[schema] to assist you. 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-21-Configuration_Migration_Tools.adoc b/documentation/src/main/asciidoc/user_guide/chapter-21-Configuration_Migration_Tools.adoc
new file mode 100644
index 0000000..5a2ec8b
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-21-Configuration_Migration_Tools.adoc
@@ -0,0 +1,66 @@
+[[sid-68355051]]
+
+==  Configuration Migration Tools
+
+Infinispan has a number of scripts for importing configurations from other cache products. Currently we have scripts to import configurations from:
+
+
+* JBoss Cache 3.x
+
+
+* EHCache 1.x
+
+
+* Coherence 3.x
+
+ JBoss Cache 3.x itself supports configuration link:$$http://jbosscache.blogspot.com/2008/07/configuration-changes-in-jboss-cache-3.html$$[migration] from previous (2.x) versions, so JBoss Cache 2.x configurations can be migrated indirectly. 
+
+
+----
+If you wish to help write conversion tools for other caching systems, please contact <a href="https://lists.jboss.org/mailman/listinfo/infinispan-dev">infinispan-dev</a>.  
+----
+
+There is a single scripts for importing configurations: ${INFINISPAN_HOME}/bin/importConfig.sh and an equivalent .BAT script for Windows. Just run it and you should get a help message to assist you with the import:
+
+
+----
+C:\infinispan\bin> importConfig.bat
+Missing 'source', cannot proceed
+Usage:
+importConfig [-source <the file to be transformed>]
+[-destination <where to store resulting XML>]
+[-type <the type of the source, possible values being: [JBossCache3x, Ehcache1x, Coherence35x] >]
+
+C:\infinispan\bin>
+
+----
+
+Here is how a JBoss Cache 3.x configuration file is imported:
+
+
+----
+C:\infinispan\bin>importConfig.bat -source in\jbosscache_all.xml -destination out.xml -type JBossCache3x
+
+WARNING! Preload elements cannot be automatically transformed, please do it manually!
+
+WARNING! Please configure cache loader props manually!
+
+WARNING! Singleton store was changed and needs to be configured manually!
+
+IMPORTANT: Please take a look at the generated file 
+for (possible) TODOs about the elements that couldn't be converted automatically!
+
+---
+
+New configuration file [out.xml] successfully created.
+
+---
+
+C:\infinispan\bin>
+
+----
+
+ Please read all warning messages _carefully_ and inspect the generated XML for potential TODO statements that indicate the need for manual intervention. In the case of JBoss Cache 3.x this would usually have to do with custom extensions, such as custom CacheLoaders that cannot be automatically migrated. 
+
+For EHCache and Coherence these may also contain suggestions and warnings for configuration options that may not have direct equivalents in Infinispan.
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-22-Consistent_Concurrent_Updates_With_Hot_Rod_Versioned_Operations.adoc b/documentation/src/main/asciidoc/user_guide/chapter-22-Consistent_Concurrent_Updates_With_Hot_Rod_Versioned_Operations.adoc
new file mode 100644
index 0000000..9246e1c
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-22-Consistent_Concurrent_Updates_With_Hot_Rod_Versioned_Operations.adoc
@@ -0,0 +1,74 @@
+[[sid-68355052]]
+
+==  Consistent Concurrent Updates With Hot Rod Versioned Operations
+
+[[sid-68355052_ConsistentConcurrentUpdatesWithHotRodVersionedOperations-Introduction]]
+
+
+=== Introduction
+
+ Data structures, such as Infinispan link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/Cache.html$$[Cache] , that are accessed and modified concurrently can suffer from data consistency issues unless there're mechanisms to guarantee data correctness. Infinispan Cache, since it implements link:$$http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/api/java/util/concurrent/ConcurrentMap.html?is-external=true$$[ConcurrentMap] , provides operations such as link:$$http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/api/java/util/concurrent/ConcurrentMap.html#replace(K, V, V)$$[conditional replace] , link:$$http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/api/java/util/concurrent/ConcurrentMap.html#putIfAbsent(K, V)$$[putIfAbsent] , and link:$$http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/api/java/util/concurrent/ConcurrentMap.html#remove(java.lang.Object, java.lang.Object)$$[conditional remove] to its clients in order to guarantee data correctness. It even allows clients to operate against cache instances within JTA transactions, hence providing the necessary data consistency guarantees. 
+
+ However, when it comes to link:$$http://community.jboss.org/wiki/HotRodProtocol$$[Hot Rod protocol] backed link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737146$$[servers] , clients do not yet have the ability to start remote transactions but they can call instead versioned operations to mimic the conditional methods provided by the embedded Infinispan cache instance API.  Let's look at a real example to understand how it works. 
+
+[[sid-68355052_ConsistentConcurrentUpdatesWithHotRodVersionedOperations-DataConsistencyProblem]]
+
+
+=== Data Consistency Problem
+
+Imagine you have two ATMs that connect using Hot Rod to a bank where an account's balance is stored.  Two closely followed operations to retrieve the latest balance could return 500 CHF (swiss francs) as shown below:
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+Next a customer connects to the first ATM and requests 400 CHF to be retrieved.  Based on the last value read, the ATM could calculate what the new balance is, which is 100 CHF, and request a put with this new value. Let's imagine now that around the same time another customer connects to the ATM and requests 200 CHF to be retrieved.  Let's assume that the ATM thinks it has the latest balance and based on its calculations it sets the new balance to 300 CHF:
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+Obviously, this would be wrong.  Two concurrent updates have resulted in an incorrect account balance.  The second update should not have been allowed since the balance the second ATM had was incorrect. Even if the ATM would have retrieved the balance before calculating the new balance, someone could have updated between the new balance being retrieved and the update. Before finding out how to solve this issue in a client-server scenario with Hot Rod, let's look at how this is solved when Infinispan clients run in peer-to-peer mode where clients and Infinispan live within the same JVM.
+
+[[sid-68355052_ConsistentConcurrentUpdatesWithHotRodVersionedOperations-PeertoPeerSolution]]
+
+
+==== to-Peer Solution
+
+ If the ATM and the Infinispan instance storing the bank account lived in the same JVM, the ATM could use the link:$$http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/api/java/util/concurrent/ConcurrentMap.html#replace(K, V, V)$$[conditional replace API] referred at the beginning of this article.  So, it could send the previous known value to verify whether it has changed since it was last read.  By doing so, the first operation could double check that the balance is still 500 CHF when it was to update to 100 CHF.  Now, when the second operation comes, the current balance would not be 500 CHF any more and hence the conditional replace call would fail, hence avoiding data consistency issues: 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+[[sid-68355052_ConsistentConcurrentUpdatesWithHotRodVersionedOperations-ClientServerSolution]]
+
+
+==== Client-Server Solution
+
+In theory, Hot Rod could use the same p2p solution but sending the previous value would be not practical.  In this example, the previous value is just an integer but the value could be a lot bigger and hence forcing clients to send it to the server would be rather wasteful.  Instead, Hot Rod offers versioned operations to deal with this situation.
+
+ Basically, together with each key/value pair, Hot Rod stores a version number which uniquely identifies each modification. So, using an operation called link:$$http://community.jboss.org/wiki/HotRodProtocol#getWithVersion_response$$[getVersioned or getWithVersion] , clients can retrieve not only the value associated with a key, but also the current version. So, if we look at the previous example once again, the ATMs could call getVersioned and get the balance's version: 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ When the ATMs wanted to modify the balance, instead of just calling put, they could call link:$$http://community.jboss.org/wiki/HotRodProtocol#removeIfUnmodified_request$$[replaceIfUnmodified] operation passing the latest version number of which the clients are aware of.  The operation will only succeed if the version passed matches the version in the server.  So, the first modification by the ATM would be allowed since the client passes 1 as version and the server side version for the balance is also 1.  On the other hand, the second ATM would not be able to make the modification because after the first ATMs modification the version would have been incremented to 2, and now the passed version (1) and the server side version (2) would not match: 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ Finally, to find out how to call these operations from a Java environment, checkout link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737142$$[the Java Hot Rod Client article] . 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-23-Cache_Loaders_and_Stores.adoc b/documentation/src/main/asciidoc/user_guide/chapter-23-Cache_Loaders_and_Stores.adoc
new file mode 100644
index 0000000..ee5f392
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-23-Cache_Loaders_and_Stores.adoc
@@ -0,0 +1,897 @@
+[[sid-68355053]]
+
+==  Cache Loaders and Stores
+
+[[sid-68355053_CacheLoadersandStores-Introduction]]
+
+
+=== Introduction
+
+Cache loader is Infinispan's connection to a (persistent) data store. Cache loader fetches data from a store when that data is not in the cache, and when modifications are made to data in the cache the CacheLoader is called to store those modifications back to the store. Cache loaders are associated with individual caches, i.e. different caches from the same cache manager might have different cache store configurations.
+
+[[sid-68355053_CacheLoadersandStores-Configuration]]
+
+
+=== Configuration
+
+Cache loaders can be configured in a chain. Cache read operations will look at all of the cache loaders in the order they've been configured until it finds a valid, non-null element of data. When performing writes all cache loaders are written to except if the ignoreModifications element has been set to true for a specific cache loader. See the configuration section below for details.
+
+
+----
+
+<loaders passivation="false" shared="false" preload="true">
+   <!-- We can have multiple cache loaders, which get chained -->
+   <fileStore
+           fetchPersistentState="true"
+           purgerThreads="3"
+           purgeSynchronously="true"
+           ignoreModifications="false"
+           purgeOnStartup="false"
+           location="${java.io.tmpdir}">
+      <async
+           enabled="true"
+           flushLockTimeout="15000"
+           threadPoolSize="5" />
+      <singletonStore
+           enabled="true"
+           pushStateWhenCoordinator="true"
+           pushStateTimeout="20000" />
+   </fileStore>
+</loaders>
+
+----
+
+
+----
+
+ConfigurationBuilder builder = new ConfigurationBuilder();
+builder.loaders()
+    .passivation(false)
+    .shared(false)
+    .preload(true)
+    .addFileCacheStore()
+        .fetchPersistentState(true)
+        .purgerThreads(3)
+        .purgeSynchronously(true)
+        .ignoreModifications(false)
+        .purgeOnStartup(false)
+        .location(System.getProperty("java.io.tmpdir"))
+        .async()
+           .enabled(true)
+           .flushLockTimeout(15000)
+           .threadPoolSize(5)
+        .singletonStore()
+           .enabled(true)
+           .pushStateWhenCoordinator(true)
+           .pushStateTimeout(20000);
+
+----
+
+
+*  passivation (false by default) has a significant impact on how Infinispan interacts with the loaders, and is discussed in the <<sid-68355053,next paragraph>> . 
+
+
+* shared (false by default) indicates that the cache loader is shared among different cache instances, for example where all instances in a cluster use the same JDBC settings to talk to the same remote, shared database. Setting this to true prevents repeated and unnecessary writes of the same data to the cache loader by different cache instances.
+
+
+* preload (false by default) if true, when the cache starts, data stored in the cache loader will be pre-loaded into memory. This is particularly useful when data in the cache loader is needed immediately after startup and you want to avoid cache operations being delayed as a result of loading this data lazily. Can be used to provide a 'warm-cache' on startup, however there is a performance penalty as startup time is affected by this process. Note that preloading is done in a local fashion, so any data loaded is only stored locally in the node. No replication or distribution of the preloaded data happens. Also, Infinispan only preloads up to the maximum configured number of entries in eviction.
+
+
+* class attribute (mandatory) defines the class of the cache loader implementation.
+
+
+* fetchPersistentState (false by default) determines whether or not to fetch the persistent state of a cache when joining a cluster. The aim here is to take the persistent state of a cache and apply it to the local cache store of the joining node. Hence, if cache store is configured to be shared, since caches access the same cache store, fetch persistent state is ignored. Only one configured cache loader may set this property to true; if more than one cache loader does so, a configuration exception will be thrown when starting your cache service.
+
+
+* purgeSynchronously will control whether the expiration takes place in the eviction thread, i.e. if purgeSynchronously (false by default) is set to true, the eviction thread will block until the purging is finished, otherwise would return immediately. If the cache loader supports multi-threaded purge then purgeThreads (1 by default) are used for purging expired entries. There are cache loaders that support multi-threaded purge (e.g. FileCacheStore) and caches that don't (e.g. JDBCCacheStore); check the actual cache loader configuration in order to see that.
+
+
+* ignoreModifications(false by default) determines whether write methods are pushed down to the specific cache loader. Situations may arise where transient application data should only reside in a file based cache loader on the same server as the in-memory cache, for example, with a further JDBC based cache loader used by all servers in the network. This feature allows you to write to the 'local' file cache loader but not the shared JDBCCacheLoader.
+
+
+* purgeOnStatup empties the specified cache loader (if ignoreModifications is false) when the cache loader starts up.
+
+
+* additional attributes configure aspects specific to each cache loader, e.g. the location attribute in the previous example refers to where the FileCacheStore will keep the files that contain data. Other loaders, with more complex configuration, also introduce additional sub-elements to the basic configuration. See for example the JDBC cache store configuration examples below
+
+
+* singletonStore (default for enabled is false) element enables modifications to be stored by only one node in the cluster, the coordinator. Essentially, whenever any data comes in to some node it is always replicated(or distributed) so as to keep the caches in-memory states in sync; the coordinator, though, has the sole responsibility of pushing that state to disk. This functionality can be activated setting the enabled attribute to true in all nodes, but again only the coordinator of the cluster will the modifications in the underlying cache loader as defined in loader element. You cannot define a shared and with singletonStore enabled at the same time.
+
+
+* pushStateWhenCoordinator (true by default) If true, when a node becomes the coordinator, it will transfer in-memory state to the underlying cache loader. This can be very useful in situations where the coordinator crashes and the new coordinator is elected.
+
+
+*  async element has to do with cache store persisting data (a)synchronously to the actual store. It is discussed in detail link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737144$$[here] . 
+
+[[sid-68355053_CacheLoadersandStores-CachePassivation]]
+
+
+=== Cache Passivation
+
+A cache loader can be used to enforce entry passivation and activation on eviction in a cache. Cache passivation is the process of removing an object from in-memory cache and writing it to a secondary data store (e.g., file system, database) on eviction. Cache Activation is the process of restoring an object from the data store into the in-memory cache when it's needed to be used. In both cases, the configured cache loader will be used to read from the data store and write to the data store.
+
+When an eviction policy in effect evicts an entry from the cache, if passivation is enabled, a notification that the entry is being passivated will be emitted to the cache listeners and the entry will be stored. When a user attempts to retrieve a entry that was evicted earlier, the entry is (lazily) loaded from the cache loader into memory. When the entry and its children have been loaded, they're removed from the cache loader and a notification is emitted to the cache listeners that the entry has been activated. In order to enable passivation just set passivation to true (false by default). When passivation is used, only the first cache loader configured is used and all others are ignored.
+
+[[sid-68355053_CacheLoadersandStores-CacheLoaderBehaviorwithPassivationDisabledvsEnabled]]
+
+
+==== Cache Loader Behavior with Passivation Disabled vs Enabled
+
+When passivation is disabled, whenever an element is modified, added or removed, then that modification is persisted in the backend store via the cache loader. There is no direct relationship between eviction and cache loading. If you don't use eviction, what's in the persistent store is basically a copy of what's in memory. If you do use eviction, what's in the persistent store is basically a superset of what's in memory (i.e. it includes entries that have been evicted from memory). When passivation is enabled, there is a direct relationship between eviction and the cache loader. Writes to the persistent store via the cache loader only occur as part of the eviction process. Data is deleted from the persistent store when the application reads it back into memory. In this case, what's in memory and what's in the persistent store are two subsets of the total information set, with no intersection between the subsets. Following is a simple example, showing what state is in RAM and in the persistent store after each step of a 6 step process:
+
+
+. Insert keyOne
+
+
+. Insert keyTwo
+
+
+. Eviction thread runs, evicts keyOne
+
+
+. Read keyOne
+
+
+. Eviction thread runs, evicts keyTwo
+
+
+. Remove keyTwo
+
+ When passivation is _disabled_ : 
+
+
+. Memory: keyOne Disk: keyOne
+
+
+. Memory: keyOne, keyTwo Disk: keyOne, keyTwo
+
+
+. Memory: keyTwo Disk: keyOne, keyTwo
+
+
+. Memory: keyOne, keyTwo Disk: keyOne, keyTwo
+
+
+. Memory: keyOne Disk: keyOne, keyTwo
+
+
+. Memory: keyOne Disk: keyOne
+
+ When passivation is _enabled_ : 
+
+
+. Memory: keyOne Disk:
+
+
+. Memory: keyOne, keyTwo Disk:
+
+
+. Memory: keyTwo Disk: keyOne
+
+
+. Memory: keyOne, keyTwo Disk:
+
+
+. Memory: keyOne Disk: keyTwo
+
+
+. Memory: keyOne Disk:
+
+[[sid-68355053_CacheLoadersandStores-Filesystembasedcacheloaders]]
+
+
+=== File system based cache loaders
+
+Infinispan ships with several cache loaders that utilize the file system as a data store. They all require a location attribute, which maps to a directory to be used as a persistent store. (e.g., location="/tmp/myDataStore" ).
+
+
+*  FileCacheStore, which is a simple filesystem-based implementation. Usage on shared filesystems like NFS, Windows shares, etc. should be avoided as these do not implement proper file locking and can cause data corruption. File systems are inherently not transactional, so when attempting to use your cache in a transactional context, failures when writing to the file (which happens during the commit phase) cannot be recovered. Please visit the link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/loaders/file/FileCacheStoreConfig.html$$[file cache store configuration documentation] for more information on the configurable parameters of this store. 
+
+
+*  BdbjeCacheStore, which is a cache loader implementation based on the link:$$http://www.oracle.com/database/berkeley-db/je/index.html$$[Oracle/Sleepycat's BerkeleyDB Java Edition] . 
+
+
+*  link:$$http://jdbm.sourceforge.net/$$[JdbmCacheStore] , which is a cache loader implementation based on the JDBM engine, a fast and free alternative to BerkeleyDB. 
+
+
+* LevelDBCacheStore, which is a cache store implementation based on Google's LevelDB, a fast key-value store.
+
+ Note that the BerkeleyDB implementation is much more efficient than the filesystem-based implementation, but requires a commercial license if distributed with an application (see link:$$http://www.oracle.com/database/berkeley-db/index.html$$[] for details). 
+
+ For detailed description of all the parameters supported by the stores, please consult the link:$$http://infinispan.sourceforge.net/4.0/apidocs/$$[javadoc] . 
+
+[[sid-68355053_CacheLoadersandStores-JDBCbasedcacheloaders]]
+
+
+=== JDBC based cache loaders
+
+Based on the type of keys to be persisted, there are three JDBC cache loaders:
+
+
+*  link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/binary/JdbcBinaryCacheStore.html$$[JdbcBinaryCacheStore] - can store any type of keys. It stores all the keys that have the same hash value (hashCode method on key) in the same table row/blob, having as primary key the hash value. While this offers great flexibility (can store any key type), it impacts concurrency/throughput. E.g. If storing k1,k2 and k3 keys, and keys had same hash code, then they'd persisted in the same table row. Now, if 3 threads try to concurrently update k1, k2 and k3 respectively, they would need to do it sequentially since these threads would be updating the same row. 
+
+
+*  link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/stringbased/JdbcStringBasedCacheStore.html$$[JdbcStringBasedCacheStore] - stores each key in its own row, increasing throughput under concurrent load. In order to store each key in its own column, it relies on a (pluggable) bijection that maps the each key to a String object. The bijection is defined by the Key2StringMapper interface. Infinispans ships a default implementation (smartly named link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/stringbased/DefaultKey2StringMapper.html$$[DefaultKey2StringMapper] ) that knows how to handle primitive types. 
+
+
+*  link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/mixed/JdbcMixedCacheStore.html$$[JdbcMixedCacheStore] - it is a hybrid implementation that, based on the key type, delegates to either link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/binary/JdbcBinaryCacheStore.html$$[JdbcBinaryCacheStore] or link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/stringbased/JdbcStringBasedCacheStore.html$$[JdbcStringBasedCacheStore] . 
+
+[[sid-68355053_CacheLoadersandStores-WhichJDBCcacheloadershouldIuse%3F]]
+
+
+==== Which JDBC cache loader should I use?
+
+ It is generally preferable to use link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/stringbased/JdbcStringBasedCacheStore.html$$[JdbcStringBasedCacheStore] when you are in control of the key types, as it offers better throughput under heavy load. One scenario in which it is not possible to use it though, is when you can't write an link:$$http://infinispan.sourceforge.net/4.0/apidocs/$$[Key2StringMapper] to map the keys to to string objects (e.g. when you don't have control over the types of the keys, for whatever reason). Then you should use either link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/binary/JdbcBinaryCacheStore.html$$[JdbcBinaryCacheStore] or link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/mixed/JdbcMixedCacheStore.html$$[JdbcMixedCacheStore] . The later is preferred to the former when the majority of the keys are handled by link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/stringbased/JdbcStringBasedCacheStore.html$$[JdbcStringBasedCacheStore] , but you still have some keys you cannot convert through link:$$http://infinispan.sourceforge.net/4.0/apidocs/$$[Key2StringMapper] . 
+
+[[sid-68355053_CacheLoadersandStores-Connectionmanagement%28pooling%29]]
+
+
+==== Connection management (pooling)
+
+ In order to obtain a connection to the database all the JDBC cache loaders rely on an link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/connectionfactory/ConnectionFactory.html$$[ConnectionFactory] implementation. The connection factory is specified programmatically using one of the connectionPool(), dataSource() or simpleConnection() methods on the JdbcBinaryCacheStoreConfigurationBuilder class or declaratively using one of the &lt;connectionPool /&gt;, &lt;dataSource /&gt; or &lt;simpleConnection /&gt; elements. Infinispan ships with three ConnectionFactory implementations: 
+
+
+*  link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/connectionfactory/PooledConnectionFactory.html$$[PooledConnectionFactory] is a factory based on link:$$http://sourceforge.net/projects/c3p0/$$[C3P0] . Refer to link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/connectionfactory/PooledConnectionFactory.html$$[javadoc] for details on configuring it. 
+
+
+*  link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/connectionfactory/ManagedConnectionFactory.html$$[ManagedConnectionFactory] is a connection factory that can be used within managed environments, such as application servers. It knows how to look into the JNDI tree at a certain location (configurable) and delegate connection management to the DataSource. Refer to javadoc link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/connectionfactory/ManagedConnectionFactory.html$$[javadoc] for details on how this can be configured. 
+
+
+*  link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/connectionfactory/SimpleConnectionFactory.html$$[SimpleConnectionFactory] is a factory implementation that will create database connection on a per invocation basis. Not recommended in production. 
+
+The PooledConnectionFactory is generally recommended for stand-alone deployments (i.e. not running within AS or servlet container). ManagedConnectionFactory can be used when running in a managed environment where a DataSource is present, so that connection pooling is performed within the DataSource.
+
+[[sid-68355053_CacheLoadersandStores-Sampleconfigurations]]
+
+
+==== Sample configurations
+
+ Bellow is an sample configuration for the link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/binary/JdbcBinaryCacheStore.html$$[JdbcBinaryCacheStore] . For detailed description of all the parameters used refer to the link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/binary/JdbcBinaryCacheStoreConfig.html$$[javadoc] .  Please note the use of multiple XML schemas, since each cachestore has its own schema. 
+
+
+----
+<?xml version="1.0" encoding="UTF-8"?>
+<infinispan
+   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+   xsi:schemaLocation="urn:infinispan:config:5.2 http://www.infinispan.org/schemas/infinispan-config-5.2.xsd
+                       urn:infinispan:config:jdbc:5.2 http://www.infinispan.org/schemas/infinispan-cachestore-jdbc-config-5.2.xsd"
+   xmlns="urn:infinispan:config:5.2"
+   xmlns:jdbc="urn:infinispan:config:jdbc:5.2" >
+
+<loaders>
+   <binaryKeyedJdbcStore xmlns="urn:infinispan:config:jdbc:5.2" fetchPersistentState="false"ignoreModifications="false" purgeOnStartup="false">
+       <connectionPool connectionUrl="jdbc:h2:mem:infinispan_binary_based;DB_CLOSE_DELAY=-1" username="sa" driverClass="org.h2.Driver"/>
+       <binaryKeyedTable dropOnExit="true" createOnStart="true" prefix="ISPN_BUCKET_TABLE">
+         <idColumn name="ID_COLUMN" type="VARCHAR(255)" />
+         <dataColumn name="DATA_COLUMN" type="BINARY" />
+         <timestampColumn name="TIMESTAMP_COLUMN" type="BIGINT" />
+       </binaryKeyedTable>
+   </binaryKeyedJdbcStore>
+</loaders>
+
+ :
+
+</infinispan>
+
+----
+
+
+----
+
+ConfigurationBuilder builder = new ConfigurationBuilder();
+  builder.loaders()
+     .addLoader(JdbcBinaryCacheStoreConfigurationBuilder.class)
+     .fetchPersistentState(false)
+     .ignoreModifications(false)
+     .purgeOnStartup(false)
+     .table()
+        .dropOnExit(true)
+        .createOnStart(true)
+        .tableNamePrefix("ISPN_BUCKET_TABLE")
+        .idColumnName("ID_COLUMN").idColumnType("VARCHAR(255)")
+        .dataColumnName("DATA_COLUMN").dataColumnType("BINARY")
+        .timestampColumnName("TIMESTAMP_COLUMN").timestampColumnType("BIGINT")
+     .connectionPool()
+        .connectionUrl("jdbc:h2:mem:infinispan_binary_based;DB_CLOSE_DELAY=-1")
+        .username("sa")
+        .driverClass("org.h2.Driver");
+
+----
+
+ Bellow is an sample configuration for the link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/stringbased/JdbcStringBasedCacheStore.html$$[JdbcStringBasedCacheStore] . For detailed description of all the parameters used refer to the link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/stringbased/JdbcStringBasedCacheStoreConfig.html$$[javadoc] . 
+
+
+----
+<loaders>
+   <stringKeyedJdbcStore xmlns="urn:infinispan:config:jdbc:5.2" fetchPersistentState="false" ignoreModifications="false" purgeOnStartup="false">
+       <connectionPool connectionUrl="jdbc:h2:mem:infinispan_binary_based;DB_CLOSE_DELAY=-1" username="sa" driverClass="org.h2.Driver"/>
+       <stringKeyedTable dropOnExit="true" createOnStart="true" prefix="ISPN_STRING_TABLE">
+         <idColumn name="ID_COLUMN" type="VARCHAR(255)" />
+         <dataColumn name="DATA_COLUMN" type="BINARY" />
+         <timestampColumn name="TIMESTAMP_COLUMN" type="BIGINT" />
+       </stringKeyedTable>
+   </stringKeyedJdbcStore>
+</loaders>
+
+----
+
+
+----
+
+ConfigurationBuilder builder = new ConfigurationBuilder();
+  builder.loaders().addLoader(JdbcStringBasedCacheStoreConfigurationBuilder.class)
+     .fetchPersistentState(false)
+     .ignoreModifications(false)
+     .purgeOnStartup(false)
+     .table()
+        .dropOnExit(true)
+        .createOnStart(true)
+        .tableNamePrefix("ISPN_STRING_TABLE")
+        .idColumnName("ID_COLUMN").idColumnType("VARCHAR(255)")
+        .dataColumnName("DATA_COLUMN").dataColumnType("BINARY")
+        .timestampColumnName("TIMESTAMP_COLUMN").timestampColumnType("BIGINT")
+     .connectionPool()
+        .connectionUrl("jdbc:h2:mem:infinispan_binary_based;DB_CLOSE_DELAY=-1")
+        .username("sa")
+        .driverClass("org.h2.Driver");
+
+----
+
+ Bellow is an sample configuration for the link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/mixed/JdbcMixedCacheStore.html$$[JdbcMixedCacheStore] . For detailed description of all the parameters used refer to the link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/jdbc/mixed/JdbcMixedCacheStoreConfig.html$$[javadoc] . 
+
+
+----
+<loaders>
+   <mixedKeyedJdbcStore xmlns="urn:infinispan:config:jdbc:5.2" fetchPersistentState="false" ignoreModifications="false" purgeOnStartup="false">
+      <connectionPool connectionUrl="jdbc:h2:mem:infinispan_binary_based;DB_CLOSE_DELAY=-1" username="sa" driverClass="org.h2.Driver" />
+      <stringKeyedTable dropOnExit="true" createOnStart="true" prefix="ISPN_MIXED_STR_TABLE">
+         <idColumn name="ID_COLUMN" type="VARCHAR(255)" />
+         <dataColumn name="DATA_COLUMN" type="BINARY" />
+         <timestampColumn name="TIMESTAMP_COLUMN" type="BIGINT" />
+      </stringKeyedTable>
+      <binaryKeyedTable dropOnExit="true" createOnStart="true" prefix="ISPN_MIXED_BINARY_TABLE">
+         <idColumn name="ID_COLUMN" type="VARCHAR(255)" />
+         <dataColumn name="DATA_COLUMN" type="BINARY" />
+         <timestampColumn name="TIMESTAMP_COLUMN" type="BIGINT" />
+      </binaryKeyedTable>
+   </loader>
+</loaders>
+
+----
+
+
+----
+
+ConfigurationBuilder builder = new ConfigurationBuilder();
+  builder.loaders().addLoader(JdbcMixedCacheStoreConfigurationBuilder.class)
+     .fetchPersistentState(false).ignoreModifications(false).purgeOnStartup(false)
+     .stringTable()
+        .dropOnExit(true)
+        .createOnStart(true)
+        .tableNamePrefix("ISPN_MIXED_STR_TABLE")
+        .idColumnName("ID_COLUMN").idColumnType("VARCHAR(255)")
+        .dataColumnName("DATA_COLUMN").dataColumnType("BINARY")
+        .timestampColumnName("TIMESTAMP_COLUMN").timestampColumnType("BIGINT")
+     .binaryTable()
+        .dropOnExit(true)
+        .createOnStart(true)
+        .tableNamePrefix("ISPN_MIXED_BINARY_TABLE")
+        .idColumnName("ID_COLUMN").idColumnType("VARCHAR(255)")
+        .dataColumnName("DATA_COLUMN").dataColumnType("BINARY")
+        .timestampColumnName("TIMESTAMP_COLUMN").timestampColumnType("BIGINT")
+     .connectionPool()
+        .connectionUrl("jdbc:h2:mem:infinispan_binary_based;DB_CLOSE_DELAY=-1")
+        .username("sa")
+        .driverClass("org.h2.Driver");
+
+----
+
+Finally, below is an example of a JDBC cache store with a managed connection factory, which is chosen implicitly by specifying a datasource JNDI location:
+
+
+----
+
+<stringKeyedJdbcStore xmlns="urn:infinispan:config:jdbc:5.2" fetchPersistentState="false" ignoreModifications="false" purgeOnStartup="false">
+   <dataSource jndiUrl="java:/StringStoreWithManagedConnectionTest/DS" />
+   <stringKeyedTable dropOnExit="true" createOnStart="true" prefix="ISPN_STRING_TABLE">
+       <idColumn name="ID_COLUMN" type="VARCHAR(255)" />
+       <dataColumn name="DATA_COLUMN" type="BINARY" />
+       <timestampColumn name="TIMESTAMP_COLUMN" type="BIGINT" />
+   </stringKeyedTable>
+</stringKeyedJdbcStore>
+
+----
+
+
+----
+
+ConfigurationBuilder builder = new ConfigurationBuilder();
+    builder.loaders().addLoader(JdbcStringBasedCacheStoreConfigurationBuilder.class)
+     .fetchPersistentState(false).ignoreModifications(false).purgeOnStartup(false)
+     .table()
+        .dropOnExit(true)
+        .createOnStart(true)
+        .tableNamePrefix("ISPN_STRING_TABLE")
+        .idColumnName("ID_COLUMN").idColumnType("VARCHAR(255)")
+        .dataColumnName("DATA_COLUMN").dataColumnType("BINARY")
+        .timestampColumnName("TIMESTAMP_COLUMN").timestampColumnType("BIGINT")
+     .dataSource()
+        .jndiUrl("java:/StringStoreWithManagedConnectionTest/DS");
+
+----
+
+
+[NOTE]
+.Apache Derby users
+==== 
+ If you're connecting to an Apache Derby database, make sure you set dataColumnType to BLOB : 
+
+
+----
+
+<dataColumn name="DATA_COLUMN" type="BLOB"/>
+
+----
+
+
+==== 
+
+
+[[sid-68355053_CacheLoadersandStores-Cloudcacheloader]]
+
+
+=== Cloud cache loader
+
+ The CloudCacheStore implementation utilizes link:$$http://code.google.com/p/jclouds/$$[JClouds] to communicate with cloud storage providers such as link:$$http://aws.amazon.com/s3/$$[Amazon's S3] , Rackspace's link:$$http://www.rackspacecloud.com/cloud_hosting_products/files$$[Cloudfiles] or any other such provider supported by JClouds. If you're planning to use Amazon S3 for storage, consider using it with Infinispan. Infinispan itself provides in-memory caching for your data to minimize the amount of remote access calls, thus reducing the latency and cost of fetching your Amazon S3 data. With cache replication, you are also able to load data from your local cluster without having to remotely access it every time. Note that Amazon S3 does not support transactions. If transactions are used in your application then there is some possibility of state inconsistency when using this cache loader. However, writes are atomic, in that if a write fails nothing is considered written and data is never corrupted. For a list of configuration refer to the link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/loaders/cloud/CloudCacheStoreConfig.html$$[javadoc] . 
+
+[[sid-68355053_CacheLoadersandStores-Remotecacheloader]]
+
+
+=== Remote cache loader
+
+ The RemoteCacheStore is a cache loader implementation that stores data in a remote infinispan cluster. In order to communicate with the remote cluster, the RemoteCacheStore uses the HotRod client/server architecture. HotRod bering the load balancing and fault tolerance of calls and the possibility to fine-tune the connection between the RemoteCacheStore and the actual cluster. Please refer to HotRod for more information on the protocol, link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737142$$[client] and link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737146$$[server] configuration. For a list of RemoteCacheStore configuration refer to the link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/loaders/remote/configuration/RemoteCacheStoreConfigurationBuilder.html$$[javadoc] . Example: 
+
+
+----
+
+<?xml version="1.0" encoding="UTF-8"?>
+<infinispan
+   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+   xsi:schemaLocation="urn:infinispan:config:5.2 http://www.infinispan.org/schemas/infinispan-config-5.2.xsd
+                       urn:infinispan:config:remote:5.2 http://www.infinispan.org/schemas/infinispan-cachestore-remote-config-5.2.xsd"
+   xmlns="urn:infinispan:config:5.2"
+   xmlns:remote="urn:infinispan:config:remote:5.2" >
+
+ :
+<loaders>
+   <remoteStore xmlns="urn:infinispan:config:remote:5.2" fetchPersistentState="false"
+             ignoreModifications="false" purgeOnStartup="false" remoteCache="mycache" rawValues="true">
+      <servers>
+         <server host="one" port="12111"/>
+         <server host="two" />
+      </servers>
+      <connectionPool maxActive="10" exhaustedAction="CREATE_NEW" />
+      <async enabled="true" />
+   </remoteStore>
+</loaders>
+
+ :
+
+</infinispan>
+
+----
+
+
+----
+
+ConfigurationBuilder b = new ConfigurationBuilder();
+b.loaders().addStore(RemoteCacheStoreConfigurationBuilder.class)
+     .fetchPersistentState(false)
+     .ignoreModifications(false)
+     .purgeOnStartup(false)
+     .remoteCacheName("mycache")
+     .rawValues(true)
+     .addServer()
+        .host("one").port(12111)
+     .addServer()
+        .host("two")
+     .connectionPool()
+        .maxActive(10)
+        .exhaustedAction(ExhaustedAction.CREATE_NEW)
+     .async().enable();
+
+----
+
+In this sample configuration, the remote cache store is configured to use the remote cache named "mycache" on servers "one" and "two". It also configures connection pooling and provides a custom transport executor. Additionally the cache store is asynchronous.
+
+[[sid-68355053_CacheLoadersandStores-Cassandracacheloader]]
+
+
+=== Cassandra cache loader
+
+ The CassandraCacheStore was introduced in Infinispan 4.2. Read the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737148$$[specific page] for details on implementation and configuration. 
+
+[[sid-68355053_CacheLoadersandStores-Clustercacheloader]]
+
+
+=== Cluster cache loader
+
+The ClusterCacheLoader is a cache loader implementation that retrieves data from other cluster members.
+
+ It is a cache loader only as it doesn't persist anything (it is not a Store), therefore features like _fetchPersistentState_ (and like) are not applicable. 
+
+ A cluster cache loader can be used as a non-blocking (partial) alternative to _stateTransfer_ : keys not already available in the local node are fetched on-demand from other nodes in the cluster. This is a kind of lazy-loading of the cache content. 
+
+
+----
+
+<loaders>
+   <clusterLoader remoteCallTimeout="500" />
+</loaders>
+
+----
+
+
+----
+
+ConfigurationBuilder b = new ConfigurationBuilder();
+b.loaders()
+    .addClusterCacheLoader()
+    .remoteCallTimeout(500);
+
+----
+
+ For a list of ClusterCacheLoader configuration refer to the link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/loaders/cluster/ClusterCacheLoaderConfig.html$$[javadoc] . 
+
+Note: The ClusterCacheLoader does not support preloading(preload=true). It also won't provide state if fetchPersistentSate=true.
+
+[[sid-68355053_CacheLoadersandStores-JPAcachestore]]
+
+
+=== JPA cache store
+
+The implementation depends on JPA 2.0 specification to access entity meta model.
+
+In normal use cases, it's recommended to leverage Infinispan for JPA second level cache and/or query cache.  However, if you'd like to use only Infinispan API and you want Infinispan to persist into a cache store using a common format (e.g., a database with well defined schema), then JPA Cache Store could be right for you.
+
+When using JPA Cache Store, the key should be the ID of the entity, while the value should be the entity object.  Only a single @Id or @EmbeddedId annotated property is allowed.  Auto-generated ID is not supported.  Lastly, all entries will be stored as immortal entries.
+
+[[sid-68355053_CacheLoadersandStores-SampleUsage]]
+
+
+==== Sample Usage
+
+For example, given a persistence unit "myPersistenceUnit", and a JPA entity User:
+
+persistence.xml
+
+
+----
+
+<persistence-unit name="myPersistenceUnit">
+	...
+</persistence-unit>
+
+----
+
+ User entity class ﻿(see link:$$https://github.com/infinispan/infinispan/tree/master/cachestore/jpa/src/test/java/org/infinispan/loaders/jpa/entity$$[test for full example] ) 
+
+
+----
+
+@Entity
+public class User implements Serializable {
+	@Id
+	private String username;
+	private String firstName;
+	private String lastName;
+
+	...
+}
+
+----
+
+Then you can configure a cache "usersCache" to use JPA Cache Store, so that when you put data into the cache, the data would be persisted into the database based on JPA configuration.
+
+
+----
+
+EmbeddedCacheManager cacheManager = ...;
+
+
+Configuration cacheConfig = new ConfigurationBuilder().loaders()
+				.addLoader(JpaCacheStoreConfigurationBuilder.class)
+				.persistenceUnitName("myPersistenceUnit")
+				.entityClass(User.class)
+				.build();
+cacheManager.defineCache("usersCache", cacheConfig);
+
+Cache<String, User> usersCache = cacheManager.getCache("usersCache");
+usersCache.put("raytsang", new User(...));
+
+----
+
+Normally a single Infinispan cache can store multiple types of key/value pairs, for example:
+
+
+----
+
+Cache<String, User> usersCache = cacheManager.getCache("myCache");
+usersCache.put("raytsang", new User());
+Cache<Integer, Teacher> teachersCache = cacheManager.getCache("myCache");
+teachersCache.put(1, new Teacher());
+
+----
+
+It's important to note that, when a cache is configured to use a JPA Cache Store, that cache would only be able to store ONE type of data.
+
+
+----
+
+Cache<String, User> usersCache = cacheManager.getCache("myJPACache"); // configured for User entity class
+usersCache.put("raytsang", new User());
+Cache<Integer, Teacher> teachersCache = cacheManager.getCache("myJPACache"); // cannot do this when this cache is configured to use a JPA cache store
+teachersCache.put(1, new Teacher());
+
+----
+
+ Use of @EmbeddedId is supported so that you can also use composite keys (see the link:$$https://github.com/infinispan/infinispan/blob/master/cachestore/jpa/src/test/java/org/infinispan/loaders/jpa/entity/Vehicle.java$$[test code] for full example). 
+
+
+----
+
+@Entity
+public class Vehicle implements Serializable {
+	@EmbeddedId
+	private VehicleId id;
+	private String color;	...
+}
+
+@Embeddable
+public class VehicleId implements Serializable
+{
+	private String state;
+	private String licensePlate;
+	...
+}
+
+----
+
+Lastly, auto-generated IDs ﻿(e.g., @GeneratedValue) is not supported.  When putting things into the cache with a JPA cache store, the key should be the ID value!
+
+[[sid-68355053_CacheLoadersandStores-Configurationx]]
+
+
+==== Configuration
+
+[[sid-68355053_CacheLoadersandStores-SampleProgramaticConfiguration]]
+
+
+===== Sample Programatic Configuration
+
+
+----
+
+Configuration cacheConfig = new ConfigurationBuilder().loaders()
+				.addLoader(JpaCacheStoreConfigurationBuilder.class)
+				.persistenceUnitName("org.infinispan.loaders.jpa.configurationTest")
+				.entityClass(User.class)
+				.build();
+
+----
+
+[options="header"]
+|===============
+|Parameter|Description
+|persistenceUnitName| JPA persistence unit name in JPA configuration ﻿(persistence.xml) that contains the JPA entity class 
+|entityClass| JPA entity class that is expected to be stored in this cache.  Only one class is allowed. 
+
+|===============
+
+
+[[sid-68355053_CacheLoadersandStores-SampleXMLConfiguration]]
+
+
+===== Sample XML Configuration
+
+
+----
+
+<namedCache name="vehicleCache">
+	<loaders passivation="false" shared="true" preload="true">
+		<jpaStore 
+			persistenceUnitName="org.infinispan.loaders.jpa.configurationTest"
+			entityClassName="org.infinispan.loaders.jpa.entity.User"
+		/>
+	</loaders>
+</namedCache>
+
+----
+
+[options="header"]
+|===============
+|Parameter|Description
+|persistenceUnitName| JPA persistence unit name in JPA configuration ﻿(persistence.xml) that contains the JPA entity class 
+|entityClassName|Fully qualified JPA entity class name that is expected to be stored in this cache.  Only one class is allowed.
+
+|===============
+
+
+[[sid-68355053_CacheLoadersandStores-AdditionalReferences]]
+
+
+==== Additional References
+
+ Refer to the link:$$https://github.com/infinispan/infinispan/blob/master/cachestore/jpa/src/test/java/org/infinispan/loaders/jpa/config/ConfigurationTest.java$$[test case] for code samples in action. 
+
+ Refer to link:$$https://github.com/infinispan/infinispan/blob/master/cachestore/jpa/src/test/resources/config/jpa-config-53.xml$$[test configurations] for configuration samples. 
+
+[[sid-68355053_CacheLoadersandStores-LevelDBcachestore]]
+
+
+=== LevelDB cache store
+
+ link:$$http://code.google.com/p/leveldb/$$[LevelDB] is a fast key-value filesystem-based storage written at Google.  LevelDB cache store currently uses a link:$$https://github.com/dain/leveldb$$[Java implementation] .  It may be possible to use a link:$$https://github.com/fusesource/leveldbjni$$[JNI implementation] in the future. 
+
+[[sid-68355053_CacheLoadersandStores-SampleUsagex]]
+
+
+==== Sample Usage
+
+LevelDB cache store requires 2 filesystem directories to be configured - each directory for a LevelDB database.  One location is used to store non-expired data, while the second location is used to store expired keys pending purge.
+
+EmbeddedCacheManager cacheManager = ...;
+
+
+----
+
+Configuration cacheConfig = new ConfigurationBuilder().loaders()
+				.addLoader(LevelDBCacheStoreConfigurationBuilder.class)
+				.build();
+cacheManager.defineCache("usersCache", cacheConfig);
+
+Cache<String, User> usersCache = cacheManager.getCache("usersCache");
+usersCache.put("raytsang", new User(...));
+
+----
+
+[[sid-68355053_CacheLoadersandStores-Configurationxx]]
+
+
+==== Configuration
+
+[[sid-68355053_CacheLoadersandStores-SampleProgramaticConfigurationx]]
+
+
+===== Sample Programatic Configuration
+
+
+----
+
+Configuration cacheConfig = new ConfigurationBuilder().loaders()
+				.addLoader(LevelDBCacheStoreConfigurationBuilder.class)
+				.location("/tmp/leveldb/data")
+				.expiredLocation("/tmp/leveldb/expired")
+				.entityClass(User.class)
+				.build();
+
+----
+
+[options="header"]
+|===============
+|Parameter|Description
+|location|Directory to use for LevelDB to store primary cache store data.  Directory will be auto-created if it does not exit.
+|expiredLocation| Directory to use for LevelDB to store expiring data pending to be purged permanently.  Directory will be auto-created if it does not exit. 
+| expiryQueueSize |Size of the in-memory queue to hold expiring entries before it gets flushed into expired LevelDB store
+|clearThreshold| There are two methods to clear all entries in LevelDB.  One method is to iterate through all entries and remove each entry individually.  The other method is to delete the database and re-init.  For smaller databases, deleting individual entries is faster than the latter method.  This configuration sets the max number of entries allowed before using the latter method 
+| compressionType |Configuration for LevelDB for data compression, see CompressionType enum for options
+| blockSize | Configuration for LevelDB - see link:$$http://leveldb.googlecode.com/svn/trunk/doc/index.html$$[documentation] for performance tuning 
+| cacheSize | Configuration for LevelDB - see link:$$http://leveldb.googlecode.com/svn/trunk/doc/index.html$$[documentation] for performance tuning 
+
+|===============
+
+
+[[sid-68355053_CacheLoadersandStores-SampleXMLConfigurationx]]
+
+
+===== Sample XML Configuration
+
+
+----
+
+<namedCache name="vehicleCache">
+	<loaders passivation="false" shared="true" preload="true">
+		<leveldbStore 
+			location="/tmp/leveldb/data"
+			expiredLocation="/tmp/leveldb/expired"
+		/>
+	</loaders>
+</namedCache>
+
+----
+
+[[sid-68355053_CacheLoadersandStores-AdditionalReferencesx]]
+
+
+==== Additional References
+
+ Refer to the link:$$https://github.com/infinispan/infinispan/blob/master/cachestore/leveldb/src/test/java/org/infinispan/loaders/leveldb/config/ConfigurationTest.java$$[test case] for code samples in action. 
+
+ Refer to link:$$https://github.com/infinispan/infinispan/blob/master/cachestore/leveldb/src/test/resources/config/leveldb-config-52.xml$$[test configurations] for configuration samples. 
+
+[[sid-68355053_CacheLoadersandStores-CacheLoadersandtransactionalcaches]]
+
+
+=== Cache Loaders and transactional caches
+
+When a cache is transactional and a cache loader is present, the cache loader won't be enlisted in the transaction in which the cache is part. That means that it is possible to have inconsistencies at cache loader level: the transaction to succeed applying the in-memory state but (partially) fail applying the changes to the store. Manual recovery would not work with caches stores.
+
+[[sid-68355053_CacheLoadersandStores-MongoDBcacheloader]]
+
+
+=== MongoDB cache loader
+
+The MongoDB cachestore is released within the 5.3 version of Infinispan aka "Tactical Nuclear Penguin".
+
+To communicate with the MongoDB server instance, we are using the official java driver version  2.10.1
+
+To configure the cachestore, you just need to add a new entry into the loaders section.
+
+Here is an example for your xml configuration file:
+
+
+----
+
+<loaders>
+   <mongodbStore xmlns="urn:infinispan:config:mongodb:5.3" >
+        <connection host="localhost" port="27017" timeout="2000" acknowledgment="0"/>
+        <authentication username="mongoUser" password="mongoPass" />
+        <storage database="infinispan_test_database" collection="infispan_cachestore" />
+   </mongodbStore>
+</loaders>
+
+----
+
+If you prefer the programmatic API here is a snippet:
+
+
+----
+
+ConfigurationBuilder b = new ConfigurationBuilder();
+b.loaders().addStore(MongoDBCacheStoreConfigurationBuilder.class)
+   .host( "localhost" )
+   .port( 27017 )
+   .timeout( 1500 )
+   .acknowledgment( 0 )
+   .username( "mongoDBUSer" )
+   .password( "mongoBDPassword" )
+   .database( "infinispan_cachestore" )
+   .collection( "indexes" );
+
+final Configuration config = b.build();
+MongoDBCacheStoreConfiguration store = (MongoDBCacheStoreConfiguration) config.loaders().cacheLoaders().get(0);
+
+----
+
+ The connection section contains the connection information to connect to the MongoDB server instance. The authentication section is optional, it allows you to specificy username and password if you are using some. The storage section explicits where you will store the data. 
+
+[options="header"]
+|===============
+|Section|property|usage|default value
+| _connection_ | | | 
+| |host| The hostname of the server on which the MongoDB is running |localhost
+| |port| The port used by the MongoDB server instance. |27017
+| |timeout| The timeout used by the MongoDB driver at the connection. (in ms) |2000
+| |acknoledgement| The value used to configure the acknowledgment for write operation (-1 / 0 / 1 / 2+) |1
+| _authentication_ | | | 
+| |username| The username used for the authentication with the MongoDB server. | 
+| |password| The password used for the authentication with the MongoDB server. | 
+| _storage_ | | | 
+| |database| The database used to store elements. | 
+| |collection| The collection which will contain the elements. | 
+
+|===============
+
+
+ For more information about the configuration property usage, you can refer to the official link:$$http://api.mongodb.org/java/2.10.1/com/mongodb/WriteConcern.html$$[MongoDB java driver documentation] 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-24-Portable_Serialization_For_Hot_Rod_With_Apache_Avro.adoc b/documentation/src/main/asciidoc/user_guide/chapter-24-Portable_Serialization_For_Hot_Rod_With_Apache_Avro.adoc
new file mode 100644
index 0000000..0ef2502
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-24-Portable_Serialization_For_Hot_Rod_With_Apache_Avro.adoc
@@ -0,0 +1,107 @@
+[[sid-68355061]]
+
+==  Portable Serialization For Hot Rod With Apache Avro
+
+[[sid-68355061_PortableSerializationForHotRodWithApacheAvro-Introduction]]
+
+
+=== Introduction
+
+ Starting with Infinispan 5.0, Hot Rod clients can be configured with a marshaller that produces plattform independent payloads using link:$$http://avro.apache.org/$$[Apache Avro] . This means that payloads generated by a Java, Avro-based, marshaller could be read by a Python, Avro-based, marshaller. When Hot Rod clients in other languages such as Python or Ruby become available, this will mean that for example, data stored via Java Hot Rod client will be readable by a Python Hot Rod client. 
+
+[[sid-68355061_PortableSerializationForHotRodWithApacheAvro-LanguagesSupported]]
+
+
+=== Languages Supported
+
+Avro currently supports providing portable serialization payloads for the following languages:
+
+
+* C
+
+
+* $$C++$$
+
+
+* Java
+
+
+* Python
+
+
+* Ruby
+
+So interoperability of payloads is limited to these languages. The choice of Avro over other existing portable serialization libraries (i.e. Google Protocol Buffers, Apache Thrift, MessagePack...etc) was done based languages supported, ease of use, and payload size.
+
+[[sid-68355061_PortableSerializationForHotRodWithApacheAvro-ObjectTypesSupported]]
+
+
+=== Object Types Supported
+
+Avro based marshaller currently supports basic type and collection marshalling:
+
+
+* Basic types include:
+
+
+* UTF-8 string
+
+
+* Integer
+
+
+* Long
+
+
+* Float
+
+
+* Double
+
+
+* Boolean
+
+
+* Byte Array
+
+
+* Collections composed of the basic types :
+
+
+* Arrays
+
+
+* Lists
+
+
+* Maps
+
+
+* Sets
+
+ Marshalling of complex objects is not supported because it's not fully solvable as some language don't support some concepts other languages offer. Instead, it is recommended that for any complex object marshalling requirements, users serialize these complex objects into byte arrays using portable serialization libraries such as link:$$http://code.google.com/apis/protocolbuffers/$$[Google Protocol Buffers] , link:$$http://incubator.apache.org/thrift/$$[Apache Thrift] , link:$$http://msgpack.org/$$[MessagePack] , or link:$$http://avro.apache.org/$$[Apache Avro] . Once the byte array has been created, simply pass it to the Hot Rod client API which will handle it accordingly. 
+
+Therefore, it's clear that users are free to use any portable serialization library to transform their complex objects into byte arrays, regardless of the fact that Infinispan uses Apache Avro for basic type and collection marshalling. The only limitation here is that the target language used to serialize complex objects needs to be amongst the languages that Apache Avro supports.
+
+ Short and Byte Java primitive types are not supported per se. Instead, clients should pass integers which will be encoded efficiently using link:$$http://lucene.apache.org/java/2_4_0/fileformats.html#VInt$$[variable-length] link:$$http://code.google.com/apis/protocolbuffers/docs/encoding.html#types$$[zig zag] coding. Primitive arrays not supported except byte arrays. Instead, use their object counter partners, i.e. Integer...etc. 
+
+[[sid-68355061_PortableSerializationForHotRodWithApacheAvro-JavaConfiguration]]
+
+
+=== Java Configuration
+
+ To configure a Java Hot Rod client with Avro marshaller, simply pass a infinispan.client.hotrod.marshaller property to the RemoteCacheManager constructor containing the value of org.infinispan.client.hotrod.marshall.ApacheAvroMarshaller . For example: 
+
+
+----
+Properties props = new Properties();
+props.put("infinispan.client.hotrod.marshaller",
+   "org.infinispan.client.hotrod.marshall.ApacheAvroMarshaller");
+RemoteCacheManager remoteCacheManager = new RemoteCacheManager(props);
+
+----
+
+Note however that if all you're gonna be using are Java Hot Rod clients, there's no need to configure Avro based marshaller. The default marshaller is capable of transforming any Serializable or Externalizable java object into a byte array in a quick and efficient manner.
+
+Please remember as well that when remote java clients are configured with the apache avro marshaller, the server's marshaller does not need changing. This is because the server does not make any attempt at unmarshalling the data that's been passed to it. Internally, it keeps the data as byte arrays.
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-25-The_Grouping_API.adoc b/documentation/src/main/asciidoc/user_guide/chapter-25-The_Grouping_API.adoc
new file mode 100644
index 0000000..f4bf05a
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-25-The_Grouping_API.adoc
@@ -0,0 +1,134 @@
+[[sid-68355063]]
+
+==  The Grouping API
+
+In some cases you may wish to co-locate a group of entries onto a particular node. In this, the group API will be useful for you.
+
+[[sid-68355063_TheGroupingAPI-Howdoesitwork%3F]]
+
+
+=== How does it work?
+
+Infinispan allocates each node a portion of the total hash space. Normally, when you store an entry, Infinispan will take a hash of the key, and store the entry on the node which owns that portion of the hash space. Infinispan always uses an algorithm to locate a key in the hash space, never allowing the node on which the entry is stored to be specified manually. This scheme allows any node to know which nodes owns a key, without having to distribute such ownership information. This reduces the overhead of Infinispan, but more importantly improves redundancy as there is no need to replicate the ownership information in case of node failure.
+
+ If you use the grouping API , then Infinispan will ignore the hash of the key when deciding which _node_ to store the entry on, and instead use a hash of the group. Infinispan still uses the hash of the key to store the entry on a node. When the group API is in use, it is important that every node can still compute, using an algorithm, the owner of every key. For this reason, the group cannot be specified manually. The group can either be intrinsic to the entry (generated by the key class) or extrinsic (generated by an external function). 
+
+[[sid-68355063_TheGroupingAPI-HowdoIusethegroupingAPI%3F]]
+
+
+=== How do I use the grouping API?
+
+First, you must enable groups. If you are configuring Infinispan programmatically, then call:
+
+
+----
+
+Configuration c = new ConfigurationBuilder().clustering().hash().groups().enabled().build();
+
+----
+
+Or, if you are using XML:
+
+
+----
+<clustering>
+  <hash>
+     <groups enabled="true" />
+  </hash>
+</clustering>
+
+----
+
+If you have control of the key class (you can alter the class definition, it's not part of an unmodifiable library), and the determination of the group is not an orthogonal concern to the key class, then we recommend you use an intrinsic group. The intrinsic group can be specified using the @Group annotation placed on the method. Let's take a look at an example:
+
+
+----
+
+class User {
+
+   ...
+   String office;
+   ...
+
+   int hashCode() {
+      // Defines the hash for the key, normally used to determine location
+      ...
+   }
+
+   // Override the location by specifying a group, all keys in the same
+   // group end up with the same owner
+   @Group
+   String getOffice() {
+      return office;
+   }
+
+}
+
+----
+
+
+[NOTE]
+==== 
+ The group must be a String . 
+
+
+==== 
+
+
+If you don't have control over the key class, or the determination of the group is an orthogonal concern to the key class, we recommend you use an extrinsic group. In extrinsic group is specified by implementing the Grouper interface, which has a single method computeGroup, which should return the group. Grouper acts as an interceptor, passing the previously computed value in. The group passed to the first Grouper will be that determined by @Group (if @Groupis defined). This allows you even greater control over the group when using an intrinsic group. For a grouper to be used when determining the group for a key, it's keyType must be assignable from the key being grouped.
+
+Let's take a look at an example of a Grouper:
+
+
+----
+
+public class KXGrouper implements Grouper<String> {
+
+   // A pattern that can extract from a "kX" (e.g. k1, k2) style key
+   // The pattern requires a String key, of length 2, where the first character is
+   // "k" and the second character is a digit. We take that digit, and perform
+   // modular arithmetic on it to assign it to group "1" or group "2".
+   private static Pattern kPattern = Pattern.compile("(^k)(<a>\\d</a>)$");
+
+    public String computeGroup(String key, String group) {
+        Matcher matcher = kPattern.matcher(key);
+        if (matcher.matches()) {
+            String g = Integer.parseInt(matcher.group(2)) % 2 + "";
+            return g;
+        } else
+            return null;
+    }
+
+    public Class<String> getKeyType() {
+        return String.class;
+    }
+
+}
+
+----
+
+Here we determine a simple grouper that can take the key class and extract from the group from the key using a pattern. We ignore any group information specified on the key class.
+
+You must register every grouper you wish to have used. If you are configuring Infinispan programmatically:
+
+
+----
+
+Configuration c = new ConfigurationBuilder().clustering().hash().groups().addGrouper(new KXGrouper()).build();
+
+----
+
+Or, if you are using XML:
+
+
+----
+<clustering>
+  <hash>
+     <groups enabled="true">
+        <grouper class="com.acme.KXGrouper" />
+     </groups>
+  </hash>
+</clustering>
+
+----
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-26-Infinispan_transactions.adoc b/documentation/src/main/asciidoc/user_guide/chapter-26-Infinispan_transactions.adoc
new file mode 100644
index 0000000..2960261
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-26-Infinispan_transactions.adoc
@@ -0,0 +1,265 @@
+[[sid-68355064]]
+
+==  Infinispan transactions
+
+[[sid-68355064_Infinispantransactions-JTASupport]]
+
+
+=== JTA Support
+
+Infinispan can be configured to use and to participate in JTA compliant transactions. Alternatively, if transaction support is disabled, it is equivalent to using autocommit in JDBC calls, where modifications are potentially replicated after every change (if replication is enabled).
+
+On every cache operation Infinispan does the following:
+
+ 1. Retrieves the current link:$$http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/transaction/Transaction.html$$[Transaction] associated with the thread 2. If not already done, registers link:$$http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/transaction/xa/XAResource.html$$[XAResource] with the transaction manager to be notified when a transaction commits or is rolled back. 
+
+ In order to do this, the cache has to be provided with a reference to the environment's link:$$http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/transaction/TransactionManager.html$$[TransactionManager] . This is usually done by configuring the cache with the class name of an implementation of the link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/transaction/lookup/TransactionManagerLookup.html$$[TransactionManagerLookup] interface. When the cache starts, it will create an instance of this class and invoke its getTransactionManager() method, which returns a reference to the TransactionManager. 
+
+Infinispan ships with several transaction manager lookup classes:
+
+
+*  link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/transaction/lookup/DummyTransactionManagerLookup.html$$[DummyTransactionManagerLookup] : This provides with a dummy transaction manager which should only be used for testing.  Being a dummy, this is not recommended for production use a it has some severe limitations to do with concurrent transactions and recovery. 
+
+
+*  link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/transaction/lookup/JBossStandaloneJTAManagerLookup.html$$[JBossStandaloneJTAManagerLookup] : If you're running Infinispan in a standalone environment, this should be your default choice for transaction manager. It's a fully fledged transaction manager based on link:$$http://www.jboss.org/jbosstm$$[JBoss Transactions] which overcomes all the deficiencies of the dummy transaction manager. 
+
+
+*  link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/transaction/lookup/GenericTransactionManagerLookup.html$$[GenericTransactionManagerLookup] : This is a lookup class that locate transaction managers in the most  popular Java EE application servers. If no transaction manager can be found, it defaults on the dummy transaction manager. 
+
+
+*  link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/transaction/lookup/JBossTransactionManagerLookup.html$$[JBossTransactionManagerLookup] : This lookup class locates the transaction manager running within a JBoss Application Server instance. 
+
+Once initialized, the TransactionManager can also be obtained from the Cache itself:
+
+
+----
+
+//the cache must have a transactionManagerLookupClass defined
+Cache cache = cacheManager.getCache();
+
+//equivalent with calling TransactionManagerLookup.getTransactionManager();
+TransactionManager tm = cache.getAdvancedCache().getTransactionManager();
+
+----
+
+[[sid-68355064_Infinispantransactions-Configuringtransactions]]
+
+
+=== Configuring transactions
+
+Transactions are being configured at cache level; bellow is a sample configuration:
+
+
+----
+
+<transaction 
+      transactionManagerLookupClass="org.infinispan.transaction.lookup.GenericTransactionManagerLookup"
+      transactionMode="TRANSACTIONAL"
+      lockingMode="OPTIMISTIC"/>
+
+----
+
+
+* transactionManagerLookupClass fully qualified class name of a class that looks up a reference to a javax.transaction.TransactionManager
+
+
+* transactionMode - configures whether the cache is transactional or not
+
+
+* lockingMode - configures whether the cache uses optimistic or pessimistic locking.
+
+ For more details on how two phase commit (2PC) is implemented in Infinispan and how locks are being acquired see the section below. All possible transactional settings are available in link:$$http://docs.jboss.org/infinispan/5.1/configdocs/$$[Configuration reference] 
+
+[[sid-68355064_Infinispantransactions-Transactionalmodes]]
+
+
+=== Transactional modes
+
+Starting with Infinispan 5.1 release a cache can accessed either transactionally or non-transactionally. The mixed access mode is no longer supported. There are several reasons for going this path, but one of them most important is a cleaner semantic on how concurrency is managed between multiple requestors for the same cache entry.
+
+By default, all Infinispan caches are non-transactional. A cache can be made transactional by changing the transactionMode attribute:
+
+
+----
+
+<namedCache name="transactional">
+  <transaction transactionMode="TRANSACTIONAL"/>
+</namedCache>
+
+----
+
+transactionMode can only take two values: TRANSACTIONAL and NON_TRANSACTIONAL; one can configure a transactional cache programatically as well:
+
+
+----
+
+Configuration c = new ConfigurationBuilder().transaction().transactionMode(TransactionMode.TRANSACTIONAL).build();
+assert c.transaction().transactionalCache();
+
+----
+
+
+[NOTE]
+==== 
+Do not forget to configure a TransactionManagerLookup for transactional caches.
+
+
+==== 
+
+
+Supported transaction models are optimistic and pessimistic. Optimistic model is an improvement over the old transaction model as it completely defers lock acquisition to transaction prepare time. New approach reduces lock acquisition duration and increases throughput which in turn avoids deadlocks significantly. In pessimistic model, cluster wide-locks are acquired on each write operation only being released after the transaction completed.
+
+[[sid-68355064_Infinispantransactions-OptimisticTransactions]]
+
+
+==== Optimistic Transactions
+
+With optimistic transactions locks are being acquired at transaction prepare time and are only being held up to the point the transaction commits (or rollbacks). This is different from the 5.0 default locking model where local locks are being acquire on writes and cluster locks are being acquired during prepare time.
+
+Optimistic transactions can be enabled in the configuration file:
+
+
+----
+
+<namedCache name="transactional">
+  <transaction transactionMode="TRANSACTIONAL" lockingMode="OPTIMISTIC"/>
+</namedCache>
+
+----
+
+or programatically:
+
+
+----
+
+Configuration c = new ConfigurationBuilder().transaction().lockingMode(LockingMode.OPTIMISTIC).build();
+assert c.transaction().lockingMode() == LockingMode.OPTIMISTIC;
+
+----
+
+
+[NOTE]
+==== 
+By default, a transactional cache is optimistic.
+
+
+==== 
+
+
+[[sid-68355064_Infinispantransactions-PessimisticTransactions]]
+
+
+==== Pessimistic Transactions
+
+From a lock acquisition perspective, pessimistic transactions obtain locks on keys at the time the key is written. E.g.
+
+
+----
+
+transactionManager.begin();
+cache.put(k1,v1); //k1 is locked
+cache.remove(k2); //k2 is locked when this returns
+transactionManager.commit();
+
+----
+
+When cache.put(k1,v1) returns k1 is locked and no other transaction running anywhere in the cluster can write to it. Reading k1 is still possible. The lock on k1 is released when the transaction completes (commits or rollbacks).
+
+Pessimistic transactions can be enabled in the configuration file:
+
+
+----
+
+<namedCache name="transactional"/>
+  <transaction transactionMode="TRANSACTIONAL" lockingMode="PESSIMISTIC"/>
+</namedCache>
+
+----
+
+or programatically:
+
+
+----
+
+Configuration c = new ConfigurationBuilder().transaction().lockingMode(LockingMode.PESSIMISTIC).build();
+assert c.transaction().lockingMode() == LockingMode.PESSIMISTIC;
+
+----
+
+[[sid-68355064_Infinispantransactions-Backwardcompatibility]]
+
+
+==== Backward compatibility
+
+The autoCommit attribute was added in order to assure backward compatibility. If a cache is transactional and autoCommit is enabled (defaults to true) then any call that is performed outside of a transaction's scope is transparently wrapped within a transaction. In other words Infinispan adds the logic for starting a transaction before the call and committing it after the call.
+
+Therefore if your code accesses a cache both transactionally and non-transactionally all you have to do when migrating to Infinispan 5.1 is mark the cache as transactional and enable autoCommit (that's actually enabled by default)
+
+The autoCommit feature can be managed through configuration:
+
+
+----
+
+<namedCache name="transactional">;
+  <transaction transactionMode="TRANSACTIONAL" autoCommit="true"/>
+</namedCache>
+
+----
+
+[[sid-68355064_Infinispantransactions-WhatdoIneedpessimisticoroptimistictransactions%3F]]
+
+
+==== What do I need - pessimistic or optimistic transactions?
+
+ From a use case perspective, optimistic transactions should be used when there is _not_ a lot of contention between multiple transactions running at the same time. That is because the optimistic transactions rollback if data has changed between the time it was read and the time it was committed (writeSkewCheck). 
+
+On the other hand, pessimistic transactions might be a better fit when there is high contention on the keys and transaction rollbacks are less desirable. Pessimistic transactions are more costly by their nature: each write operation potentially involves a RPC for lock acquisition.
+
+[[sid-68355064_Infinispantransactions-Deadlockdetection]]
+
+
+=== Deadlock detection
+
+ Deadlocks can significantly (up to one order of magnitude, see benchmarks) reduce the throughput of a system, especially when multiple transactions are operating agains the same key set. Deadlock detection is disabled by default, but can be enabled/configured per cache (i.e. under namedCache config element) by adding the following: 
+
+
+----
+<deadlockDetection enabled="true" spinDuration="1000"/>
+
+----
+
+ Some clues on when to enable deadlock detection. A high number of transaction rolling back due to link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/util/concurrent/TimeoutException.html$$[TimeoutException] is an indicator that this functionality might help. TimeoutException might be caused by other causes as well, but deadlocks will always result in this exception being thrown. Generally, when you have a high contention on a set of keys, deadlock detection may help. But the best way is not to guess the performance improvement but to benchmark and monitor it: you can have access to statistics (e.g. number of deadlocks detected) through JMX, as it is exposed via the DeadlockDetectingLockManager MBean. For more details on how deadlock detection works, benchmarks and design details refer to link:$$http://infinispan.blogspot.com/2009/07/increase-transactional-throughput-with.html$$[this] article. 
+
+Note: deadlock detection only runs on an a per cache basis: deadlocks that spread over two or more caches won't be detected.
+
+[[sid-68355064_Infinispantransactions-Transactionandexceptions]]
+
+
+=== Transaction and exceptions
+
+ If a link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/CacheException.html$$[CacheException] (or a subclass of it) is thrown by a cache method within the scope of a JTA transaction, then the transaction is automatically marked for rollback. 
+
+[[sid-68355064_Infinispantransactions-Transactionrecoveryonnodefailures]]
+
+
+=== Transaction recovery on node failures
+
+ Transaction recovery is discussed in link:$$http://community.jboss.org/docs/DOC-16646?uniqueTitle=false$$[this] document. 
+
+[[sid-68355064_Infinispantransactions-EnlistingSynchronization]]
+
+
+=== Enlisting Synchronization
+
+ By default Infinispan registers itself as a first class participant in distributed transactions through link:$$http://download.oracle.com/javaee/1.3/api/javax/transaction/xa/XAResource.html$$[XAResource] . There are situations where Infinispan is not required to be a participant in the transaction, but only to be notified by its lifecycle (prepare, complete): e.g. in the case Infinispan is used as a 2nd level cache in Hiberenate. 
+
+ Starting with 5.0  release, Infinispan allows transaction enlistment through link:$$http://download.oracle.com/javaee/1.3/api/javax/transaction/Synchronization.html$$[Synchronisation] . This can be enabled through the _useSynchronization_ attribute on the _transaction_ element: 
+
+
+----
+<transaction useSynchronization="true"/>
+
+----
+
+ link:$$http://download.oracle.com/javaee/1.3/api/javax/transaction/Synchronization.html$$[Synchronisation] s have the advantage that they allow TransactionManager to optimize 2PC with a 1PC where only one other resource is enlisted with that transaction ( link:$$http://docs.redhat.com/docs/en-US/JBoss_Enterprise_Web_Platform/5/html/Administration_And_Configuration_Guide/ch09s04.html$$[last resource commit optimization] ). E.g. Hibernate second level cache: if Infinispan registers itself with the TransactionManager as a link:$$http://download.oracle.com/javaee/1.3/api/javax/transaction/xa/XAResource.html$$[XAResource] than at commit time, the TransactionManager sees two link:$$http://download.oracle.com/javaee/1.3/api/javax/transaction/xa/XAResource.html$$[XAResource] (cache and database) and does not make this optimization. Having to coordinate between two resources it needs to write the tx log to disk. On the other hand, registering Infinispan as a link:$$http://download.oracle.com/javaee/1.3/api/javax/transaction/Synchronization.html$$[Synchronisation] makes the TransactionManager skip wrtting the log to the disk (performance improvement). 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-27-Load_Testing_Infinispan_Server_Modules.adoc b/documentation/src/main/asciidoc/user_guide/chapter-27-Load_Testing_Infinispan_Server_Modules.adoc
new file mode 100644
index 0000000..15f1d1b
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-27-Load_Testing_Infinispan_Server_Modules.adoc
@@ -0,0 +1,67 @@
+[[sid-68355066]]
+
+==  Load Testing Infinispan Server Modules
+
+ Infinispan comes with different server implementations that allow Infinispan to be accessed remotely. You can find an overview about these servers link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737048$$[here] . 
+
+ This wiki explains how to load test and benchmark these server implementations using link:$$http://grinder.sourceforge.net/$$[Grinder] , which is a Java load testing framework that makes it easy to run a distributed test using many load injector machines. 
+
+
+.  First of all, link:$$http://grinder.sourceforge.net/download.html$$[download Grinder version 3.4 or higher] and unzip it somewhere locally. 
+
+
+.  Next, link:$$http://www.jboss.org/infinispan/downloads.html$$[download] and unzip the Infinispan version that you want to be testing. Make sure you download the -all.zip distribution to run these tests. Note that although Infinispan REST server was included in 4.0, Memcached and Hot Rod servers are only included from 4.1 onwards. 
+
+
+.  Download Infinispan Grinder scripts and other material from link:$$http://github.com/galderz/infinispan-server-grinder/archives/master$$[this source repository] . 
+
+
+.  Next up, modify bin/setGrinderEnv.sh file to set correct environment paths. Primarily, you should be looking at setting the following properties correctly (The rest of properties not mentioned below can be left as they are) : 
+
+
+.  INFINISPAN_HOME : It should point to the location where Infinispan was unzipped. 
+
+
+.  GRINDER_HOME : It should point to where Grinder was unzipped. 
+
+
+.  GRINDER_PROPERTIES : It should point to the grinder.properties provided with the Infinispan Grinder scripts 
+
+
+.  SPYMEMCACHED_HOME : It should only be modified to point to Spymemcached Memcached client library if you're planning to load test Infinispan Memcached server. 
+
+
+.  It is time now to start the Infinispan server that you want to be testing. For detailed information on starting up a Hot Rod server, check link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737146$$[this wiki] . If you want to start the Hot Rod server quickly, the following command should do the job: 
+
+
+.  $INFINISPAN_HOME/bin/startServer.sh -r hotrod -l 0.0.0.0 
+
+
+. Finally, let's start the load test. Currently, a single load test exists which after a warmup phase, it does a certain amount of put/get calls on a pool of keys with a configurable distribution. By default, it executes 20% put operations and 80% get operations. So, if you're going to start the Hot Rod test, you'd simply do:
+
+
+.  cd infinispan-server-grinder/ 
+
+
+.  ./bin/startHotRodAgent.sh 
+
+
+.  Once the test has finished, the output can be located in infinispan-server-grinder/log/out-&lt;host&gt;-0.log and will show something like this at the bottom: 
+
+
+----
+         Tests    Errors   Mean Test   Test Time   TPS         
+                           Time (ms)   Standard                 
+                                       Deviation                
+                                       (ms)                     
+ 
+Test 1   25       0        13742.56    457.22      0.29      "Warmup (1000 ops)"
+Test 2   400136   0        1.92        2.55        4687.08   "Read (20000 ops per thread)"
+Test 3   99864    0        2.41        4.97        1169.78   "Put (20000 ops per thread)"
+ 
+Totals   500025   0        2.70        97.26       1952.38  
+
+----
+
+    The output is saying that it first run 25 threads, each sending 1000 operations in order to warm up the cache. Afterwards, each of these 25 threads send 20.000 operations making a total of 500.000 operations, out of which 400136 were get calls and 99864 were put calls, and the test here indicates what was the mean test time for each of these operations, including standard deviation and how many operations per second (TPS) were executed. In this case, 4686 get operations per second and 1169 put operations per second. 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-28-Using_Infinispan_as_JPA_Hibernate_Second_Level_Cache_Provider.adoc b/documentation/src/main/asciidoc/user_guide/chapter-28-Using_Infinispan_as_JPA_Hibernate_Second_Level_Cache_Provider.adoc
new file mode 100644
index 0000000..455dd1a
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-28-Using_Infinispan_as_JPA_Hibernate_Second_Level_Cache_Provider.adoc
@@ -0,0 +1,557 @@
+[[sid-68355067]]
+
+==  Using Infinispan as JPA-Hibernate Second Level Cache Provider
+
+[[sid-68355067_UsingInfinispanasJPA-HibernateSecondLevelCacheProvider-Overview]]
+
+
+=== Overview
+
+ Following some of the principles set out by Brian Stansberry in link:$$http://community.jboss.org/docs/14247$$[Using JBoss Cache 3 as a Hibernate 3.5 Second Level Cache] and taking in account improvements introduced by Infinispan, an Infinispan JPA/Hibernate second level cache provider has been developed. This wiki explains how to configure JPA/Hibernate to use the Infinispan and for those keen on lower level details, the key design decisions made and differences with previous JBoss Cache based cache providers. 
+
+ If you're unfamiliar with JPA/Hibernate Second Level Caching, I'd suggest you to read Chapter 2.1 in link:$$http://www.jboss.org/jbossclustering/docs/hibernate-jbosscache-guide-3.pdf$$[this guide] which explains the different types of data that can be cached. 
+
+
+[NOTE]
+.On Caching
+==== 
+ Query result caching, or entity caching, _may or may not improve_ application performance. Be sure to benchmark your application with and without caching. 
+
+
+==== 
+
+
+[[sid-68355067_UsingInfinispanasJPA-HibernateSecondLevelCacheProvider-Configuration]]
+
+
+=== Configuration
+
+1. First of all, to enable JPA/Hibernate second level cache with query result caching enabled, add either of the following:
+
+
+----
+<!-- If using JPA, add to your persistence.xml -->
+<property name="hibernate.cache.use_second_level_cache" value="true" />
+<property name="hibernate.cache.use_query_cache" value="true" />
+
+----
+
+
+----
+<!-- If using Hibernate, add to your hibernate.cfg.xml -->
+<property name="hibernate.cache.use_second_level_cache">true</property>
+<property name="hibernate.cache.use_query_cache">true</property>
+
+----
+
+2. Now, configure the Infinispan cache region factory using one of the two options below:
+
+• If the Infinispan CacheManager instance happens to be bound to JNDI select JndiInfinispanRegionFactory as the cacheregion factory and add the cache manager's JNDI name:
+
+
+----
+<!-- If using JPA, add to your persistence.xml -->
+<property name="hibernate.cache.region.factory_class" value="org.hibernate.cache.infinispan.JndiInfinispanRegionFactory" />
+<property name="hibernate.cache.infinispan.cachemanager" value="java:CacheManager" />
+
+----
+
+
+----
+<!-- If using Hibernate, add to your hibernate.cfg.xml -->
+<property name="hibernate.cache.region.factory_class">org.hibernate.cache.infinispan.JndiInfinispanRegionFactory</property>
+<property name="hibernate.cache.infinispan.cachemanager">java:CacheManager/entity</property>
+
+----
+
+
+[NOTE]
+.JBoss Application Server
+==== 
+ JBoss Application Server 6 and 7 deploy a shared Infinispan cache manager that can be used by all services, so when trying to configure applications with Infinispan second level cache, you should use the JNDI name for the cache manager responsible for the second level cache. By default, this is "java:CacheManager/entity". In any other application server, you can deploy your own cache manager and link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=5832910$$[bind the CacheManager to JNDI] , but in this cases it's generally preferred that the following method is used. 
+
+
+==== 
+
+
+ • If running JPA/Hibernate and Infinispan standalone or within third party Application Server, select the _InfinispanRegionFactory_ as the cache region factory: 
+
+
+----
+<!-- If using JPA, add to your persistence.xml -->
+<property name="hibernate.cache.region.factory_class" value="org.hibernate.cache.infinispan.InfinispanRegionFactory"/>
+
+----
+
+
+----
+<!-- If using Hibernate, add to your hibernate.cfg.xml -->
+<property name="hibernate.cache.region.factory_class">org.hibernate.cache.infinispan.InfinispanRegionFactory</property>
+
+----
+
+ This is all the configuration you need to have JPA/Hibernate use Infinispan as cache provider with the default settings. You will still need to define which entities and queries need to be cached as defined in the Hibernate reference documentation, but that configuration aspect is not peculiar to Infinispan. This default configuration should suit the majority of use cases but sometimes, further configuration is required and to help with such situations, please check the following section where more advanced settings are discussed. 
+
+[[sid-68355067_UsingInfinispanasJPA-HibernateSecondLevelCacheProvider-DefaultConfigurationExplained]]
+
+
+=== Default Configuration Explained
+
+The aim of this section is to explain the default settings for each of the different global data type (entity, collection, query and timestamps) caches, why these were chosen and what are the available alternatives.
+
+[[sid-68355067_UsingInfinispanasJPA-HibernateSecondLevelCacheProvider-DefaultsforEntity%2FCollectionCaching]]
+
+
+==== Defaults for Entity/Collection Caching
+
+
+*  By default, for all entities and collections, whenever an new _entity or collection is read from database_ and needs to be cached, _it's only cached locally_ in order to reduce intra-cluster traffic. This option cannot be changed. 
+
+
+*  By default, all _entities and collections are configured to use a synchronous invalidation_ as clustering mode. This means that when an entity is updated, the updated cache will send a message to the other members of the cluster telling them that the entity has been modified. Upon receipt of this message, the other nodes will remove this data from their local cache, if it was stored there. This option can be changed to use replication by configuring entities or collections to use "replicated-entity" cache but it's generally not a recommended choice. 
+
+
+*  By default, all _entities and collections have initial state transfer disabled_ since there's no need for it. It's not recommended that this is enabled. 
+
+
+*  By default, _$$entities and collections are configured to use READ_COMMITTED$$_ as cache isolation level. It would only make sure to configure REPEATABLE_READ if the application evicts/clears entities from the Hibernate Session and then expects to repeatably re-read them in the same transaction. Otherwise, the Session's internal cache provides repeatable-read semantics. If you really need to use REPEATABLE_READ, you can simply configure entities or collections to use "entity-repeatable" cache. 
+
+
+* By default, entities and collections are configured with the following eviction settings:
+
+
+* Eviction wake up interval is 5 seconds.
+
+
+* Max number of entries are 10.000
+
+
+* Max idle time before expiration is 100 seconds
+
+       You can change these settings on a per entity or collection basis or per individual entity or collection type.
+
+       More information in the "Advanced Configuration" section below.
+
+
+*  By default _entites and collections are configured with lazy deserialization_ which helps deserialization when entities or collections are stored in isolated deployments. If you're sure you'll never deploy your entities or collections in classloader isolated deployment archives, you can disable this setting. 
+
+[[sid-68355067_UsingInfinispanasJPA-HibernateSecondLevelCacheProvider-DefaultsforQueryCaching]]
+
+
+==== Defaults for Query Caching
+
+
+*  By default, query cache is configured so that _queries are only cached locally_ . Alternatively, you can configure query caching to use replication by selecting the "replicated-query" as query cache name. However, replication for query cache only makes sense if, and only if, all of this conditions are true: 
+
+
+* Performing the query is quite expensive.
+
+
+* The same query is very likely to be repeatedly executed on different cluster nodes.
+
+
+* The query is unlikely to be invalidated out of the cache (Note: Hibernate must aggressively invalidate query results from the cache any time any instance of one of the entity types targeted by the query. All such query results are invalidated, even if the change made to the specific entity instance would not have affected the query result)
+
+
+*  By default, _query cache_ uses the _same cache isolation levels and eviction/expiration settings as for entities/collections_ . 
+
+
+*  By default, _query cache has initial state transfer disabled_ . It is not recommended that this is enabled. 
+
+[[sid-68355067_UsingInfinispanasJPA-HibernateSecondLevelCacheProvider-DefaultsforTimestampsCache]]
+
+
+==== Defaults for Timestamps Cache
+
+
+*  By default, the _timestamps cache is configured with asynchronous replication_ as clustering mode. Local or invalidated cluster modes are not allowed, since all cluster nodes must store all timestamps. As a result, _no eviction/expiration is allowed for timestamp caches either_ . 
+
+
+*  By default, the _timestamps cache is configured with a cluster cache loader (in Hibernate 3.6.0 or earlier it had state transfer enabled)_ so that joining nodes can retrieve all timestamps. You shouldn't attempt to disable the cluster cache loader for the timestamps cache. 
+
+[[sid-68355067_UsingInfinispanasJPA-HibernateSecondLevelCacheProvider-JTATransactionsConfiguration]]
+
+
+=== JTA Transactions Configuration
+
+It is highly recommended that Hibernate is configured with JTA transactions so that both Hibernate and Infinispan cooperate within the same transaction and the interaction works as expected.
+
+Otherwise, if Hibernate is configured for example with JDBC transactions, Hibernate will create a Transaction instance via java.sql.Connection and Infinispan will create a transaction via whatever TransactionManager returned by hibernate.transaction.manager_lookup_class. If hibernate.transaction.manager_lookup_class has not been populated, it will default on the dummy transaction manager. So, any work on the 2nd level cache will be done under a different transaction to the one used to commit the stuff to the database via Hibernate. In other words, your operations on the database and the 2LC are not treated as a single unit. Risks here include failures to update the 2LC leaving it with stale data while the database committed data correctly. It has also been observed that under some circumstances where JTA was not used, commit/rollbacks are not propagated to Infinispan.
+
+To sum up, if you configure Hibernate with Infinispan, apply the following changes to your configuration file:
+
+ 1. Unless your application uses JPA, you need to select the correct Hibernate transaction factory via the property _$$hibernate.transaction.factory_class$$_ : 
+
+
+* If you're running within an application server, it's recommended that you use:
+
+
+----
+<!-- If using JPA, add to your persistence.xml -->
+<property name="hibernate.transaction.factory_class" value="org.hibernate.transaction.CMTTransactionFactory"/>
+
+----
+
+
+----
+<!-- If using Hibernate, add to your hibernate.cfg.xml -->
+<property name="hibernate.transaction.factory_class">org.hibernate.transaction.CMTTransactionFactory</property>
+
+----
+
+
+* If you're running in a standalone environment and you wanna enable JTA transaction factory, use:
+
+
+----
+<!-- If using JPA, add to your persistence.xml -->
+<property name="hibernate.transaction.factory_class" value="org.hibernate.transaction.JTATransactionFactory"/>
+
+----
+
+
+----
+<!-- If using Hibernate, add to your hibernate.cfg.xml -->
+<property name="hibernate.transaction.factory_class">org.hibernate.transaction.JTATransactionFactory</property>
+
+----
+
+The reason why JPA does not require a transaction factory class to be set up is because the entity manager already sets it to a variant of CMTTransactionFactory.
+
+2. Select the correct Hibernate transaction manager lookup:
+
+
+*  If you're running within an application server, select the appropriate lookup class according to link:$$http://docs.jboss.org/hibernate/core/3.3/reference/en/html/session-configuration.html#configuration-optional-transactionstrategy$$["JTA Transaction Managers" table] . 
+
+For Example if you were running with the JBoss Application Server you would set:
+
+
+----
+ <!-- If using JPA, add to your persistence.xml -->
+<property name="hibernate.transaction.manager_lookup_class" 
+   value="org.hibernate.transaction.JBossTransactionManagerLookup"/>
+----
+
+
+----
+<!-- If using Hibernate, add to your hibernate.cfg.xml -->
+<property name="hibernate.transaction.manager_lookup_class">
+   org.hibernate.transaction.JBossTransactionManagerLookup
+</property>
+----
+
+
+*  If you are running standalone and you want to add a JTA transaction manager lookup, things get a bit more complicated. Due to a current limitation, Hibernate does not support injecting a JTA TransactionManager or JTA UserTransaction that are not bound to JNDI. In other words, if you want to use JTA, Hibernate expects your TransactionManager to be bound to JNDI and it also expects that UserTransaction instances are retrieved from JNDI. This means that in an standalone environment, you need to add some code that binds your TransactionManager and UserTransaction to JNDI. With this in mind and with the help of one of our community contributors, we've created an example that does just that: link:$$http://anonsvn.jboss.org/repos/hibernate/core/trunk/cache-infinispan/src/test/java/org/hibernate/test/cache/infinispan/tm/JBossStandaloneJtaExampleTest.java$$[JBoss Standalone JTA Example] . Once you have the code in place, it's just a matter of selecting the correct Hibernate transaction manager lookup class, based on the JNDI names given. If you take _JBossStandaloneJtaExample_ as an example, you simply have to add: 
+
+
+----
+ <!-- If using JPA, add to your persistence.xml -->
+<property name="hibernate.transaction.manager_lookup_class" 
+   value="org.hibernate.transaction.JBossTransactionManagerLookup"/>
+----
+
+
+----
+<!-- If using Hibernate, add to your hibernate.cfg.xml -->
+<property name="hibernate.transaction.manager_lookup_class">
+   org.hibernate.transaction.JBossTransactionManagerLookup
+</property>
+----
+
+ As you probably have noted through this section, there wasn't a single mention of the need to configure link:$$http://docs.jboss.org/infinispan/4.0/apidocs/config.html#ce_default_transaction$$[Infinispan's transaction manager lookup] and there's a good reason for that. Basically, the code within Infinispan cache provider takes the transaction manager that has been configured at the Hibernate level and uses that. Otherwise, if no Hibernate transaction manager lookup class has been defined, Infinispan uses a default dummy transaction manager. 
+
+ Since Hibernate 4.0, the way Infinispan hooks into the transaction manager can be configured. By default, since 4.0, Infinispan interacts with the transaction manager as an JTA synchronization, resulting link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737108$$[in a faster interaction with the 2LC thanks to some key optimisations that the transaction manager can apply] . However if desired, users can configure Infinispan to act as an XA resource (just like it did in 3.6 and earlier) by disabling the use of the synchronization. For example: 
+
+
+----
+<!-- If using JPA, add to your persistence.xml: -->
+<property name="hibernate.cache.infinispan.use_synchronization"  value="false"/>
+----
+
+
+----
+<!-- If using Hibernate, add to your hibernate.cfg.xml: -->
+<property name="hibernate.cache.infinispan.use_synchronization">
+   false
+</property>
+----
+
+[[sid-68355067_UsingInfinispanasJPA-HibernateSecondLevelCacheProvider-StandaloneJTAforJPA%2FHibernateusingInfinispanas2LC]]
+
+
+==== Standalone JTA for JPA/Hibernate using Infinispan as 2LC
+
+ The JBoss standalone JTA example referred to in the previous section is inspired by the great work of Guenther Demetz, one of the members of the Infinispan community, who wrote an link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737126$$[impressive wiki explaining how to set up standalone JTA with different transaction managers running outside of an EE server, and how to get this to work with an Infinispan backed JPA/Hibernate application] . 
+
+[[sid-68355067_UsingInfinispanasJPA-HibernateSecondLevelCacheProvider-AdvancedConfiguration]]
+
+
+=== Advanced Configuration
+
+Infinispan has the capability of exposing statistics via JMX and since Hibernate 3.5.0.Beta4, you can enable such statistics from the Hibernate/JPA configuration file. By default, Infinispan statistics are turned off but when these are disabled via the following method, statistics for the Infinispan Cache Manager and all the managed caches (entity, collection,...etc) are enabled:
+
+
+----
+<!-- If using JPA, add to your persistence.xml -->
+<property name="hibernate.cache.infinispan.statistics" value="true"/>
+----
+
+
+----
+<!-- If using Hibernate, add to your hibernate.cfg.xml: -->
+<property name="hibernate.cache.infinispan.statistics">true</property>
+----
+
+The Infinispan cache provider jar file contains an Infinispan configuration file, which is the one used by default when configuring the Infinispan standalone cache region factory. This file contains default cache configurations for all Hibernate data types that should suit the majority of use cases. However, if you want to use a different configuration file, you can configure it via the following property:
+
+
+----
+<!-- If using JPA, add to your persistence.xml -->
+<property name="hibernate.cache.infinispan.cfg" 
+   value="/home/infinispan/cacheprovider-configs.xml"/>
+----
+
+
+----
+<!-- If using Hibernate, add to your hibernate.cfg.xml: -->
+<property name="hibernate.cache.infinispan.cfg">
+   /home/infinispan/cacheprovider-configs.xml
+</property>
+----
+
+ For each Hibernate cache data types, Infinispan cache region factory has defined a default cache name to look up in either the default, or the user defined, Infinispan cache configuration file. These default values can be found in the link:$$http://docs.jboss.org/hibernate/core/4.0/javadocs/constant-values.html#org.hibernate.cache.infinispan.InfinispanRegionFactory.INFINISPAN_CONFIG_RESOURCE_PROP$$[Infinispan cache provider javadoc] . You can change these cache names using the following properties: 
+
+
+----
+<!-- If using JPA, add to your persistence.xml: -->
+<property name="hibernate.cache.infinispan.entity.cfg" 
+   value="custom-entity"/>
+<property name="hibernate.cache.infinispan.collection.cfg" 
+   value="custom-collection"/>
+<property name="hibernate.cache.infinispan.query.cfg" 
+   value="custom-collection"/>
+<property name="hibernate.cache.infinispan.timestamp.cfg" 
+   value="custom-timestamp"/>
+----
+
+
+----
+<!-- If using Hibernate, add to your hibernate.cfg.xml -->
+<property name="hibernate.cache.infinispan.entity.cfg">
+   custom-entity
+</property>
+<property name="hibernate.cache.infinispan.collection.cfg">
+   custom-collection
+</property>
+<property name="hibernate.cache.infinispan.query.cfg">
+   custom-collection
+</property>
+<property name="hibernate.cache.infinispan.timestamp.cfg">
+   custom-timestamp
+</property>
+----
+
+One of the key improvements brought in by Infinispan is the fact that cache instances are more lightweight than they used to be in JBoss Cache. This has enabled a radical change in the way entity/collection type cache management works. With the Infinispan cache provider, each entity/collection type gets each own cache instance, whereas in old JBoss Cache based cache providers, all entity/collection types would be sharing the same cache instance. As a result of this, locking issues related to updating different entity/collection types concurrently are avoided completely.
+
+This also has an important bearing on the meaning of hibernate.cache.infinispan.entity.cfg and hibernate.cache.infinispan.collection.cfg properties. These properties define the template cache name that should be used for all entity/collection data types. So, with the above hibernate.cache.infinispan.entity.cfg configuration, when a region needs to be created for entity com.acme.Person, the cache instance to be assigned to this entity will be based on a "custom-entity" named cache.
+
+On top of that, this finer grained cache definition enables users to define cache settings on a per entity/collection basis. For example:
+
+
+----
+<!-- If using JPA, add to your persistence.xml -->
+<property name="hibernate.cache.infinispan.com.acme.Person.cfg" 
+   value="person-entity"/>
+<property name="hibernate.cache.infinispan.com.acme.Person.addresses.cfg" 
+   value="addresses-collection"/>
+----
+
+
+----
+<!-- If using Hibernate, add to your hibernate.cfg.xml -->
+<property name="hibernate.cache.infinispan.com.acme.Person.cfg">
+   person-entity
+</property>
+<property name="hibernate.cache.infinispan.com.acme.Person.addresses.cfg">
+   addresses-collection
+</property>
+----
+
+Here, we're configuring the Infinispan cache provider so that for com.acme.Person entity type, the cache instance assigned will be based on a "person-entity" named cache, and for com.acme.Person.addresses collection type, the cache instance assigned will be based on a "addresses-collection" named cache. If either of these two named caches did not exist in the Infinispan cache configuration file, the cache provider would create a cache instance for com.acme.Person entity and com.acme.Person.addresses collection based on the default cache in the configuration file.
+
+Furthermore, thanks to the excellent feedback from the Infinispan community and in particular, Brian Stansberry, we've decided to allow users to define the most commonly tweaked Infinispan cache parameters via hibernate.cfg.xml or persistence.xml, for example eviction/expiration settings. So, with the Infinispan cache provider, you can configure eviction/expiration this way:
+
+
+----
+<!-- If using JPA, add to your persistence.xml -->
+<property name="hibernate.cache.infinispan.entity.eviction.strategy" 
+   value= "LRU"/>
+<property name="hibernate.cache.infinispan.entity.eviction.wake_up_interval" 
+   value= "2000"/>
+<property name="hibernate.cache.infinispan.entity.eviction.max_entries" 
+   value= "5000"/>
+<property name="hibernate.cache.infinispan.entity.expiration.lifespan" 
+   value= "60000"/>
+<property name="hibernate.cache.infinispan.entity.expiration.max_idle" 
+   value= "30000"/>
+----
+
+
+----
+<!-- If using Hibernate, add to your hibernate.cfg.xml -->
+<property name="hibernate.cache.infinispan.entity.eviction.strategy">
+   LRU
+</property>
+<property name="hibernate.cache.infinispan.entity.eviction.wake_up_interval">
+   2000
+</property>
+<property name="hibernate.cache.infinispan.entity.eviction.max_entries">
+   5000
+</property>
+<property name="hibernate.cache.infinispan.entity.expiration.lifespan">
+   60000
+</property>
+<property name="hibernate.cache.infinispan.entity.expiration.max_idle">
+   30000
+</property>
+----
+
+With the above configuration, you're overriding whatever eviction/expiration settings were defined for the default entity cache name in the Infinispan cache configuration used, regardless of whether it's the default one or user defined. More specifically, we're defining the following:
+
+
+* All entities to use LRU eviction strategy
+
+
+* The eviction thread to wake up every 2000 milliseconds
+
+
+* The maximum number of entities for each entity type to be 5000 entries
+
+
+* The lifespan of each entity instance to be 600000 milliseconds
+
+
+* The maximum idle time for each entity instance to be 30000
+
+You can also override eviction/expiration settings on a per entity/collection type basis in such way that the overriden settings only afftect that particular entity (i.e. com.acme.Person) or collection type (i.e. com.acme.Person.addresses). For example:
+
+
+----
+<!-- If using JPA, add to your persistence.xml -->
+<property name="hibernate.cache.infinispan.com.acme.Person.eviction.strategy" 
+   value= "FIFO"/>
+<property name="hibernate.cache.infinispan.com.acme.Person.eviction.wake_up_interval" 
+   value= "2500"/>
+<property name="hibernate.cache.infinispan.com.acme.Person.eviction.max_entries" 
+   value= "5500"/>
+<property name="hibernate.cache.infinispan.com.acme.Person.expiration.lifespan" 
+   value= "65000"/>
+<property name="hibernate.cache.infinispan.com.acme.Person.expiration.max_idle" 
+   value= "35000"/>
+----
+
+
+----
+<!-- If using Hibernate, add to your hibernate.cfg.xml -->
+<property name="hibernate.cache.infinispan.com.acme.Person.eviction.strategy">
+   FIFO
+</property>
+<property name="hibernate.cache.infinispan.com.acme.Person.eviction.wake_up_interval">
+   2500
+</property>
+<property name="hibernate.cache.infinispan.com.acme.Person.eviction.max_entries">
+   5500
+</property>
+<property name="hibernate.cache.infinispan.com.acme.Person.expiration.lifespan">
+   65000
+</property>
+<property name="hibernate.cache.infinispan.com.acme.Person.expiration.max_idle">
+   35000
+</property>
+----
+
+ The aim of these configuration capabilities is to reduce the number of files needed to modify in order to define the most commonly tweaked parameters. So, by enabling eviction/expiration configuration on a per generic Hibernate data type or particular entity/collection type via hibernate.cfg.xml or persistence.xml, users don't have to touch to Infinispan's cache configuration file any more. We believe users will like this approach and so, if you there are any other Infinispan parameters that you often tweak and these cannot be configured via hibernate.cfg.xml or persistence.xml, please let the Infinispan team know by sending an email to infinispan-dev@lists.jboss.org . 
+
+Please note that query/timestamp caches work the same way they did with JBoss Cache based cache providers. In other words, there's a query cache instance and timestamp cache instance shared by all. It's worth noting that eviction/expiration settings are allowed for query cache but not for timestamp cache. So configuring an eviction strategy other than NONE for timestamp cache would result in a failure to start up.
+
+Finally, from Hibernate 3.5.4 and 3.6 onwards, queries with specific cache region names are stored under matching cache instances. This means that you can now set query cache region specific settings. For example, assuming you had a query like this:
+
+
+----
+Query query = session.createQuery(
+  "select account.branch from Account as account where account.holder = ?");
+query.setCacheable(true);
+query.setCacheRegion("AccountRegion");
+
+----
+
+The query would be stored under "AccountRegion" cache instance and users could control settings in similar fashion to what was done with entities and collections. So, for example, you could define specific eviction settings for this particular query region doing something like this:
+
+
+----
+<!-- If using JPA, add to your persistence.xml -->
+<property name="hibernate.cache.infinispan.AccountRegion.eviction.strategy" 
+   value= "FIFO"/>
+<property name="hibernate.cache.infinispan.AccountRegion.eviction.wake_up_interval" 
+   value= "10000"/>
+----
+
+
+----
+<!-- If using Hibernate, add to your hibernate.cfg.xml -->
+<property name="hibernate.cache.infinispan.AccountRegion.eviction.strategy">
+   FIFO
+</property>
+<property name="hibernate.cache.infinispan.AccountRegion.eviction.wake_up_interval">
+   10000
+</property>
+----
+
+[[sid-68355067_UsingInfinispanasJPA-HibernateSecondLevelCacheProvider-IntegrationwithJBossApplicationServer]]
+
+
+=== Integration with JBoss Application Server
+
+ In JBoss Application Server 7, Infinispan is the default second level cache provider and you can find details about its configuration link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=8094254$$[the AS7 JPA reference guide] . 
+
+Infinispan based Hibernate 2LC was developed as part of Hibernate 3.5 release and so it currently only works within AS 6 or higher. Hibernate 3.5 is not designed to work with AS/EAP 5.x or lower. To be able to run Infinispan based Hibernate 2LC in a lower AS version such as 5.1, the Infinispan 2LC module would require porting to Hibernate 3.3.
+
+ Recently, William Decoste has helped migrate the Infinispan 2LC module to Hibernate 3.3, and link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737057$$[in this wiki] , he explains how to integrate Infinispan Hibernate 2LC with JBoss AS/EAP 5.x. 
+
+[[sid-68355067_UsingInfinispanasJPA-HibernateSecondLevelCacheProvider-UsingInfinispanasremoteSecondLevelCache%3F]]
+
+
+=== Using Infinispan as remote Second Level Cache?
+
+ Lately, several questions ( link:$$http://community.jboss.org/message/575814#575814$$[here] &amp; link:$$http://community.jboss.org/message/585841#585841$$[here] ) have appeared in the Infinispan user forums asking whether it'd be possible to have an Infinispan second level cache that instead of living in the same JVM as the Hibernate code, it resides in a remote server, i.e. an Infinispan Hot Rod server. It's important to understand that trying to set up second level cache in this way is generally not a good idea for the following reasons: 
+
+
+* The purpose of a JPA/Hibernate second level cache is to store entities/collections recently retrieved from database or to maintain results of recent queries. So, part of the aim of the second level cache is to have data accessible locally rather than having to go to the database to retrieve it everytime this is needed. Hence, if you decide to set the second level cache to be remote as well, you're losing one of the key advantages of the second level cache: the fact that the cache is local to the code that requires it.
+
+
+* Setting a remote second level cache can have a negative impact in the overall performance of your application because it means that cache misses require accessing a remote location to verify whether a particular entity/collection/query is cached. With a local second level cache however, these misses are resolved locally and so they are much faster to execute than with a remote second level cache.
+
+There are however some edge cases where it might make sense to have a remote second level cache, for example:
+
+
+* You are having memory issues in the JVM where JPA/Hibernate code and the second level cache is running. Off loading the second level cache to remote Hot Rod servers could be an interesting way to separate systems and allow you find the culprit of the memory issues more easily.
+
+
+* Your application layer cannot be clustered but you still want to run multiple application layer nodes. In this case, you can't have multiple local second level cache instances running because they won't be able to invalidate each other for example when data in the second level cache is updated. In this case, having a remote second level cache could be a way out to make sure your second level cache is always in a consistent state, will all nodes in the application layer pointing to it.
+
+
+* Rather than having the second level cache in a remote server, you want to simply keep the cache in a separate VM still within the same machine. In this case you would still have the additional overhead of talking across to another JVM, but it wouldn't have the latency of across a network. The benefit of doing this is that:
+
+
+* Size the cache separate from the application, since the cache and the application server have very different memory profiles. One has lots of short lived objects, and the other could have lots of long lived objects.
+
+
+*  To pin the cache and the application server onto different CPU cores (using _numactl_ ), and even pin them to different physically memory based on the NUMA nodes. 
+
+[[sid-68355067_UsingInfinispanasJPA-HibernateSecondLevelCacheProvider-FrequentlyAskedQuestions]]
+
+
+=== Frequently Asked Questions
+
+ To find out more please go to the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=5832912$$[Hibernate 2nd level cache  section] in the <<sid-68354942,Technical FAQ wiki>> . 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-29-Default_Values_For_Property_Based_Attributes.adoc b/documentation/src/main/asciidoc/user_guide/chapter-29-Default_Values_For_Property_Based_Attributes.adoc
new file mode 100644
index 0000000..b232a10
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-29-Default_Values_For_Property_Based_Attributes.adoc
@@ -0,0 +1,50 @@
+[[sid-68355069]]
+
+==  Default Values For Property Based Attributes
+
+ The aim of this article is to complement the link:$$http://docs.jboss.org/infinispan/5.1/configdocs$$[configuration reference] documentation with information on default values that could not be automatically generated. Please find below the name of the XML elements and their corresponding property default values: 
+
+[[sid-68355069_DefaultValuesForPropertyBasedAttributes-asyncListenerExecutor]]
+
+
+=== asyncListenerExecutor
+
+
+* maxThreads = 1
+
+
+* threadNamePrefix = "notification-thread"
+
+[[sid-68355069_DefaultValuesForPropertyBasedAttributes-asyncTransportExecutor]]
+
+
+=== asyncTransportExecutor
+
+
+* maxThreads = 25
+
+
+* threadNamePrefix = "transport-thread"
+
+[[sid-68355069_DefaultValuesForPropertyBasedAttributes-evictionScheduledExecutor]]
+
+
+=== evictionScheduledExecutor
+
+
+* maxThreads = 1 (cannot be changed)
+
+
+* threadNamePrefix = "eviction-thread"
+
+[[sid-68355069_DefaultValuesForPropertyBasedAttributes-replicationQueueScheduledExecutor]]
+
+
+=== replicationQueueScheduledExecutor
+
+
+* maxThreads = 1 (cannot be changed)
+
+
+* threadNamePrefix = "replicationQueue-thread"
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-3-New_in_Infinispan_5_0_0.adoc b/documentation/src/main/asciidoc/user_guide/chapter-3-New_in_Infinispan_5_0_0.adoc
index 12a6ec2..5b81d96 100644
--- a/documentation/src/main/asciidoc/user_guide/chapter-3-New_in_Infinispan_5_0_0.adoc
+++ b/documentation/src/main/asciidoc/user_guide/chapter-3-New_in_Infinispan_5_0_0.adoc
@@ -1,9 +1,9 @@
-[[sid-8093923_UserGuide-NewinInfinispan5.0.0]]
+[[sid-68355028_UserGuide-NewinInfinispan5.0.0]]
 
 ==  New in Infinispan 5.0.0
 
 
-.  <<sid-8093955,Generating keys mapped to specific cluster nodes>> 
+.  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737123$$[Generating keys mapped to specific cluster nodes] 
 
 
 .  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737105$$[Portable Serialization for Hot Rod with Apache Avro] 
@@ -15,7 +15,10 @@
 .  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737134$$[Distributed Executors Framework] 
 
 
-.  <<sid-8093926,Fluent Programmatic Configuration>> 
+.  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=59146687$$[MapReduce Framework] 
+
+
+.  <<sid-68355030,Fluent Programmatic Configuration>> 
 
 
 .  link:$$http://docs.jboss.org/infinispan/5.0/apidocs/config.html$$[Configuration Reference] 
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-30-Running_Infinispan_on_Amazon_Web_Services.adoc b/documentation/src/main/asciidoc/user_guide/chapter-30-Running_Infinispan_on_Amazon_Web_Services.adoc
new file mode 100644
index 0000000..011e7a6
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-30-Running_Infinispan_on_Amazon_Web_Services.adoc
@@ -0,0 +1,158 @@
+[[sid-68355070]]
+
+==  Running Infinispan on Amazon Web Services
+
+Infinispan can be used on the Amazon Web Service (AWS) platform and similar cloud based environment in several ways. As Infinispan uses JGroups as the underlying communication technology, the majority of the configuration work is done JGroups. The default auto discovery won't work on EC2 as multicast is not allowed, but JGroups provides several other discovery protocols so we only have to choose one.
+
+[[sid-68355070_RunningInfinispanonAmazonWebServices-TCPPing%2CGossipRouter%2CS3PING]]
+
+
+=== TCPPing, GossipRouter, S3_PING
+
+ The TCPPing approach contains a static list of the IP address of each member of the cluster in the JGroups configuration file. While this works it doesn't really help when cluster nodes are dynamically added to the cluster. See link:$$http://community.jboss.org/wiki/JGroupsTCPPING$$[] for more information about TCPPing. 
+
+.Sample TCPPing configuration
+
+==== 
+----
+<config xmlns="urn:org:jgroups" xmlns:xsi="[http://www.w3.org/2001/XMLSchema-instance]"     
+     xsi:schemaLocation="urn:org:jgroups file:schema/JGroups-2.8.xsd">
+      <TCP bind_port="7800" />
+      <TCPPING timeout="3000"
+           initial_hosts="$\{jgroups.tcpping.initial_hosts:localhost\[7800\],localhost\[7801\]\}"
+           port_range="1"
+           num_initial_members="3"/>
+      <MERGE2 max_interval="30000"  min_interval="10000"/>
+      <FD_SOCK/>
+      <FD timeout="10000" max_tries="5" />
+      <VERIFY_SUSPECT timeout="1500"  />
+      <pbcast.NAKACK
+           use_mcast_xmit="false" gc_lag="0"
+           retransmit_timeout="300,600,1200,2400,4800"
+           discard_delivered_msgs="true"/>
+      <UNICAST timeout="300,600,1200" />
+      <pbcast.STABLE
+           stability_delay="1000"
+           desired_avg_gossip="50000"
+           max_bytes="400000"/>
+      <pbcast.GMS
+           print_local_addr="true"
+           join_timeout="3000"
+           view_bundling="true"/>
+      <FC max_credits="2000000" min_threshold="0.10"/>
+      <FRAG2 frag_size="60000" />
+      <pbcast.STREAMING_STATE_TRANSFER/>
+</config>
+----
+
+==== 
+[[sid-68355070_RunningInfinispanonAmazonWebServices-GossipRouter]]
+
+
+=== GossipRouter
+
+ Another approach is to have a central server (Gossip, which each node will be configured to contact. This central server will tell each node in the cluster about each other node. More on Gossip Router @ link:$$http://community.jboss.org/docs/DOC-10890$$[http://www.jboss.org/community/wiki/JGroupsGossipRouter] 
+
+The address (ip:port) that the Gossip router is listening on can be injected into the JGroups configuration used by Infinispan. To do this pass the gossip routers address as a system property to the JVM e.g. -DGossipRouterAddress="10.10.2.4[12001]" and reference this property in the JGroups configuration that Infinispan is using e.g.
+
+
+----
+
+<config>
+    <TCP bind_port="7800" />
+    <TCPGOSSIP timeout="3000" initial_hosts="$\{GossipRouterAddress\}" num_initial_members="3" />
+.
+.
+</config>
+
+----
+
+[[sid-68355070_RunningInfinispanonAmazonWebServices-S3PING]]
+
+
+=== S3_PING
+
+Finally you can configure your JGroups instances to use a shared storage to exchange the details of the cluster nodes. S3_PING was added to JGroups in 2.6.12 and 2.8, and allows the Amazon S3 to be used as the shared storage. It is experimental at the moment but offers another method of clustering without a central server. Be sure that you have signed up for Amazon S3 as well as EC2 to use this method.
+
+
+----
+
+<?xml version="1.0" encoding="UTF-8"?>
+<config>
+    <TCP bind_port="7800" />
+    <S3_PING
+            secret_access_key="replace this with you secret access key"
+            access_key="replace this with your access key"
+            location="replace this with your S3 bucket location" />
+    <MERGE2
+            max_interval="30000"
+            min_interval="10000" />
+    <FD_SOCK />
+    <FD timeout="10000"
+            max_tries="5" />
+    <VERIFY_SUSPECT timeout="1500" />
+    <pbcast.NAKACK
+            use_mcast_xmit="false"
+            gc_lag="0" retransmit_timeout="300,600,1200,2400,4800"
+            discard_delivered_msgs="true" />
+    <UNICAST timeout="300,600,1200,2400,3600" />
+    <pbcast.STABLE
+            stability_delay="1000"
+            desired_avg_gossip="50000"
+            max_bytes="400000" />
+    <VIEW_SYNC
+            avg_send_interval="60000" />
+    <pbcast.GMS
+            print_local_addr="true"
+            join_timeout="60000"
+            view_bundling="true" />
+    <FC max_credits="20000000"
+            min_threshold="0.10" />
+    <FRAG2 frag_size="60000" />
+    <pbcast.STATE_TRANSFER />
+    <pbcast.FLUSH timeout="0" />
+</config>
+
+----
+
+[[sid-68355070_RunningInfinispanonAmazonWebServices-JDBCPING]]
+
+
+=== JDBC_PING
+
+ A similar approach to S3_PING, but using a JDBC connection to a shared database. On EC2 that is quite easy using Amazon RDS. See the link:$$http://community.jboss.org/wiki/JDBCPING$$[JDBC_PING Wiki page] for details. 
+
+[[sid-68355070_RunningInfinispanonAmazonWebServices-Creatingaclusternodewithdistributedcache]]
+
+
+=== Creating a cluster node with distributed cache
+
+.Creating a cluster
+
+==== 
+----
+
+GlobalConfiguration gc = GlobalConfiguration.getClusteredDefault();
+gc.setClusterName("infinispan-test-cluster");
+gc.setTransportClass(JGroupsTransport.class.getName());
+//Load the jgroups properties
+Properties p = newProperties();
+p.setProperty("configurationFile","jgroups-config.xml");
+gc.setTransportProperties(p);
+Configuration c = new Configuration();
+//Distributed cache mode
+c.setCacheMode(Configuration.CacheMode.DIST_SYNC);
+c.setExposeJmxStatistics(true);
+// turn functionality which returns the previous value when setting
+c.setUnsafeUnreliableReturnValues(true);
+//data will be distributed over 3 nodes
+c.setNumOwners(3);
+c.setL1CacheEnabled(true);
+//Allow batching
+c.setInvocationBatchingEnabled(true);
+c.setL1Lifespan(6000000);
+cache_manager = new DefaultCacheManager(gc, c, false);
+
+----
+
+==== 
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-31-Eviction_Examples.adoc b/documentation/src/main/asciidoc/user_guide/chapter-31-Eviction_Examples.adoc
new file mode 100644
index 0000000..c9f8d52
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-31-Eviction_Examples.adoc
@@ -0,0 +1,140 @@
+[[sid-68355071]]
+
+==  Eviction Examples
+
+[[sid-68355071_EvictionExamples-Introduction]]
+
+
+=== Introduction
+
+
+.  _Expiration_ is a top-level construct, represented in the configuration as well as in the cache API.  More on this later. 
+
+
+.  While eviction is _local to each cache instance_ , expiration is _cluster-wide_ .  Expiration lifespans and maxIdle values are replicated along with the cache entry. 
+
+
+.  Expiration lifespan and maxIdle are also persisted in CacheStores, so this information survives eviction/passivation. 
+
+
+.  Four eviction strategies are shipped, link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/eviction/EvictionStrategy.html#NONE$$[EvictionStrategy.NONE] , link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/eviction/EvictionStrategy.html#LRU$$[EvictionStrategy.LRU] , link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/eviction/EvictionStrategy.html#UNORDERED$$[EvictionStrategy.UNORDERED] , and link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/eviction/EvictionStrategy.html#LIRS$$[EvictionStrategy.LIRS] . 
+
+[[sid-68355071_EvictionExamples-Configuration]]
+
+
+=== Configuration
+
+Eviction may be configured using the Configuration bean or the XML file.  Eviction configuration is on a per-cache basis.  Valid eviction-related configuration elements are:
+
+
+----
+<eviction strategy="FIFO" wakeupInterval="1000" maxEntries="2000"/>
+<expiration lifespan="1000" maxIdle="500" />
+
+----
+
+
+[NOTE]
+.XML changes in Infinispan 5.0
+==== 
+ From Infinispan 5.0 onwards, wakeupInterval attribute has been moved to expiration XML element. This is because since 4.1, eviction happens in the user thread, and so the old eviction thread now simply purges expired entries from memory and any attached cache store. So, effectively, wakeUpInterval controls how often this purging occurs: 
+
+
+----
+<eviction strategy="FIFO" maxEntries="2000"/>
+<expiration lifespan="1000" maxIdle="500" wakeupInterval="1000"/>
+
+----
+
+
+==== 
+
+
+Programmatically, the same would be defined using:
+
+
+----
+Configuration c = new ConfigurationBuilder().eviction().strategy(EvictionStrategy.LRU)
+               .maxEntries(2000).expiration().wakeUpInterval(5000l).lifespan(1000l).maxIdle(1000l)
+               .build();
+
+----
+
+[[sid-68355071_EvictionExamples-Defaultvalues]]
+
+
+==== Default values
+
+Eviction is disabled by default.  If enabled (using an empty &lt;eviction /&gt; element), certain default values are used:
+
+
+* strategy: EvictionStrategy.NONE is assumed, if a strategy is not specified..
+
+
+* wakeupInterval: 5000 is used if not specified.
+
+
+* If you wish to disable the eviction thread, set wakeupInterval to -1.
+
+
+* maxEntries: -1 is used if not specified, which means unlimited entries.
+
+
+* 0 means no entries, and the eviction thread will strive to keep the cache empty.
+
+Expiration lifespan and maxIdle both default to -1.
+
+[[sid-68355071_EvictionExamples-Usingexpiration]]
+
+
+==== Using expiration
+
+Expiration allows you to set either a lifespan or a maximum idle time on each key/value pair stored in the cache.  This can either be set cache-wide using the configuration, as described above, or it can be defined per-key/value pair using the Cache interface.  Any values defined per key/value pair overrides the cache-wide default for the specific entry in question.
+
+For example, assume the following configuration:
+
+
+----
+<expiration lifespan="1000" />
+
+----
+
+
+----
+// this entry will expire in 1000 millis
+cache.put("pinot noir", pinotNoirPrice);
+
+// this entry will expire in 2000 millis
+cache.put("chardonnay", chardonnayPrice, 2, TimeUnit.SECONDS);
+
+// this entry will expire 1000 millis after it is last accessed
+cache.put("pinot grigio", pinotGrigioPrice, -1,
+          TimeUnit.SECONDS, 1, TimeUnit.SECONDS);
+
+// this entry will expire 1000 millis after it is last accessed, or
+// in 5000 millis, which ever triggers first
+cache.put("riesling", rieslingPrice, 5,
+          TimeUnit.SECONDS, 1, TimeUnit.SECONDS);
+
+----
+
+[[sid-68355071_EvictionExamples-Evictiondesigns]]
+
+
+=== Eviction designs
+
+Central to eviction is an EvictionManager - which is only available if eviction or expiration is configured.
+
+The purpose of the EvictionManager is to drive the eviction/expiration thread which periodically purges items from the DataContainer.  If the eviction thread is disabled (wakeupInterval set to -1) eviction can be kicked off manually using EvictionManager.processEviction(), for example from another maintenance thread that may run periodically in your application.
+
+The eviction manager processes evictions in the following manner:
+
+
+. Causes the data container to purge expired entries
+
+
+. Causes cache stores (if any) to purge expired entries
+
+
+. Prunes the data container to a specific size, determined by maxElements
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-32-Clustering_modes.adoc b/documentation/src/main/asciidoc/user_guide/chapter-32-Clustering_modes.adoc
new file mode 100644
index 0000000..be2147d
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-32-Clustering_modes.adoc
@@ -0,0 +1,173 @@
+[[sid-68355074]]
+
+==  Clustering modes
+
+[[sid-68355074_Clusteringmodes-Introduction]]
+
+
+=== Introduction
+
+Infinispan can be configured to be either local (standalone) or clustered. If in a cluster, the cache can be configured to replicate changes to all nodes, to invalidate changes across nodes and finally to be used in distributed mode - state changes are replicated to a small subset of nodes enough to be fault tolerant but not to many nodes to prevent scalability.
+
+[[sid-68355074_Clusteringmodes-LocalMode]]
+
+
+=== Local Mode
+
+ While Infinispan is particularly interesting in clustered mode, it also offers a very capable local mode, where it acts as a simple, in-memory data cache similar to JBoss Cache and EHCache. But why would one use a local cache rather than a map? Caches offer a lot of features over and above a simple map, including write-through and write-behind caching to persist data, eviction of entries to prevent running out of memory, and support for expirable entries. Infinispan, specifically, is built around a high-performance, read-biased data container which uses modern techniques like MVCC locking - which buys you non-blocking, thread-safe reads even when concurrent writes are taking place. Infinispan also makes heavy use of compare-and-swap and other lock-free algorithms, making it ideal for high-throughput, multi-CPU/multi-core environments. Further, Infinispan's Cache API extends the JDK's ConcurrentMap - making migration from a map to Infinispan trivial. For more details refer to link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737159$$[Non-clustered, LOCAL mode] section. 
+
+[[sid-68355074_Clusteringmodes-ReplicatedMode]]
+
+
+=== Replicated Mode
+
+Replication is a simple clustered mode where cache instances automatically discover neighboring instances on other JVMs on the same local network, and form a cluster. Entries added to any of these cache instances will be replicated to all other cache instances in the cluster, and can be retrieved locally from any instance. This clustered mode provides a quick and easy way to share state across a cluster, however replication practically only performs well in small clusters (under 10 servers), due to the number of replication messages that need to happen - as the cluster size increases. Infinispan can be configured to use UDP multicast which mitigates this problem to some degree.
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+                                                        Figure 1. Replication mode
+
+Replication can be synchronous or asynchronous. Use of either one of the options is application dependent. Synchronous replication blocks the caller (e.g. on a put() ) until the modifications have been replicated successfully to all nodes in a cluster. Asynchronous replication performs replication in the background (the put() returns immediately). Infinispan offers a replication queue, where modifications are replicated periodically (i.e. interval-based), or when the queue size exceeds a number of elements, or a combination thereof. A replication queue can therefore offer much higher performance as the actual replication is performed by a background thread.
+
+Asynchronous replication is faster (no caller blocking), because synchronous replication requires acknowledgments from all nodes in a cluster that they received and applied the modification successfully (round-trip time). However, when a synchronous replication returns successfully, the caller knows for sure that all modifications have been applied to all cache instances, whereas this is not be the case with asynchronous replication. With asynchronous replication, errors are simply written to a log. Even when using transactions, a transaction may succeed but replication may not succeed on all cache instances.
+
+[[sid-68355074_Clusteringmodes-InvalidationMode]]
+
+
+=== Invalidation Mode
+
+Invalidation is a clustered mode that does not actually share any data at all, but simply aims to remove data that may be stale from remote caches. This cache mode only makes sense if you have another, permanent store for your data such as a database and are only using Infinispan as an optimization in a read-heavy system, to prevent hitting the database every time you need some state. If a cache is configured for invalidation rather than replication, every time data is changed in a cache other caches in the cluster receive a message informing them that their data is now stale and should be evicted from memory.
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+                                                            Figure 2. Invalidation mode
+
+Invalidation, when used with a shared cache loader would cause remote caches to refer to the shared cache loader to retrieve modified data. The benefit of this is twofold: network traffic is minimized as invalidation messages are very small compared to replicating updated data, and also that other caches in the cluster look up modified data in a lazy manner, only when needed.
+
+Invalidation messages are sent after each modification (no transactions or batches), or at the end of a transaction or batch, upon successful commit. This is usually more efficient as invalidation messages can be optimized for the transaction as a whole rather than on a per-modification basis.
+
+Invalidation too can be synchronous or asynchronous, and just as in the case of replication, synchronous invalidation blocks until all caches in the cluster receive invalidation messages and have evicted stale data while asynchronous invalidation works in a 'fire-and-forget' mode, where invalidation messages are broadcast but doesn't block and wait for responses.
+
+[[sid-68355074_Clusteringmodes-DistributionMode]]
+
+
+=== Distribution Mode
+
+ Distribution is a powerful clustering mode which allows Infinispan to scale linearly as more servers are added to the cluster. Distribution makes use of a link:$$http://en.wikipedia.org/wiki/Consistent_hashing$$[consistent hash] algorithm to determine where in a cluster entries should be stored. Hashing algorithm is configured with the number of copies each cache entry should be maintained cluster-wide. Number of copies represents the tradeoff between performance and durability of data. The more copies you maintain, the lower performance will be, but also the lower the risk of losing data due to server outages. Regardless of how many copies are maintained, distribution still scales linearly and this is key to Infinispan scalability. Another feature of the consistent hash algorithm is that it is deterministic in locating entries without resorting to multicasting requests or maintaining expensive metadata. Doing a PUT would result in at most num_copies remote calls, and doing a GET anywhere in the cluster would result in at most 1 remote call. In reality, num_copies remote calls are made even for a GET, but these are done in parallel and as soon as any one of these returns, the entry is passed back to the caller. 
+
+ _NOTE:_ This behavior is due to change in Infinispan 5.3, where just a single GET call is made.  See link:$$https://issues.jboss.org/browse/ISPN-825$$[ISPN-825] . 
+
+[[sid-68355074_Clusteringmodes-Readconsistency]]
+
+
+==== Read consistency
+
+ Since GETs are sent to all data owners in parallel and the first returning result is used, this can lead to data inconsistency when using an _asynchronous_ transport.  If an updating thread modifies the primary data owner, but updates are only sent to backup nodes asynchronously, a concurrent read may read a stale value for a short period of time until the asynchronous replication completes. 
+
+ Note that this is _only_ if the transport is _asynchronous_ .  If using a _synchronous_ transport this behavior is not exhibited. 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+                                                       Figure 3. Distribution mode
+
+[[sid-68355074_Clusteringmodes-VirtualNodesImprovingthedistributionofdata]]
+
+
+==== Virtual Nodes - Improving the distribution of data
+
+Infinispan does not attempt to evenly split the hash space between nodes – by not trying to split it evenly, it means that if a node joins or leaves the grid, there is no need to adjust the ownership of every node, just the neighbours of the joiner/leaver. This has a positive impact on network traffic. However this can mean that some nodes take on substantially larger portions of the hash space than others. This, combined with potential irregularities in the hash functions of keys, can mean the distribution of entries across the grid becomes poor. In order to address the irregularities in the hash of keys, Infinispan uses an advanced hashing function (Murmur Hash 3) by default, as well as using a bit spreader. In order to address the irregularities in the node distribution, Infinispan uses virtual nodes.
+
+First, let's consider how virtual nodes help conceptually by taking a couple of distribution examples, and armed with that knowledge, look at how Infinispan uses them.
+
+Consider a hash space of 1000 (there are 1000 buckets into which data can be placed). If there were two nodes, it is possible you can have 1 node being used for 1 bucket, and 1 node for 999 buckets (this is the most pessimistic distribution!). If there were 200 nodes, the worst distribution of node would end up being 199 nodes responsible for one bucket each (199 buckets in total), and 1 node being responsible for 801 buckets. If there were 1000 nodes, then each node must be responsible for 1 bucket each. From this we can deduce that as the number of nodes tends to the size of the hash space, that the distribution of buckets to nodes improves.
+
+A guiding principle of Infinispan is that it always uses an algorithm to locate a key in the hash space, never allowing the node on which the entry is stored to be specified manually. This scheme allows any node to know which nodes owns a key, without having to distribute such ownership information. This reduces the overhead of Infinispan, but more importantly improves redundancy as there is no need to replicate the ownership information in case of node failure.
+
+With this in mind, we can see that virtual nodes are an ideal solution to the distribution of nodes problem, as it allows the location of an entry to be determined algorithmically.
+
+Infinispan implements virtual nodes by altering the algorithm for splitting the hash space whenever a node joins or leaves the grid. Rather than allocating a block of the hashspace to the node, it allocates a number of blocks from throughout the hash space.
+
+Often it's easier to understand the topology changes that virtual nodes introduce through diagrams.
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+Figure: Topology Without Virtual Nodes
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+Figure: Topology With Virtual Nodes
+
+To use virtual nodes, simply set the number of virtual nodes higher than one. For example
+
+
+----
+
+
+   <namedCache name="cacheWithVirtualNodes">
+      <clustering>
+         <hash numVirtualNodes="10" />
+      </clustering>
+   </namedCache>
+
+
+----
+
+Alternatively, you can enable virtual nodes programmatically
+
+
+----
+
+new ConfigurationBuilder()
+   .clustering()
+      .hash()
+         .numVirtualNodes(10)
+   .build();
+
+----
+
+TODO Add notes on how to select number of virtual nodes.
+
+[[sid-68355074_Clusteringmodes-L1Caching]]
+
+
+=== L1 Caching
+
+To prevent repeated remote calls when doing multiple GETs, L1 caching can be enabled. L1 caching places remotely received values in a near cache for a short period of time (configurable) so repeated lookups would not result in remote calls. In the above diagram, if L1 was enabled, a subsequent GET for the same key on Server3 would not result in any remote calls.
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+                                                            Figure 4. L1 caching
+
+L1 caching is not free though. Enabling it comes at a cost, and this cost is that every time a key is updated, an invalidation message needs to be multicast to ensure nodes with the entry in L1 invalidates the entry. L1 caching causes the requesting node to cache the retrieved entry locally and listen for changes to the key on the wire. L1-cached entries are given an internal expiry to control memory usage. Enabling L1 will improve performance for repeated reads of non-local keys, but will increase memory consumption to some degree. It offers a nice tradeoff between the "read-mostly" performance of an invalidated data grid with the scalability of a distributed one. Is L1 caching right for you? The correct approach is to benchmark your application with and without L1 enabled and see what works best for your access pattern.
+
+
+----
+Looking for Buddy Replication?  Buddy Replication - from JBoss Cache - does not exist in Infinispan.  See this blog article which discusses the reasons why Buddy Replication was not implemented in Infinispan, and how the same effects can be achieved using Infinispan - 
+<a href="http://infinispan.blogspot.com/2009/08/distribution-instead-of-buddy.html">http://infinispan.blogspot.com/2009/08/distribution-instead-of-buddy.html</a>
+
+----
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-33-Using_Infinispan_as_a_Spring_Cache_provider.adoc b/documentation/src/main/asciidoc/user_guide/chapter-33-Using_Infinispan_as_a_Spring_Cache_provider.adoc
new file mode 100644
index 0000000..934b2c9
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-33-Using_Infinispan_as_a_Spring_Cache_provider.adoc
@@ -0,0 +1,87 @@
+[[sid-68355076]]
+
+==  Using Infinispan as a Spring Cache provider
+
+
+----
+h1. Introduction
+
+Starting with 3.1 Spring offers a [cache abstraction|<a href="http://blog.springsource.com/2011/02/23/spring-3-1-m1-caching/">http://blog.springsource.com/2011/02/23/spring-3-1-m1-caching/</a>], enabling users to declaratively add caching support to applications via two simple annotations, {font:monospace}@Cacheable{font} and {font:monospace}@CacheEvict{font}. While out of the box Spring 3.1's caching support is backed by [Ehcache|<a href="http://ehcache.org/">http://ehcache.org/</a>] it has been designed to easily support different cache providers. To that end Spring 3.1 defines a simple and straightforward SPI other caching solutions may implement. Infinispan's very own spring module does - amongst other things - exactly this and therefore users invested in Spring's programming model may easily have all their caching needs fulfilled through Infinispan. Here's how.
+
+(Note that the following is based on a small but fully functional example that is part of Spring Infinispan's test suite. For further details you are encouraged to look at {font:monospace}org.infinispan.spring.provider.sample.CachingBookDaoContextTest{font} and its ilk.)
+
+h1. Activating Spring Cache support
+
+You activate Spring's cache support via putting
+{code:xml}
+<beans xmlns="<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>" 
+            xmlns:xsi="<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>"
+            xmlns:cache="<a href="http://www.springframework.org/schema/cache">http://www.springframework.org/schema/cache</a>"
+            xsi:schemaLocation="
+                <a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a> 
+                <a href="http://www.springframework.org/schema/beans/spring-beans.xsd">http://www.springframework.org/schema/beans/spring-beans.xsd</a>
+                <a href="http://www.springframework.org/schema/cache">http://www.springframework.org/schema/cache</a> 
+                <a href="http://www.springframework.org/schema/cache/spring-cache.xsd">http://www.springframework.org/schema/cache/spring-cache.xsd</a>">
+
+  <cache:annotation-driven />
+
+</beans>
+
+----
+
+somewhere in your application context. This will tell Spring to be on the lookout for {font:monospace}@Cacheable{font} and {font:monospace}@CacheEvict{font} within your application code.Now, assuming you've already {font:monospace}infinispan.jar{font} and its dependencies on your classpath, all that's left to do is installing {font:monospace}infinispan-spring{font} and {font:monospace}spring{font}. For maven users this translates into
+
+
+----
+
+     <dependency>
+         <groupId>org.springframework</groupId>
+         <artifactId>spring-context</artifactId>
+         <version>3.1.0.M1</version>
+         <scope>compile</scope>
+      </dependency>
+      <dependency>
+         <groupId>org.infinispan</groupId>
+         <artifactId>infinispan-spring</artifactId>
+         <version>5.0.0</version>
+         <scope>compile</scope>
+      </dependency>
+ 
+----
+
+{font:monospace}Gradle{font} users will most likely know how to adapt this to their needs. Those leaning towards a more ... pedestrian way of managing their dependencies will need to download {font:monospace}Spring 3.1.0 M1{font} and install it manually alongside {font:monospace}infinispan-spring.jar{font} from the Infinispan distribution.h1. Telling Spring to use Infinispan as its caching providerSpring 3.1's cache provider SPI comprises two interfaces, {font:monospace}org.springframework.cache.CacheManager{font} and {font:monospace}org.springframework.cache.Cache{font} where a {font:monospace}CacheManager{font} serves as a factory for named {font:monospace}Cache{font} instances. By default Spring will look at runtime for a {font:monospace}CacheManager{font} implementation having the bean name "cacheManager" in an application's application context. So by putting
+
+
+----
+
+<!-- Infinispan cache manager -->
+<bean id="cacheManager" 
+          class="org.infinispan.spring.provider.SpringEmbeddedCacheManagerFactoryBean"
+          p:configurationFileLocation="classpath:/org/infinispan/spring/provider/sample/books-infinispan-config.xml" />
+
+----
+
+somewhere in your application context you tell Spring to henceforth use Infinispan as its caching provider.h1. Adding caching to your application codeAs outlined above enabling caching in your application code is as simple as adding {font:monospace}@Cacheable{font} and {font:monospace}@CacheEvict{font} to select methods. Suppose you've got a DAO for, say, books and you want book instances to be cached once they've been loaded from the underlying database using {font:monospace}BookDao#findBook(Integer bookId){font}. To that end you annotate {font:monospace}findBook(Integer bookId){font} with {font:monospace}@Cacheable{font}, as in
+
+
+----
+
+@Transactional
+@Cacheable(value = "books", key = "#bookId")
+Book findBook(Integer bookId) {...}
+
+----
+
+ This will tell Spring to cache Book instances returned from calls to {font:monospace}findBook(Integer bookId){font} in a named cache "books", using the parameter's "bookId" value as a cache key. Here, "#bookId" is an expression in the [Spring Expression Language| link:$$http://static.springsource.org/spring/docs/current/spring-framework-reference/html/expressions.html$$[] ] that evaluates to the {font:monospace}bookId{font} argument. If you don't specify the {font:monospace}key{font} attribute Spring will generate a hash from the supplied method arguments - in this case only {font:monospace}bookId{font} - and use that as a cache key. Essentially, you relinquish control over what cache key to use to Spring. Which may or may not be fine depending on your application's needs.Though the notion of actually deleting a book will undoubtedly seem alien and outright abhorrent to any sane reader there might come the time when your application needs to do just that. For whatever reason. In this case you will want for such a book to be removed not only from the underlying database but from the cache, too. So you annotate {font:monospace}deleteBook(Integer bookId){font} with {font:monospace}@CacheEvict{font} as in 
+
+
+----
+
+@Transactional
+@CacheEvict(value = "books", key = "#bookId")
+void deleteBook(Integer bookId) {...}
+
+----
+
+ and you may rest assured that no stray books be left in your application once you decide to remove them.h1. OutroHopefully you enjoyed our quick tour of Infinispan's support for Spring's cache abstraction and saw how easy it is for all your caching woes to be taken care of by Infinispan. More information may be found in Spring's as usual rather excellent [reference documentation| link:$$http://static.springsource.org/spring/docs/3.1.0.M1/spring-framework-reference/html/cache.html$$[] ] and [javadocs| link:$$http://static.springsource.org/spring/docs/3.1.0.M1/javadoc-api/index.html?org/springframework/cache/package-summary.html$$[] ]. Also see [this| link:$$http://blog.springsource.com/2011/02/23/spring-3-1-m1-caching/$$[] ] very nice posting on the official Spring blog for a somewhat more comprehensive introduction to Spring's cache abstraction.{code} 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-34-Distributed_Data_Stream_Processing_Framework_In_Infinispan.adoc b/documentation/src/main/asciidoc/user_guide/chapter-34-Distributed_Data_Stream_Processing_Framework_In_Infinispan.adoc
new file mode 100644
index 0000000..75d9d75
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-34-Distributed_Data_Stream_Processing_Framework_In_Infinispan.adoc
@@ -0,0 +1,4 @@
+[[sid-68355077]]
+
+==  Distributed Data Stream Processing Framework In Infinispan
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-35-Per_Invocation_Flags.adoc b/documentation/src/main/asciidoc/user_guide/chapter-35-Per_Invocation_Flags.adoc
new file mode 100644
index 0000000..e03d7f5
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-35-Per_Invocation_Flags.adoc
@@ -0,0 +1,63 @@
+[[sid-68355078]]
+
+==  Invocation Flags
+
+ An important aspect of getting the most of Infinispan is the use of per-invocation flags in order to provide specific behaviour to each particular cache call. By doing this, some important optimizations can be implemented potentially saving precious time and network resources. One of the most popular usages of flags can be found right in Cache API, underneath the link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/Cache.html#putForExternalRead(K, V)$$[putForExternalRead()] method which is used to load an Infinispan cache with data read from an external resource. In order to make this call efficient, Infinispan basically calls a normal put operation passing the following flags: link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/context/Flag.html#FAIL_SILENTLY$$[FAIL_SILENTLY] , link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/context/Flag.html#FORCE_ASYNCHRONOUS$$[FORCE_ASYNCHRONOUS] , link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/context/Flag.html#ZERO_LOCK_ACQUISITION_TIMEOUT$$[ZERO_LOCK_ACQUISITION_TIMEOUT] 
+
+ What Infinispan is doing here is effectively saying that when putting data read from external read, it will use an almost-zero lock acquisition time and that if the locks cannot be acquired, it will fail silently without throwing any exception related to lock acquisition. It also specifies that regardless of the cache mode, if the cache is clustered, it will replicate asynchronously and so won't wait for responses from other nodes. The combination of all these flags make this kind of operation very efficient, and the efficiency comes from the fact this type of _putForExternalRead_ calls are used with the knowledge that client can always head back to a persistent store of some sorts to retrieve the data that should be stored in memory. So, any attempt to store the data is just a best effort and if not possible, the client should try again if there's a cache miss. 
+
+[[sid-68355078_Per-InvocationFlags-Examples]]
+
+
+=== Examples
+
+ If you want to use these or any other flags available, which by the way are described in detail the link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/context/Flag.html$$[Flag enumeration] , you simply need to get hold of the advanced cache and add the flags you need via the link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/AdvancedCache.html#withFlags(org.infinispan.context.Flag...)$$[withFlags()] method call. For example: 
+
+
+----
+Cache cache = ...
+cache.getAdvancedCache()
+   .withFlags(Flag.SKIP_CACHE_STORE, Flag.CACHE_MODE_LOCAL)
+   .put("local", "only"); 
+
+----
+
+ It's worth noting that these flags are only active for the duration of the cache operation. If the same flags need to be used in several invocations, even if they're in the same transaction, link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/AdvancedCache.html#withFlags(org.infinispan.context.Flag...)$$[withFlags()] needs to be called repeatedly. Clearly, if the cache operation is to be replicated in another node, the flags are carried over to the remote nodes as well. 
+
+[[sid-68355078_Per-InvocationFlags-DecoratedCache]]
+
+
+=== DecoratedCache
+
+ Another approach would be to use the link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/DecoratedCache.html$$[DecoratedCache] wrapper. This allows you to reuse flags. For example: 
+
+
+----
+AdvancedCache cache = ...
+DecoratedCache strictlyLocal = new DecoratedCache(cache, Flag.CACHE_MODE_LOCAL, Flag.SKIP_CACHE_STORE);
+strictlyLocal.put("local_1", "only");
+strictlyLocal.put("local_2", "only");
+strictlyLocal.put("local_3", "only");
+
+----
+
+This approach makes your code more readable.
+
+[[sid-68355078_Per-InvocationFlags-Suppressingreturnvaluesfromaput%28%29orremove%28%29]]
+
+
+=== Suppressing return values from a put() or remove()
+
+ Another very important use case is when you want a write operation such as put() to _not_ return the previous value. To do that, you need to use two flags to make sure that in a distributed environment, no remote lookup is done to potentially get previous value, and if the cache is configured with a cache loader, to avoid loading the previous value from the cache store. You can see these two flags in action in the following example: 
+
+
+----
+Cache cache = ...
+cache.getAdvancedCache()
+   .withFlags(Flag.SKIP_REMOTE_LOOKUP, Flag.SKIP_CACHE_LOAD)
+   .put("local", "only")
+
+----
+
+ For more information, please check the link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/context/Flag.html$$[Flag enumeration] javadoc. 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-36-Key_affinity_service.adoc b/documentation/src/main/asciidoc/user_guide/chapter-36-Key_affinity_service.adoc
new file mode 100644
index 0000000..ddd22b0
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-36-Key_affinity_service.adoc
@@ -0,0 +1,75 @@
+[[sid-68355079]]
+
+==  Key affinity service
+
+[[sid-68355079_Keyaffinityservice-Introduction]]
+
+
+=== Introduction
+
+ The key affinity service solves the following problem: for a distributed Infinispan cluster one wants to make sure that a value is placed in a certain node. Based on a supplied cluster link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/remoting/transport/Address.html$$[address] identifying the node, the service returns a key that will be hashed to that particular node. 
+
+[[sid-68355079_Keyaffinityservice-API]]
+
+
+=== API
+
+ Following code snippet depicts how a reference to this service can be obtained and used. 
+
+
+----
+//1. obtain a reference to a cache manager
+EmbeddedCacheManager cacheManager = getCacheManager();//obtain a reference to a cache manager
+Cache cache = cacheManager.getCache();
+ 
+//2. create the affinity service
+KeyAffinityService keyAffinityService = KeyAffinityServiceFactory.newLocalKeyAffinityService(cache, new RndKeyGenerator(),
+                                 Executors.newSingleThreadExecutor(), 100);
+ 
+//3. obtain a key to be mapped to a certain address
+Object localKey = keyAffinityService.getKeyForAddress(cacheManager.getAddress());
+ 
+//4. this put makes sure that the key resigns on the local node (as obtained cacheManager.getAddress())
+cache.put(localKey, "yourValue");
+
+----
+
+The service is started at step 2: after this point it uses the supplied Excutor to generate and queue keys. At step 3, we obtain a key for this service, and use it at step 4, with that guarantee that it is distributed in node identified by cacheManager.getAddress().
+
+[[sid-68355079_Keyaffinityservice-Lifecycle]]
+
+
+=== Lifecycle
+
+ KeyAffinityService extends Lifecycle, which allows stopping and (re)starting it: 
+
+
+----
+public interface Lifecycle {
+   void start();
+   void stop();
+}
+
+----
+
+The service is instantiated through KeyAffinityServiceFactory. All the factory method have an Executors parameter, that is used for asynchronous key generation (so that it won't happen in the caller's thread). It is user's responsibility to handle the shutdown of this Executor.
+
+The KeyAffinityService, once started, needs to be explicitly stopped. This stops the async key generation and releases other held resources.
+
+The only situation in which KeyAffinityService stops by itself is when the cache manager with wich it was registered is shutdown.
+
+[[sid-68355079_Keyaffinityservice-Topologychanges]]
+
+
+=== Topology changes
+
+When a topology change takes place the key ownership from the KeyAffinityService might change. The key affinity service keep tracks of these topology changes and updates and doesn't return stale keys, i.e. keys that would currently map to a different node than the one specified. However, this does not guarantee that at the time the key is used its node affinity hasn't changed, e.g.:
+
+- thread T1 reads a key k1 that maps to node A
+
+- a topology change happens which makes k1 map to node B
+
+- T1 uses k1 to add something to the cache. At this point k1 maps to B, different node than the one requested at the time of read.
+
+Whilst this is not ideal, it should be a supported behaviour for the application as all the already in-use keys might me moved over during cluster change. The KeyAffinityService provides an access proximity optimisation for stable clusters which doesn't apply during topology changes.
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-37-Transaction_recovery.adoc b/documentation/src/main/asciidoc/user_guide/chapter-37-Transaction_recovery.adoc
new file mode 100644
index 0000000..be5d24c
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-37-Transaction_recovery.adoc
@@ -0,0 +1,141 @@
+[[sid-68355080]]
+
+==  Transaction recovery
+
+[[sid-68355080_Transactionrecovery-]]
+
+
+=== 
+
+[[sid-68355080_Transactionrecovery-Whentouserecovery]]
+
+
+=== When to use recovery
+
+Consider a distributed transaction in which money are transfered from an account stored in the database to an account stored in Infinispan. When TransactionManager.commit() is invoked, both resources prepare successfully(1st phase). During commit (2nd phase), the database successfully applies the changes whilst Infinispan fails before receiving the commit request from the TransactionManager. At this point the system is in an inconsistent state: money are taken from the datbase account but not visible yet in Infinispan(locks are only released during 2nd phase of 2PC). Recovery deals with this situation to make sure data in both the database and Infinispan ends up in a consistent state.
+
+[[sid-68355080_Transactionrecovery-Howdoesitwork]]
+
+
+=== How does it work
+
+Recovery is coordinated by the TransactionManager (TM). The TM works with Infinispan to determine the list of in-doubt transactions that require manual intervention and informs the system administrator (SA) (email, logs). This process is TM specific, but generally requires some configuration on TM's side.  
+
+ Knowing the in-doubt transaction ids, the SA can now connect to the Infinispan cluster and replay the commit of transactions or force the rollback. Infinispan provides JMX tooling for this - this is explained extensively in the link:$$http://community.jboss.org/docs/DOC-16646?uniqueTitle=false#Reconciliate_state$$[Reconciliate state] section. 
+
+[[sid-68355080_Transactionrecovery-Configuringrecovery%C2%A0%C2%A0%C2%A0]]
+
+
+=== Configuring recovery   
+
+ Recovery is _not_ enabled by default in Infinispan. If disabled the TransactionManager won't be able to work with Infinispan to determine the in-doubt transactions. In order to enable recovery through xml configuration: 
+
+
+----
+<transaction useEagerLocking="true" eagerLockSingleNode="true">
+    <recovery enabled="true" recoveryInfoCacheName="noRecovery"/>
+</transaction>
+
+----
+
+ Note:  the _recoveryInfoCacheName_ attribute is not mandatory. More information about it can be found in the  _Recovery Cache_ section below. 
+
+Alternatively you can enable it through the fluent configuration API as follows:
+
+
+----
+//simply calling .recovery() enables it
+configuration.fluent().transaction().recovery();
+
+//then you can disable it
+configuration.fluent().transaction().recovery().disable();
+
+//or just check its status
+boolean isRecoveryEnabled = configuration.isTransactionRecoveryEnabled();
+
+----
+
+Recovery can be enabled/disabled o a per cache level: e..g it is possible to have a transaction spanning a cache that is has it enabled and another one that doesn't.
+
+[[sid-68355080_Transactionrecovery-EnableJMXsupport]]
+
+
+==== Enable JMX support
+
+ _Important:_ In order to be able to use JMX for managing recovery JMX support must be explicitly enabled. More about enabling JMX link:$$http://community.jboss.org/docs/DOC-14865#Enabling_JMX_Statistics$$[here] . 
+
+[[sid-68355080_Transactionrecovery-Recoverycache]]
+
+
+==== Recovery cache
+
+In order to track in-doubt transactions and be able to reply them Infinispan caches all transaction state for future use. This state is held only for in-doubt transaction, being removed for successfully completed transactions after the commit/rollback phase completed.
+
+This in-doubt transaction data is held within a local cache: this allows one to configure swapping this info to disk through cache loader in the case it gets too big. This cache can be specified through the  "recoveryInfoCacheName" configuration attribute. If not specified infinispan will configure a local cache for you.
+
+ It is possible (though not mandated) to share same recovery cache between all the Infinispan caches that have recovery enabled.  If default recovery cache is overridden then the specified recovery cache must use a link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/transaction/lookup/class-use/TransactionManagerLookup.html$$[TransactionManagerLookup] that returns a different TM than the one used by the cache itself. 
+
+[[sid-68355080_Transactionrecovery-IntegrationwiththeTM]]
+
+
+=== Integration with the TM
+
+Even though this is TM specific, generally the TM would need a reference to a XAResource imlementation in order to run XAResource.recover on it. In order to obtain a reference to a Infinispan XAResource following API can be used:
+
+
+----
+XAResource xar = cache.getAdvancedCache().getXAResource();  
+
+----
+
+ Note: It is a common practice to run the recovery in a different process than the one running the transaction. At the moment it is not possible to do this with infinispan: the recovery must be run from the same process where the infinispan instance exists. This limitation will be dropped once link:$$https://issues.jboss.org/browse/ISPN-375$$[ransactions over HotRod are available] . 
+
+[[sid-68355080_Transactionrecovery-Reconciliatestate]]
+
+
+=== conciliate state
+
+The TM informs the SA on in-doubt transaction in a proprietary way. At this stage it is assumed that the SA knows transaction's XID (byte array).
+
+A normal recovery flow is:
+
+1. SA connects to an Infinispan server through JMX, and lists the in doubt transactions
+
+The image below is taken with JCosole connecting to an Infinispan node that has an in doubt transaction.
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ The status of each in-doubt transaction is displayed(in this example " _PREPARED_ "). There might be multiple elements in the status field, e.g. "PREPARED" and "COMMITTED" in the case the transaction committed on certain nodes but not on all of them.   
+
+2. SA visually maps the XID received from the TM to an Infinispna internal id, represented as a number. This step is needed because the XID, a byte array, cannot conveniently be passed to the JMX tool (e.g. JConsole) and then re-assembled on infinispan's side.
+
+3. SA forces the transaction's commit/rollback through the corresponding jmx operation, based on the internal id.
+
+The image below is obtained by forcing the commit of the transaction based on its internal id.
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ _Note:_ All JMX operations described above can be executed on any node, disregarding where the transaction originated. 
+
+[[sid-68355080_Transactionrecovery-Forcecommit%2FrollbackbasedonXID]]
+
+
+==== Force commit/rollback based on XID
+
+XID-based JMX operations for forcing in-doubt transactions' commit/rollback are available as well: these methods receive byte[] arrays describing the XID instead of the number associated with the transactions (as previously described at step 2). These can be useful e.g. if one wants to set up an automatic completion job for certain in-doubt transactions. This process is plugged into TM's recovery and has access to the TM's XID objects.
+
+[[sid-68355080_Transactionrecovery-Wanttoknowmore%3F]]
+
+
+=== Want to know more?
+
+The recovery design document describes in more detail the insides of transaction recovery implementation.
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-38-Implementing_standalone_JPA_JTA_Hibernate_application_outside_J2EE_server_using_Infinispan_2nd_level_cache.adoc b/documentation/src/main/asciidoc/user_guide/chapter-38-Implementing_standalone_JPA_JTA_Hibernate_application_outside_J2EE_server_using_Infinispan_2nd_level_cache.adoc
new file mode 100644
index 0000000..85689da
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-38-Implementing_standalone_JPA_JTA_Hibernate_application_outside_J2EE_server_using_Infinispan_2nd_level_cache.adoc
@@ -0,0 +1,644 @@
+[[sid-68355081]]
+
+==  Implementing standalone JPA JTA Hibernate application outside J2EE server using Infinispan 2nd level cache
+
+[[sid-68355081_ImplementingstandaloneJPAJTAHibernateapplicationoutsideJ2EEserverusingInfinispan2ndlevelcache-Introduction]]
+
+
+=== Introduction
+
+ _IMPORTANT NOTE: From Hibernate 4.0.1 onwards, Infinispan now interacts as a synchronization rather than as an XA resource with the transaction manager when used as second-level cache, so there's no longer need to apply any of the changes suggested below!_ 
+
+ Infinispans predecessor link:$$http://www.jboss.org/file-access/default/members/jbossclustering/freezone/docs/hibernate-caching/3.3/en-US/html/introduction-requirements.html$$[JBossCache requires integration with JTA] when used as 2L-cache for a Hibernate application.  At the moment of writing this article (Hibernate 3.5.0.Beta3) also Infinspan requires integration with JTA.  Hibernate integrated with JTA is already largely used in EJB applications servers, but most users using Hibernate with Java SE outside any EJB container, still use the plain JDBC approach instead to use JTA. 
+
+According Hiberante documentation it should also possible to integrate JTA in a standalone application outside any EJB container, but I did hardly find any documentation how to do that in detail. (probably the reason is, that probably 95% of people is using hibernate within a EJB app. server or using SPRING).  This article should give you some example how to realize a standalone Hibernate app. outside of a EJB container with JTA integration (and using Infinispan 2nd level cache).
+
+As first thing you have to choose which implementation of TransactionManager to take.  This article comes with examples for following OpenSource TransactionManagers:
+
+
+. JBoss
+
+
+. JOTM
+
+
+. Bitronix
+
+
+. Atomikos
+
+
+[NOTE]
+.Datasource/Transaction interaction
+==== 
+A very important aspect is not forgetting to couple the datasource with your transaction manager. In other words, the corresponding XAResource must be onto the transaction manager, otherwise only DML-statements but no commits/rollbacks are propagated to your database.
+
+
+==== 
+
+
+[[sid-68355081_ImplementingstandaloneJPAJTAHibernateapplicationoutsideJ2EEserverusingInfinispan2ndlevelcache-JBossTransactions]]
+
+
+=== JBoss Transactions
+
+The example with JBoss Transactions Transaction Manager was the most complex to implement, as JBoss's TransactionManager and UserTransaction objects are not declared serializable whilst it's JNDI-server isn't able to bind non serializable objects out of the box. Special use of NonSerializableFactory is needed, requiring some additional custom code:
+
+
+----
+import hello.A;  // a persistent class
+import java.io.Serializable;
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.util.Properties;
+
+import javax.naming.Context;
+import javax.naming.InitialContext;
+import javax.naming.Name;
+import javax.naming.NameNotFoundException;
+import javax.naming.Reference;
+import javax.naming.StringRefAddr;
+import javax.persistence.EntityManager;
+import javax.persistence.Persistence;
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+
+import org.enhydra.jdbc.standard.StandardXADataSource;
+import org.hibernate.Session;
+import org.hibernate.SessionFactory;
+import org.hibernate.ejb.HibernateEntityManagerFactory;
+import org.hibernate.transaction.JBossTransactionManagerLookup;
+import org.infinispan.transaction.lookup.JBossStandaloneJTAManagerLookup;
+import org.jboss.util.naming.NonSerializableFactory;
+import org.jnp.interfaces.NamingContext;
+import org.jnp.server.Main;
+import org.jnp.server.NamingServer;
+
+public class JTAStandaloneExampleJBossTM  {
+    
+    static JBossStandaloneJTAManagerLookup _ml =  new JBossStandaloneJTAManagerLookup();
+    
+
+    public static void main(String[] args) {
+        try {
+            // Create an in-memory jndi
+            NamingServer namingServer = new NamingServer();
+            NamingContext.setLocal(namingServer);
+            Main namingMain = new Main();
+            namingMain.setInstallGlobalService(true);
+            namingMain.setPort(-1);
+            namingMain.start();
+            
+            Properties props = new Properties();
+            props.put(Context.INITIAL_CONTEXT_FACTORY, "org.jnp.interfaces.NamingContextFactory");
+            props.put("java.naming.factory.url.pkgs", "org.jboss.naming:org.jnp.interfaces");
+           
+            InitialContext ictx = new InitialContext( props );
+  
+            
+            // as JBossTransactionManagerLookup extends JNDITransactionManagerLookup we must also register the TransactionManager
+            bind("java:/TransactionManager", _ml.getTransactionManager(), _ml.getTransactionManager().getClass(), ictx);
+            
+            // also the UserTransaction must be registered on jndi: org.hibernate.transaction.JTATransactionFactory#getUserTransaction() requires this
+            bind(new JBossTransactionManagerLookup().getUserTransactionName(),_ml.getUserTransaction(),_ml.getUserTransaction().getClass(), ictx);
+            
+            ExtendedXADataSource xads = new ExtendedXADataSource();  
+            xads.setDriverName("org.hsqldb.jdbcDriver");
+            xads.setDriverName("com.p6spy.engine.spy.P6SpyDriver"); // comment this line if you don't want p6spy-logging
+            xads.setUrl("jdbc:hsqldb:hsql://localhost");    
+            //xads.setTransactionManager(_ml.getTransactionManager()); useless here as this information is not serialized
+                                                                   
+            ictx.bind("java:/MyDatasource", xads);          
+
+            final HibernateEntityManagerFactory emf =  (HibernateEntityManagerFactory) Persistence.createEntityManagerFactory("helloworld");          
+       
+            UserTransaction userTransaction = _ml.getUserTransaction();
+            userTransaction.setTransactionTimeout(300000);
+            //SessionFactory sf = (SessionFactory) ictx.lookup("java:/hibernate/MySessionFactory"); // if hibernate.session_factory_name set
+            final SessionFactory sf = emf.getSessionFactory(); 
+
+            userTransaction.begin();
+            EntityManager em = emf.createEntityManager();
+            
+            // do here your persistent work
+            A a = new A();
+            a.name= "firstvalue";
+            em.persist(a);
+            em.flush();     // do manually flush here as apparently FLUSH_BEFORE_COMPLETION seems not work, bug ?
+
+            System.out.println("\nCreated and flushed instance a with id : " + a.oid + "  a.name set to:" + a.name);
+
+            System.out.println("Calling userTransaction.commit() (Please check if the commit is effectively executed!)");
+            userTransaction.commit();
+           
+            
+            ictx.close();
+            namingMain.stop();
+            emf.close();
+                
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        System.exit(0);
+    }
+    
+   public static class ExtendedXADataSource extends StandardXADataSource { // XAPOOL
+        
+        @Override
+        public Connection getConnection() throws SQLException {
+            
+            if (getTransactionManager() == null) { // although already set before, it results null again after retrieving the datasource by jndi  
+                TransactionManager tm;  // this is because the TransactionManager information is not serialized.
+                try {
+                    tm = _ml.getTransactionManager();
+                } catch (Exception e) {
+                    throw new SQLException(e);
+                }
+                setTransactionManager(tm);  //  resets the TransactionManager on the datasource retrieved by jndi, 
+                                            //  this makes the datasource JTA-aware
+            }
+            
+            // According to Enhydra documentation, here we must return the connection of our XAConnection
+            // see http://cvs.forge.objectweb.org/cgi-bin/viewcvs.cgi/xapool/xapool/examples/xapooldatasource/DatabaseHelper.java?sortby=rev
+            return super.getXAConnection().getConnection();
+        }
+    }
+    
+    /**
+     * Helper method that binds the a non serializable object to the JNDI tree.
+     * 
+     * @param jndiName Name under which the object must be bound
+     * @param who Object to bind in JNDI
+     * @param classType Class type under which should appear the bound object
+     * @param ctx Naming context under which we bind the object
+     * @throws Exception Thrown if a naming exception occurs during binding
+     */
+    private static void bind(String jndiName, Object who, Class classType, Context ctx) throws Exception {
+       // Ah ! This service isn't serializable, so we use a helper class
+       NonSerializableFactory.bind(jndiName, who);
+       Name n = ctx.getNameParser("").parse(jndiName);
+       while (n.size() > 1) {
+          String ctxName = n.get(0);
+          try {
+             ctx = (Context) ctx.lookup(ctxName);
+          } catch (NameNotFoundException e) {
+             System.out.println("Creating subcontext:" + ctxName);
+             ctx = ctx.createSubcontext(ctxName);
+          }
+          n = n.getSuffix(1);
+       }
+
+       // The helper class NonSerializableFactory uses address type nns, we go on to
+       // use the helper class to bind the service object in JNDI
+       StringRefAddr addr = new StringRefAddr("nns", jndiName);
+       Reference ref = new Reference(classType.getName(), addr, NonSerializableFactory.class.getName(), null);
+       ctx.rebind(n.get(0), ref);
+    }
+    
+    private static void unbind(String jndiName, Context ctx) throws Exception {
+       NonSerializableFactory.unbind(jndiName);
+       ctx.unbind(jndiName);
+    }
+
+}
+ 
+----
+
+The content of the corresponding complete persistence.xml:
+
+
+----
+<persistence xmlns="http://java.sun.com/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"  version="1.0">
+   <persistence-unit name="helloworld" transaction-type="JTA">
+      <jta-data-source>java:/MyDatasource</jta-data-source>
+      <properties>
+       <property name="hibernate.hbm2ddl.auto" value = "create"/> 
+       <property name="hibernate.archive.autodetection" value="class, hbm"/>
+           <property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect"/>
+
+           <property name="hibernate.jndi.class" value="org.jnp.interfaces.NamingContextFactory"/> 
+           <property name="hibernate.transaction.manager_lookup_class" value="org.hibernate.transaction.JBossTransactionManagerLookup"/> 
+
+        <property name="current_session_context_class" value="jta"/>
+           <!-- <property name="hibernate.session_factory_name" value="java:/hibernate/MySessionFactory"/> optional --> 
+           <property name="hibernate.transaction.factory_class" value="org.hibernate.transaction.JTATransactionFactory"/>
+           <property name="hibernate.connection.release_mode" value="auto"/> 
+           <!-- setting above is important using XA-DataSource on SQLServer, 
+                otherwise SQLServerException: The function START: has failed. No transaction cookie was returned.-->
+
+         <property name="hibernate.cache.use_second_level_cache" value="true"/>
+            <property name="hibernate.cache.use_query_cache" value="true"/>
+     
+         <property name="hibernate.cache.region.factory_class"   value="org.hibernate.cache.infinispan.InfinispanRegionFactory"/>
+         
+      </properties>
+   </persistence-unit>
+</persistence>
+
+----
+
+[[sid-68355081_ImplementingstandaloneJPAJTAHibernateapplicationoutsideJ2EEserverusingInfinispan2ndlevelcache-JOTM]]
+
+
+=== JOTM
+
+The example with JOTM is more simple, but apparently it's JNDI implementation is not useable without wasting any rmi port. So it is not completely 'standalone' as the JNDI service is exposed outside your virtual machine.
+
+
+----
+ 
+import hello.A; // a persistent class
+
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.util.Properties;
+
+import javax.naming.Context;
+import javax.naming.InitialContext;
+import javax.persistence.EntityManager;
+import javax.persistence.EntityManagerFactory;
+import javax.persistence.Persistence;
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+
+import org.enhydra.jdbc.standard.StandardXADataSource;
+import org.hibernate.transaction.JOTMTransactionManagerLookup;
+import org.objectweb.jotm.Jotm;
+import org.objectweb.transaction.jta.TMService;
+
+
+public class JTAExampleJOTM {
+    
+ static JOTMTransactionManagerLookup _ml =  new JOTMTransactionManagerLookup();
+ 
+ public static class ExtendedXADataSource extends StandardXADataSource { // XAPOOL   
+        @Override
+        public Connection getConnection() throws SQLException {
+            if (getTransactionManager() == null) { // although already set before, it results null again after retrieving the datasource by jndi  
+                TransactionManager tm;  // this is because the TransactionManager information is not serialized.
+                try {
+                    tm = _ml.getTransactionManager(null);
+                } catch (Exception e) {
+                    throw new SQLException(e);
+                }
+                setTransactionManager(tm);  //  resets the TransactionManager on the datasource retrieved by jndi, 
+                                            //  this makes the datasource JTA-aware
+            }
+            
+            // According to Enhydra documantation, here we must return the connection of our XAConnection
+            // see http://cvs.forge.objectweb.org/cgi-bin/viewcvs.cgi/xapool/xapool/examples/xapooldatasource/DatabaseHelper.java?sortby=rev
+            return super.getXAConnection().getConnection();
+        }
+    }
+
+    
+    public static void main( String[] args )
+    {
+        try
+        {
+            java.rmi.registry.LocateRegistry.createRegistry(1099); // also possible to lauch by command line rmiregistry
+            System.out.println("RMI registry ready.");
+
+            
+           // following properties can be left out if specifying thes values in a file jndi.properties located into classpath
+            Properties props = new Properties();
+            props.put(Context.INITIAL_CONTEXT_FACTORY, "org.ow2.carol.jndi.spi.MultiOrbInitialContextFactory");
+           InitialContext jndiCtx = new InitialContext(props);
+           
+       
+        // XAPOOL
+           ExtendedXADataSource xads = new ExtendedXADataSource();  
+           xads.setDriverName("org.hsqldb.jdbcDriver");
+           xads.setDriverName("com.p6spy.engine.spy.P6SpyDriver");
+           xads.setUrl("jdbc:hsqldb:hsql://localhost");
+          
+           jndiCtx.bind("java:/MyDatasource", xads);
+         
+ 
+           
+           /* startup JOTM */
+           TMService jotm = new Jotm(true, false);
+           jotm.getUserTransaction().setTransactionTimeout(36000); // secs, important JOTM default is only 60 secs ! 
+           
+           
+           /* and get a UserTransaction */
+           UserTransaction userTransaction = jotm.getUserTransaction();
+           
+
+           jndiCtx.bind("java:comp/UserTransaction", jotm.getUserTransaction()); // this is needed by hibernates JTATransactionFactory
+
+           /* get the Hibernate SessionFactory */
+           EntityManagerFactory emf =    Persistence.createEntityManagerFactory("helloworld");
+           //SessionFactory sf = (SessionFactory) jndiCtx.lookup("java:/hibernate/MySessionFactory");
+           
+           // begin a new Transaction
+           userTransaction.begin();
+           EntityManager em = emf.createEntityManager();
+          
+           A a = new A();
+           a.name= "firstvalue";
+           em.persist(a);
+           em.flush();     // do manually flush here as apparently FLUSH_BEFORE_COMPLETION seems not work, bug ?
+
+           System.out.println("Calling userTransaction.commit() (Please check if the commit is effectively executed!)");
+           userTransaction.commit();
+           
+           
+           // stop the transaction manager
+           jotm.stop();
+           jndiCtx.close();
+           emf.close();
+           
+          
+        }
+        catch( Exception e )
+        {
+           e.printStackTrace();
+        }
+        System.exit(0);
+     }
+
+}
+
+----
+
+Adjust following 2 properties in your persistence.xml:
+
+
+----
+
+<property name="hibernate.jndi.class" value="org.ow2.carol.jndi.spi.MultiOrbInitialContextFactory"/> 
+<property name="hibernate.transaction.manager_lookup_class" value="org.hibernate.transaction.JOTMTransactionManagerLookup"/>
+
+----
+
+ For using the JTA Hibernate application as servlet in tomcat please read  link:$$http://jotm.objectweb.org/current/jotm/doc/howto-tomcat-jotm.html$$[] and also link:$$https://forum.hibernate.org/viewtopic.php?f=1&amp;t=1003866$$[] 
+
+[[sid-68355081_ImplementingstandaloneJPAJTAHibernateapplicationoutsideJ2EEserverusingInfinispan2ndlevelcache-Bitronix]]
+
+
+=== Bitronix
+
+ The Transaction Manager comes bundled with a fake in memory jndi-implementation which is ideal for standalone purpose. To integrate with Infinispan I did need a ad-hoc pre-alpha improvement (see attached link:$$https://docs.jboss.org/author/download/attachments/68355081/btm-ispn.jar?version=1&amp;modificationDate=1308852871000$$[btm-ispn.jar] by courtesy of  Mr. Ludivic Orban). BitronixTM offers the so-called Last Resource Commit optimization (aka Last Resource Gambit or Last Agent optimization) and it allows a single non-XA database to participate in a XA transaction by cleverly ordering the resources. "Last Resource Commit" is not part of the XA spec as it doesn't cover the transaction-recovery aspect, so if your database does not support XA (or if you don't wish to have the Xa-driver performance overhead against the plain jdbc) then the "Last Resource Commit" feature should be ideal for the combination 1 single database plus infinispan. 
+
+
+----
+
+import hello.A; // a persistent class
+
+import java.util.Properties;
+
+import javax.naming.Context;
+import javax.naming.InitialContext;
+import javax.persistence.EntityManager;
+import javax.persistence.Persistence;
+import javax.transaction.UserTransaction;
+
+import org.hibernate.cache.infinispan.InfinispanRegionFactory;
+import org.hibernate.ejb.HibernateEntityManagerFactory;
+import org.hibernate.impl.SessionFactoryImpl;
+import org.infinispan.manager.CacheManager;
+
+import bitronix.tm.resource.ResourceRegistrar;
+import bitronix.tm.resource.infinispan.InfinispanCacheManager;
+import bitronix.tm.resource.jdbc.PoolingDataSource;
+
+
+
+public class JTAExampleBTM  {
+    public static void main(String[] args) {
+        try { 
+             Properties props = new Properties();
+             props.put(Context.INITIAL_CONTEXT_FACTORY, "bitronix.tm.jndi.BitronixInitialContextFactory");
+             // Attention: BitronixInitialContextFactory is'nt a real jndi implementation: you can't do explicit bindings
+             // It is ideal for hiberante standalone usage, as it automatically 'binds' the needed things: datasource + usertransaction
+            
+             System.out.println("create initial context");
+             InitialContext ictx = new InitialContext(props);
+            
+             PoolingDataSource myDataSource = new PoolingDataSource();
+             myDataSource.setClassName("bitronix.tm.resource.jdbc.lrc.LrcXADataSource");
+             
+             myDataSource.setMaxPoolSize(5);
+             myDataSource.setAllowLocalTransactions(true);
+             
+             myDataSource.getDriverProperties().setProperty("driverClassName", "com.p6spy.engine.spy.P6SpyDriver");
+             myDataSource.getDriverProperties().setProperty("url", "jdbc:hsqldb:hsql://localhost");
+             myDataSource.getDriverProperties().setProperty("user", "sa");
+             myDataSource.getDriverProperties().setProperty("password", "");
+             myDataSource.setUniqueName("java:/MyDatasource");
+             myDataSource.setAutomaticEnlistingEnabled(true); // important to keep it to true (default), otherwise commits/rollbacks are not propagated
+             myDataSource.init(); // does also register the datasource on the Fake-JNDI with Unique Name
+             
+             org.hibernate.transaction.BTMTransactionManagerLookup lokhiberante = new org.hibernate.transaction.BTMTransactionManagerLookup();
+
+             HibernateEntityManagerFactory emf =  (HibernateEntityManagerFactory)  Persistence.createEntityManagerFactory("helloworld");
+             SessionFactoryImpl sfi = (SessionFactoryImpl) emf.getSessionFactory();
+             InfinispanRegionFactory infinispanregionfactory = (InfinispanRegionFactory) sfi.getSettings().getRegionFactory();
+             CacheManager manager = infinispanregionfactory.getCacheManager();
+             
+             // register Inifinispan as a BTM resource
+             InfinispanCacheManager icm = new InfinispanCacheManager();
+             icm.setUniqueName("infinispan");
+             ResourceRegistrar.register(icm); 
+             icm.setManager(manager);
+
+            final UserTransaction userTransaction = (UserTransaction) ictx.lookup(lokhiberante.getUserTransactionName());
+
+            // begin a new Transaction
+            userTransaction.begin();
+            EntityManager em = emf.createEntityManager();
+           
+            A a = new A();
+            a.name= "firstvalue";
+            em.persist(a);
+            em.flush();     // do manually flush here as apparently FLUSH_BEFORE_COMPLETION seems not work, bug ?
+
+            System.out.println("Calling userTransaction.commit() (Please check if the commit is effectively executed!)");
+            userTransaction.commit();
+           
+            emf.close();
+
+        } catch (Exception e) {
+            e.printStackTrace();
+            System.exit(1);
+        }
+         System.exit(0);
+   
+    }
+}
+
+----
+
+Adjust following 2 properties in your corresponding persistence.xml:
+
+
+----
+
+<property name="hibernate.jndi.class" value="bitronix.tm.jndi.BitronixInitialContextFactory"/> 
+<property name="hibernate.transaction.manager_lookup_class" value="org.hibernate.transaction.BTMTransactionManagerLookup"/> 
+
+----
+
+[[sid-68355081_ImplementingstandaloneJPAJTAHibernateapplicationoutsideJ2EEserverusingInfinispan2ndlevelcache-Atominkos]]
+
+
+=== Atominkos
+
+ Last but not least, the Atomikos Transaction manager. It is currently the unique Transaction manager I've found with a online-documentation on link:$$http://www.atomikos.com/Documentation/HibernateIntegration#Without_Spring$$[how to integrate with Hiberante] link:$$http://www.atomikos.com/Documentation/HibernateIntegration#Without_Spring$$[without Spring, outside any J2EE container.] . It seems to be the unique supporting XaDataSource together with Pooling, so it doesn't matter that It does not come  with it's own JNDI implementation (we will use the one of JBoss in following example). 
+
+
+----
+ 
+import hello.A; // a persistent class
+
+import java.io.Serializable;
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.util.Properties;
+
+import javax.naming.Context;
+import javax.naming.InitialContext;
+import javax.naming.Name;
+import javax.naming.NameNotFoundException;
+import javax.naming.Reference;
+import javax.naming.StringRefAddr;
+import javax.persistence.EntityManager;
+import javax.persistence.Persistence;
+import javax.transaction.TransactionManager;
+import javax.transaction.UserTransaction;
+
+import org.hibernate.Session;
+import org.hibernate.SessionFactory;
+import org.hibernate.ejb.HibernateEntityManagerFactory;
+import org.hibernate.impl.SessionFactoryImpl;
+
+import org.jboss.util.naming.NonSerializableFactory;
+import org.jnp.interfaces.NamingContext;
+import org.jnp.server.Main;
+import org.jnp.server.NamingServer;
+
+import com.atomikos.icatch.jta.hibernate3.TransactionManagerLookup;
+import com.atomikos.jdbc.AtomikosDataSourceBean;
+import com.atomikos.jdbc.SimpleDataSourceBean;
+
+public class JTAStandaloneExampleAtomikos  {
+    
+    public static void main(String[] args) {
+        try {
+            // Create an in-memory jndi
+            NamingServer namingServer = new NamingServer();
+            NamingContext.setLocal(namingServer);
+            Main namingMain = new Main();
+            namingMain.setInstallGlobalService(true);
+            namingMain.setPort(-1);
+            namingMain.start();
+            
+            Properties props = new Properties();
+            props.put(Context.INITIAL_CONTEXT_FACTORY, "org.jnp.interfaces.NamingContextFactory");
+            props.put("java.naming.factory.url.pkgs", "org.jboss.naming:org.jnp.interfaces");
+           
+            InitialContext ictx = new InitialContext( props );
+  
+            AtomikosDataSourceBean ds = new AtomikosDataSourceBean();
+            ds.setUniqueResourceName("sqlserver_ds");
+            ds.setXaDataSourceClassName("com.microsoft.sqlserver.jdbc.SQLServerXADataSource");
+            Properties p = new Properties();
+            p.setProperty ( "user" , "sa" );
+            p.setProperty ( "password" , "" );
+            p.setProperty ( "serverName" , "myserver" );
+            ds.setXaProperties ( p );
+            ds.setPoolSize(5);
+            bind("java:/MyDatasource", ds, ds.getClass(), ictx);
+            
+            TransactionManagerLookup _ml = new TransactionManagerLookup();
+            UserTransaction userTransaction = new com.atomikos.icatch.jta.UserTransactionImp();
+            
+            bind("java:/TransactionManager", _ml.getTransactionManager(null), _ml.getTransactionManager(null).getClass(), ictx);
+            bind("java:comp/UserTransaction", userTransaction, userTransaction.getClass(), ictx);
+
+            HibernateEntityManagerFactory emf =  (HibernateEntityManagerFactory) Persistence.createEntityManagerFactory("helloworld");          
+
+            // begin a new Transaction
+            userTransaction.begin();
+            EntityManager em = emf.createEntityManager();
+           
+            A a = new A();
+            a.name= "firstvalue";
+            em.persist(a);
+            em.flush();     // do manually flush here as apparently FLUSH_BEFORE_COMPLETION seems not work, bug ?
+
+            System.out.println("Calling userTransaction.commit() (Please check if the commit is effectively executed!)");
+            userTransaction.commit();
+           
+            emf.close();
+            
+        } catch (Exception e) {
+            e.printStackTrace();
+            System.exit(1);
+        }
+         System.exit(0);
+    }
+    
+    /**
+     * Helper method that binds the a non serializable object to the JNDI tree.
+     * 
+     * @param jndiName Name under which the object must be bound
+     * @param who Object to bind in JNDI
+     * @param classType Class type under which should appear the bound object
+     * @param ctx Naming context under which we bind the object
+     * @throws Exception Thrown if a naming exception occurs during binding
+     */
+    private static void bind(String jndiName, Object who, Class<?> classType, Context ctx) throws Exception {
+       // Ah ! This service isn't serializable, so we use a helper class
+       NonSerializableFactory.bind(jndiName, who);
+       Name n = ctx.getNameParser("").parse(jndiName);
+       while (n.size() > 1) {
+          String ctxName = n.get(0);
+          try {
+             ctx = (Context) ctx.lookup(ctxName);
+          } catch (NameNotFoundException e) {
+             System.out.println("Creating subcontext:" + ctxName);
+             ctx = ctx.createSubcontext(ctxName);
+          }
+          n = n.getSuffix(1);
+       }
+
+       // The helper class NonSerializableFactory uses address type nns, we go on to
+       // use the helper class to bind the service object in JNDI
+       StringRefAddr addr = new StringRefAddr("nns", jndiName);
+       Reference ref = new Reference(classType.getName(), addr, NonSerializableFactory.class.getName(), null);
+       ctx.rebind(n.get(0), ref);
+    }
+    
+    private static void unbind(String jndiName, Context ctx) throws Exception {
+       NonSerializableFactory.unbind(jndiName);
+       ctx.unbind(jndiName);
+    }
+
+}
+
+
+----
+
+Adjust follwing 2 properties in your corresponding persistence.xml:
+
+
+----
+<property name="hibernate.jndi.class" value="org.jnp.interfaces.NamingContextFactory"/>   
+<property name="hibernate.transaction.manager_lookup_class" value="com.atomikos.icatch.jta.hibernate3.TransactionManagerLookup"/>
+
+----
+
+And create a file named jta.properties in your classpath with following content:
+
+
+----
+
+com.atomikos.icatch.service=com.atomikos.icatch.standalone.UserTransactionServiceFactory
+com.atomikos.icatch.automatic_resource_registration=false
+com.atomikos.icatch.console_log_level=WARN
+com.atomikos.icatch.force_shutdown_on_vm_exit=true
+com.atomikos.icatch.enable_logging=false
+----
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-39-Infinispan_Maven_Archetypes.adoc b/documentation/src/main/asciidoc/user_guide/chapter-39-Infinispan_Maven_Archetypes.adoc
new file mode 100644
index 0000000..0c43e55
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-39-Infinispan_Maven_Archetypes.adoc
@@ -0,0 +1,151 @@
+[[sid-68355082]]
+
+==  Infinispan Maven Archetypes
+
+ Infinispan currently has 2 separate Maven link:$$http://maven.apache.org/guides/introduction/introduction-to-archetypes.html$$[archetypes] you can use to create a skeleton project and get started using Infinispan.  This is an easy way to get started using Infinispan as the archetype generates sample code, a sample Maven pom.xml with necessary depedencies, etc. 
+
+
+.
+****
+NOTE:  You don't need to have any experience with or knowledge of Maven's Archetypes to use this!  Just follow the simple steps below.
+
+
+****
+
+
+
+.
+****
+ WARNING: These archetypes have only been tested with link:$$http://maven.apache.org/docs/3.0.1/release-notes.html$$[Maven 3] .  Please report back if you have any success with using Maven 2. 
+
+
+****
+
+
+[[sid-68355082_InfinispanMavenArchetypes-Startinganewproject]]
+
+
+=== Starting a new project
+
+Use the newproject-archetype project.  The simple command below will get you started, and
+
+
+----
+$ mvn archetype:generate \
+    -DarchetypeGroupId=org.infinispan.archetypes \
+    -DarchetypeArtifactId=newproject-archetype \
+    -DarchetypeVersion=1.0.13 \
+    -DarchetypeRepository=http://repository.jboss.org/nexus/content/groups/public
+
+----
+
+ You will be prompted for a few things, including the _artifactId_ , _groupId_ and _version_ of your new project.  And that's it - you're ready to go! 
+
+[[sid-68355082_InfinispanMavenArchetypes-Playingwithyournewproject]]
+
+
+==== Playing with your new project
+
+ The skeleton project ships with a sample application class, interacting with Infinispan.  You should open this new project in your IDE - most good IDEs such as IntelliJ and Eclipse allow you to import Maven projects, see link:$$http://www.jetbrains.com/idea/webhelp/importing-maven-project.html$$[this guide] and link:$$http://m2eclipse.sonatype.org/$$[this guide] .  Once you open your project in your IDE, you should examine the generated classes and read through the comments. 
+
+[[sid-68355082_InfinispanMavenArchetypes-Onthecommandline...]]
+
+
+==== On the command line...
+
+ Try running 
+
+
+----
+$ mvn install -Prun
+----
+
+in your newly generated project!  This runs the main() method in the generated application class.
+
+[[sid-68355082_InfinispanMavenArchetypes-WritingatestcaseforInfinispan]]
+
+
+=== Writing a test case for Infinispan
+
+This archetype is useful if you wish to contribute a test to the Infinispan project and helps you get set up to use Infinispan's testing harness and related tools.
+
+ Use 
+
+
+----
+$ mvn archetype:generate \
+    -DarchetypeGroupId=org.infinispan.archetypes \
+    -DarchetypeArtifactId=testcase-archetype \
+    -DarchetypeVersion=1.0.13 \
+    -DarchetypeRepository=http://repository.jboss.org/nexus/content/groups/public
+----
+
+As above, this will prompt you for project details and again as above, you should open this project in your IDE.  Once you have done so, you will see some sample tests written for Infinispan making use of Infinispan's test harness and testing tools along with extensive comments and links for further reading.
+
+[[sid-68355082_InfinispanMavenArchetypes-Onthecommandline...x]]
+
+
+==== On the command line...
+
+ Try running 
+
+
+----
+$ mvn test 
+----
+
+in your newly generated project to run your tests.
+
+The generated project has a few different profiles you can use as well, using Maven's -P flag.  E.g.,
+
+
+----
+$ mvn test -Pudp
+----
+
+[[sid-68355082_InfinispanMavenArchetypes-Availableprofiles]]
+
+
+==== Available profiles
+
+The profiles available in the generated sample project are:
+
+
+* udp: use UDP for network communications rather than TCP
+
+
+* tcp: use TCP for network communications rather than UDP
+
+
+*  jbosstm: Use the embedded link:$$http://www.jboss.org/jbosstm$$[JBoss Transaction Manager] rather than Infinispan's dummy test transaction manager 
+
+[[sid-68355082_InfinispanMavenArchetypes-ContributingtestsbacktoInfinispan]]
+
+
+==== Contributing tests back to Infinispan
+
+ If you have written a functional, unit or stress test for Infinispan and want to contribute this back to Infinispan, your best bet is to link:$$https://github.com/infinispan/infinispan$$[fork the Infinispan sources on GitHub] .  The test you would have prototyped and tested in an isolated project created using this archetype can be simply dropped in to Infinispan's test suite.  Make your changes, add your test, prove that it fails even on Infinispan's upstream source tree and issue a link:$$http://help.github.com/pull-requests/$$[pull request] . 
+
+
+.
+****
+ TIP: New to working with Infinispan and GitHub?  Want to know how best to work with the repositories and contribute code?  Read link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=68355224$$[Infinispan and GitHub] 
+
+
+****
+
+
+[[sid-68355082_InfinispanMavenArchetypes-Versions]]
+
+
+=== Versions
+
+The archetypes generate poms with dependencies to specific versions of Infinispan.  You should edit these generated poms by hand to point to other versions of Infinispan that you are interested in.
+
+[[sid-68355082_InfinispanMavenArchetypes-SourceCode]]
+
+
+=== Source Code
+
+ The source code used to generate these archetypes are link:$$https://github.com/infinispan/infinispan-archetypes$$[on GitHub] .  If you wish to enhance and contribute back to the project, fork away! 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-4-New_in_Infinispan_5_2_0.adoc b/documentation/src/main/asciidoc/user_guide/chapter-4-New_in_Infinispan_5_2_0.adoc
new file mode 100644
index 0000000..b762548
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-4-New_in_Infinispan_5_2_0.adoc
@@ -0,0 +1,13 @@
+[[sid-68355028_UserGuide-NewinInfinispan5.2.0]]
+
+==  New in Infinispan 5.2.0
+
+
+.  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=54493404$$[Cross-site replication] 
+
+
+.  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=60227604$$[Rolling upgrades] 
+
+
+.  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=61505925$$[Command-Line Interface (CLI)] 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-40-Accessing_data_in_Infinispan_via_RESTful_interface.adoc b/documentation/src/main/asciidoc/user_guide/chapter-40-Accessing_data_in_Infinispan_via_RESTful_interface.adoc
new file mode 100644
index 0000000..3c93a58
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-40-Accessing_data_in_Infinispan_via_RESTful_interface.adoc
@@ -0,0 +1,202 @@
+[[sid-68355085]]
+
+==  Accessing data in Infinispan via RESTful interface
+
+ 
+.TODO Gliffy image title empty
+image::[]
+
+ _Standards_ Red Hat is working towards standardization of the REST API as a part of the link:$$http://www.rest-star.org$$[REST-*] effort.  To participate in this standard, please visit link:$$http://groups.google.com/group/reststar-caching$$[this Google Group] 
+
+[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-Puttingdatain]]
+
+
+=== Putting data in
+
+ HTTP PUT and POST methods are used to place data in the cache - the data being the body of the request (the data can be anything you like). It is important that a Content-Type header is set. 
+
+[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-PUT%2F%5C%2F%5C]]
+
+
+==== PUT /{cacheName}/{cacheKey}
+
+ A PUT request of the above URL form will place the payload (body) in the given cache, with the given key (the named cache must exist on the server). For example link:$$http://someserver/hr/payRoll/3$$[] (in which case "hr" is the cache name, and "payRoll/3" is the key). Any existing data will be replaced, and Time-To-Live and Last-Modified values etc will updated (if applicable). 
+
+[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-POST%2F%5C%2F%5C]]
+
+
+==== POST /{cacheName}/{cacheKey}
+
+ Exactly the same as PUT, only if a value in a cache/key already exists, it will return a Http CONFLICT status (and the content will not be updated). 
+
+[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-Headers%3A]]
+
+
+==== Headers:
+
+
+*  Content-Type : MANDATORY (use link:$$http://www.iana.org/assignments/media-types/$$[media/mime-types] for example: "application/json"). 
+
+
+[NOTE]
+.Special case
+==== 
+ If you set the Content-Type to application/x-java-serialized-object , then it will be stored as a Java object 
+
+
+==== 
+
+
+
+*  performAsync : OPTIONAL true/false (if true, this will return immediately, and then replicate data to the cluster on its own. Can help with bulk data inserts/large clusters.) 
+
+
+*  timeToLiveSeconds : OPTIONAL number (the number of seconds before this entry will automatically be deleted) 
+
+
+* If no parameter is sent, Infinispan assumes -1 as default value, which means that the entry will not expire as a result of ttl. Passing any negative value will have the same effect.
+
+
+*  maxIdleTimeSeconds : OPTIONAL number (the number of seconds after last usage of this entry when it will automatically be deleted) 
+
+
+* If no  parameter is sent, Infinispan assumes -1 as default value, which means that the entry will not expire as a result of idle time. Passing any negative value will have the same effect.
+
+
+[NOTE]
+.Passing 0 as parameter for timeToLiveSeconds and/or maxIdleTimeSeconds
+==== 
+
+*  If both timeToLiveSeconds and maxIdleTimeSeconds are 0, the cache will use the default lifespan and maxIdle values configured in XML/programmatically 
+
+
+*  If _only_ maxIdleTimeSeconds is 0, it uses the timeToLiveSeconds value passed as parameter (or -1 if not present), and default maxIdle configured in XML/programmatically 
+
+
+*  If _only_ timeToLiveSeconds is 0, it uses 0 as timeToLiveSeconds meaning that it will expire immediately, and maxIdle is set whatever came as parameter (or -1 if not present) 
+
+
+==== 
+
+
+[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-Gettingdatabackout]]
+
+
+=== Getting data back out
+
+ HTTP GET and HEAD are used to retrieve data from entries. 
+
+[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-GET%2F%5C%2F%5C]]
+
+
+==== GET /{cacheName}/{cacheKey}
+
+ This will return the data found in the given cacheName, under the given key - as the body of the response. A Content-Type header will be supplied which matches what the data was inserted as (other then if it is a Java object, see below). Browsers can use the cache directly of course (eg as a CDN). An link:$$http://en.wikipedia.org/wiki/HTTP_ETag$$[ETag] will be returned unique for each entry, as will the Last-Modified and Expires headers field indicating the state of the data at the given URL. ETags allow browsers (and other clients) to ask for data only in the case where it has changed (to save on bandwidth) - this is standard HTTP and is honoured by Infinispan. 
+
+Since Infinispan 5.3 it is possible to obtain additional information by appending the "extended" parameter on the query string, as follows:
+
+
+----
+
+GET /cacheName/cacheKey?extended
+
+----
+
+This will return the following custom headers:
+
+
+* Cluster-Primary-Owner: the node name of the primary owner for this key
+
+
+* Cluster-Node-Name: the JGroups node name of the server that has handled the request
+
+
+* Cluster-Physical-Address: the physical JGroups address of the server that has handled the request.
+
+[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-HEAD%2F%5C%2F%5C]]
+
+
+==== HEAD /{cacheName}/{cacheKey}
+
+The same as GET, only no content is returned (only the header fields). You will receive the same content that you stored. E.g., if you stored a String, this is what you get back. If you stored some XML or JSON, this is what you will receive. If you stored a binary (base 64 encoded) blob, perhaps a serialized; Java; object - you will need to; deserialize this yourself.
+
+
+[WARNING]
+.Prior to Infinispan 4.2
+==== 
+ The behaviour was as follows: If the data in the grid is a Java object - there are a few options in how it can be returned, which use the HTTP Accept header: 
+
+
+*  application/xml - the object will be serialized via XStream to XML representation 
+
+
+*  application/json - the object will be sent via a JSON format (via Jackson) 
+
+
+*  application/x-java-serialized-object - if the object is Serializable, you can use this and get a stream of the Java Serialization form of the object (obviously only makes sense for java clients with a suitable class loaded). If its not Serializable, you have to use one of the other options. 
+
+
+==== 
+
+
+Similarly to the GET method, the HEAD method also supports returning extended information via headers. See above.
+
+[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-GET%2F%5C]]
+
+
+==== GET /{cacheName}
+
+This will return a list of keys present in the given cacheName as the body of the response. The format of the response can be controlled via the Accept header as follows:
+
+
+* application/xml - the list of keys will be returned in XML format.
+
+
+* application/json - the list of keys will be return in JSON format.
+
+
+* text/html - the list of keys will be returned in HTML format.
+
+
+* text/plain - the list of keys will be returned in plain text format, one key per line
+
+If the cache identified by cacheName is distributed, only the keys owned by the node handling the request will be returned. To return all keys, append the "global" parameter to the query, as follows:
+
+
+----
+
+GET /cacheName?global
+
+----
+
+[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-Removingdata]]
+
+
+=== Removing data
+
+Data can be removed at the cache key/element level, or via a whole cache name using the HTTP delete method.
+
+[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-DELETE%2F%5C%2F%5C]]
+
+
+==== DELETE /{cacheName}/{cacheKey}
+
+Removes the given key name from the cache.
+
+[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-DELETE%2F%5C]]
+
+
+==== DELETE /{cacheName}
+
+Removes ALL the entries in the given cache name (ie everything from that path down). If the operation is successful, it returns 200 code.
+
+
+[TIP]
+.Make it quicker!
+==== 
+Set the header performAsync to true to return immediately and let the removal happen in the background.
+
+
+==== 
+
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-41-Infinispan_Distributed_Execution_Framework.adoc b/documentation/src/main/asciidoc/user_guide/chapter-41-Infinispan_Distributed_Execution_Framework.adoc
new file mode 100644
index 0000000..81cdaa6
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-41-Infinispan_Distributed_Execution_Framework.adoc
@@ -0,0 +1,242 @@
+[[sid-68355086]]
+
+==  Infinispan Distributed Execution Framework
+
+[[sid-68355086_InfinispanDistributedExecutionFramework-Introduction]]
+
+
+=== Introduction
+
+ Infinispan provides distributed execution through a standard JDK link:$$http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ExecutorService.html$$[ExecutorService] interface. Tasks submitted for execution, instead of being executed in a local JVM, are executed on an entire cluster of Infinispan nodes. Every DistributedExecutorService is bound to one particular cache. Tasks submitted will have access to key/value pairs from that particular cache if and only if the task submitted is an instance of DistributedCallable. Also note that there is nothing preventing users from submitting a familiar Runnable or Callable just like to any other ExecutorService. However, DistributedExecutorService, as it name implies, will likely migrate submitted Callable or Runnable to another JVM in Infinispan cluster, execute it and return a result to task invoker. Due to a potential task migration to other nodes every Callable, Runnable and/or DistributedCallable submitted must be either Serializable or Externalizable. Also the value returned from a callable must be Serializable or Externalizable as well. If the value returned is not serializable a NotSerializableException will be thrown. 
+
+Infinispan's distributed task executors use data from Infinispan cache nodes as input for execution tasks. Most other distributed frameworks do not have that leverage and users have to specify input for distributed tasks from some well known location. Furthermore, users of Infinispan distributed execution framework do not have to configure store for intermediate and final results thus removing another layer of complexity and maintenance.
+
+Our distributed execution framework capitalizes on the fact input data in Infinispan data grid is already load balanced (in case of DIST mode). Since input data is already balanced execution tasks will be automatically balanced as well; users do not have to explicitly assign work tasks to specific Infinispan nodes. However, our framework accommodates users to specify arbitrary subset of cache keys as input for distributed execution tasks.
+
+[[sid-68355086_InfinispanDistributedExecutionFramework-DistributedCallableAPI]]
+
+
+=== DistributedCallable API
+
+ In case users needs access to Infinispan cache data for an execution of a task we recommend that you encapsulate task in link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/distexec/DistributedCallable.html$$[DistributedCallable] interface. DistributedCallable is a subtype of the existing Callable from java.util.concurrent package; DistributedCallable can be executed in a remote JVM and receive input from Infinispan cache. Task's main algorithm could essentially remain unchanged, only the input source is changed. Exisiting Callable implementations most likely get its input in a form of some Java object/primitive while DistributedCallable gets its input from Infinispan cache. Therefore, users who have already implemented Callable interface to describe their task units would simply extend DistributedCallable and use keys from Infinispan execution environment as input for the task. Implentation of DistributedCallable can in fact continue to support implementation of an already existing Callable while simultaneously be ready for distribited execution by extending DistributedCallable. 
+
+
+----
+public interface DistributedCallable<K, V, T> extends Callable<T> {
+
+   /**
+    * Invoked by execution environment after DistributedCallable
+    * has been migrated for execution to a specific Infinispan node.
+    *
+    * @param cache
+    *           cache whose keys are used as input data for this
+    *           DistributedCallable task
+    * @param inputKeys
+    *           keys used as input for this DistributedCallable task
+    */
+   public void setEnvironment(Cache<K, V> cache, Set<K> inputKeys);
+
+}
+
+
+
+----
+
+[[sid-68355086_InfinispanDistributedExecutionFramework-CallableandCDI]]
+
+
+=== Callable and CDI
+
+ Users that do not want or can not implement DistributedCallable yet need a reference to input cache used in DistributedExecutorService have an option of the input cache being injected by CDI mechanism. Upon arrival of user's Callable to an Infinispan executing node, Infinispan CDI mechanism will provide appropriate cache reference and inject it to executing Callable. All one has to do is to declare a Cache field in Callable and annotate it with org.infinispan.cdi.Input annotation along with mandatory @Inject annotation. __ 
+
+
+----
+
+ public class CallableWithInjectedCache implements Callable<Integer>, Serializable {
+     
+      @Inject
+      @Input
+      private Cache<String, String> cache;
+
+
+      @Override
+      public Integer call() throws Exception {
+        //use injected cache reference
+        return 1;
+      }
+}
+----
+
+[[sid-68355086_InfinispanDistributedExecutionFramework-DistributedExecutorService%2CDistributedTaskBuilderandDistributedTaskAPI]]
+
+
+=== DistributedExecutorService, DistributedTaskBuilder and DistributedTask API
+
+ link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/distexec/DistributedExecutorService.html$$[DistributedExecutorService] is a simple extension of a familiar link:$$http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ExecutorService.html$$[ExecutorService] from java.util.concurrent package. However, advantages of DistributedExecutorService are not to be overlooked. Existing Callable tasks, instead of being executed in JDK's ExecutorService, are also eligible for execution on Infinispan cluster. Infinispan execution environment would migrate a task to execution node(s), run the task and return the result(s) to the calling node. Of course, not all Callable tasks would benefit from parallel distributed execution. Excellent candidates are long running and computationally intensive tasks that can run concurrently and/or tasks using input data that can be processed concurrently. For more details about good candidates for parallel execution and parallel algorithms in general refer to link:$$https://computing.llnl.gov/tutorials/parallel_comp/$$[Introduction to Parallel Computing] . 
+
+The second advantage of the DistributedExecutorService is that it allows a quick and simple implementation of tasks that take input from Infinispan cache nodes, execute certain computation and return results to the caller. Users would specify which keys to use as input for specified DistributedCallable and submit that callable for execution on Infinispan cluster. Infinispan runtime would locate the appriate keys, migrate DistributedCallable to target execution node(s) and finally return a list of results for each executed Callable. Of course, users can omit specifying input keys in which case Infinispan would execute DistributedCallable on all keys for a specified cache.
+
+Lets see how we can use DistributedExecutorService If you already have Callable/Runnable tasks defined! Well, simply submit them to an instance of DefaultExecutorService for execution!
+
+
+----
+
+ExecutorService des = new DefaultExecutorService(cache);
+Future<Boolean> future = des.submit(new SomeCallable());
+Boolean r = future.get();
+----
+
+ In case you need to specify more task parameters like task timeout, custom failover policy or execution policy use link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/distexec/DistributedTaskBuilder.html$$[DistributedTaskBuilder] and link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/distexec/DistributedTask.html$$[DistributedTask] API. 
+
+
+----
+
+DistributedExecutorService des = new DefaultExecutorService(cache);
+DistributedTaskBuilder<Boolean> taskBuilder = des.createDistributedTaskBuilder(new SomeCallable());
+taskBuilder.timeout(10,TimeUnit.SECONDS);
+...
+...
+DistributedTask<Boolean> distributedTask = taskBuilder.build();
+Future<Boolean> future = des.submit(distributedTask);
+Boolean r = future.get();
+
+----
+
+[[sid-68355086_InfinispanDistributedExecutionFramework-Distributedtaskfailover]]
+
+
+=== Distributed task failover
+
+Distributed execution framework supports task failover. By default no failover policy is installed and task's Runnable/Callable/DistributedCallable will simply fail. Failover mechanism is invoked in the following cases:
+
+a) Failover due to a node failure where task is executing
+
+b) Failover due to a task failure (e.g. Callable task throws Exception).
+
+ Infinispan provides random node failover policy which will attempt execution of a part of distributed task on another random node, if such node is available.  However, users that have a need to implement a more sophisticated failover policy can implement link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/distexec/DistributedTaskFailoverPolicy.html$$[DistributedTaskFailoverPolicy] interface.  For example, users might want to use consistent hashing (CH) mechanism for failover of uncompleted tasks. CH based failover might for example migrate failed task T to cluster node(s) having a backup of input data that was executed on a failed node F. 
+
+
+----
+/**
+ * DistributedTaskFailoverPolicy allows pluggable fail over target selection for a failed remotely
+ * executed distributed task.
+ *
+ */
+public interface DistributedTaskFailoverPolicy {
+
+   /**
+    * As parts of distributively executed task can fail due to the task itself throwing an exception
+    * or it can be an Infinispan system caused failure (e.g node failed or left cluster during task
+    * execution etc).
+    *
+    * @param failoverContext
+    *           the FailoverContext of the failed execution
+    * @return result the Address of the Infinispan node selected for fail over execution
+    */
+   Address failover(FailoverContext context);
+
+   /**
+    * Maximum number of fail over attempts permitted by this DistributedTaskFailoverPolicy
+    *
+    * @return max number of fail over attempts
+    */
+   int maxFailoverAttempts();
+}
+
+----
+
+Therefore one could for example specify random failover execution policy simply by:
+
+
+----
+
+DistributedExecutorService des = new DefaultExecutorService(cache);
+DistributedTaskBuilder<Boolean> taskBuilder = des.createDistributedTaskBuilder(new SomeCallable());
+taskBuilder.failoverPolicy(DefaultExecutorService.RANDOM_NODE_FAILOVER);
+DistributedTask<Boolean> distributedTask = taskBuilder.build();
+Future<Boolean> future = des.submit(distributedTask);
+Boolean r = future.get();
+
+----
+
+[[sid-68355086_InfinispanDistributedExecutionFramework-Distributedtaskexecutionpolicy]]
+
+
+=== Distributed task execution policy
+
+ link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/distexec/DistributedTaskExecutionPolicy.html$$[DistributedTaskExecutionPolicy] is an enum that allows tasks to specify its custom task execution policy across Infinispan cluster. DistributedTaskExecutionPolicy effectively scopes execution of tasks to a subset of nodes. For example, someone might want to exclusively execute tasks on a local network site instead of a backup remote network centre as well. Others might, for example, use only a dedicated subset of a certain Infinispan rack nodes for specific task execution. DistributedTaskExecutionPolicy is set per instance of DistributedTask. 
+
+
+----
+DistributedExecutorService des = new DefaultExecutorService(cache);
+DistributedTaskBuilder<Boolean> taskBuilder = des.createDistributedTaskBuilder(new SomeCallable());
+taskBuilder.executionPolicy(DistributedTaskExecutionPolicy.SAME_RACK);
+DistributedTask<Boolean> distributedTask = taskBuilder.build();
+Future<Boolean> future = des.submit(distributedTask);
+Boolean r = future.get();
+----
+
+[[sid-68355086_InfinispanDistributedExecutionFramework-Examples]]
+
+
+=== Examples
+
+Pi approximation can greatly benefit from parallel distributed execution in DistributedExecutorService. Recall that area of the square is Sa = 4r2 and area of the circle is Ca=pi*r2. Substituting r2 from the second equation into the first one it turns out that pi = 4 * Ca/Sa. Now, image that we can shoot very large number of darts into a square; if we take ratio of darts that land inside a circle over a total number of darts shot we will approximate Ca/Sa value. Since we know that pi = 4 * Ca/Sa we can easily derive approximate value of pi. The more darts we shoot the better approximation we get. In the example below we shoot 10 million darts but instead of "shooting" them serially we parallelize work of dart shooting across entire Infinispan cluster.
+
+
+----
+  public class PiAppx {
+
+   public static void main (String [] arg){
+      List<Cache> caches = ...;
+      Cache cache = ...;
+
+      int numPoints = 10000000;
+      int numServers = caches.size();
+      int numberPerWorker = numPoints / numServers;
+
+      DistributedExecutorService des = new DefaultExecutorService(cache);
+      long start = System.currentTimeMillis();
+      CircleTest ct = new CircleTest(numberPerWorker);
+      List<Future<Integer>> results = des.submitEverywhere(ct);
+      int countCircle = 0;
+      for (Future<Integer> f : results) {
+         countCircle += f.get();
+      }
+      double appxPi = 4.0 * countCircle / numPoints;
+
+      System.out.println("Distributed PI appx is " + appxPi +
+      " completed in " + (System.currentTimeMillis() - start) + " ms");
+   }
+
+   private static class CircleTest implements Callable<Integer>, Serializable {
+
+      /** The serialVersionUID */
+      private static final long serialVersionUID = 3496135215525904755L;
+
+      private final int loopCount;
+
+      public CircleTest(int loopCount) {
+         this.loopCount = loopCount;
+      }
+
+      @Override
+      public Integer call() throws Exception {
+         int insideCircleCount = 0;
+         for (int i = 0; i < loopCount; i++) {
+            double x = Math.random();
+            double y = Math.random();
+            if (insideCircle(x, y))
+               insideCircleCount++;
+         }
+         return insideCircleCount;
+      }
+
+      private boolean insideCircle(double x, double y) {
+         return (Math.pow(x - 0.5, 2) + Math.pow(y - 0.5, 2))
+         <= Math.pow(0.5, 2);
+      }
+   }
+}
+----
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-42-Listeners_and_Notifications.adoc b/documentation/src/main/asciidoc/user_guide/chapter-42-Listeners_and_Notifications.adoc
new file mode 100644
index 0000000..b0b40b6
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-42-Listeners_and_Notifications.adoc
@@ -0,0 +1,84 @@
+[[sid-68355087]]
+
+==  Listeners and Notifications
+
+Infinispan offers a listener API, where clients can register for and get notified when events take place.  This annotation-driven API applies to 2 different levels: cache level events and cache manager level events.
+
+ Events trigger a notification which are dispatched to listeners.   Listeners are simple link:$$http://en.wikipedia.org/wiki/Plain_Old_Java_Object$$[POJO] s annotated with link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/notifications/Listener.html$$[@Listener] and registered using the methods defined in the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/notifications/Listenable.html$$[Listenable] interface. 
+
+
+----
+Both Cache and CacheManager implement Listenable, which means you can attach listeners to either a cache or a cache manager, to receive either cache-level or cache manager-level notifications.
+
+----
+
+ For example, the following class defines a listener to print out some information every time a new entry is added to the cache: 
+
+
+----
+@Listener
+public class PrintWhenAdded {
+
+  @CacheEntryCreated
+  public void print(CacheEntryCreatedEvent event) {
+    System.out.println("New entry " + event.getKey() + " created in the cache");
+  }
+
+}
+
+----
+
+ For more comprehensive examples, please see the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/notifications/Listener.html$$[Javadocs for @Listener] . 
+
+[[sid-68355087_ListenersandNotifications-Cachelevelnotifications]]
+
+
+=== Cache-level notifications
+
+Cache-level events occur on a per-cache basis, and is global and cluster-wide.  Examples of cache-level events are entries being added, removed, modified, etc.  These events trigger notifications to listeners registered to a specific cache.
+
+ Please see the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/notifications/cachelistener/annotation/package-summary.html$$[Javadocs on the org.infinispan.notifications.cachelistener.annotation package] for a comprehensive list of all cache-level notifications, and their respective method-level annotations. 
+
+
+----
+NOTE: In Infinispan 5.0, additional events were added.  Please refer to the <a href="http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/notifications/cachelistener/annotation/package-summary.html">Javadocs on the org.infinispan.notifications.cachelistener.annotation package</a> for Infinispan 5.0 for the list of cache-level notifications available in Infinispan 5.0.
+
+----
+
+[[sid-68355087_ListenersandNotifications-Cachemanagerlevelnotifications]]
+
+
+=== Cache manager-level notifications
+
+Cache manager-level events occur on a cache manager.  These too are global and  cluster-wide, but involve events that affect all caches created by a single cache manager.  Examples of cache manager-level events are nodes joining or leaving a cluster, or caches starting or stopping.
+
+ Please see the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/notifications/cachemanagerlistener/annotation/package-summary.html$$[Javadocs  on the org.infinispan.notifications.cachemanagerlistener.annotation package] for a comprehensive list of all cache manager-level notifications,  and their respective method-level annotations. 
+
+[[sid-68355087_ListenersandNotifications-Synchronicity]]
+
+
+=== Synchronicity
+
+ By default, all notifications are dispatched in the same thread that generates the event.  This means that you _must_ write your listener such that it does not block or do anything that takes too long, as it would prevent the thread from progressing.  Alternatively, you could annotate your listener as _asynchronous_ , in which case a separate thread pool will be used to dispatch the notification and prevent blocking the event originating thread.  To do this, simply annotate your listener such: 
+
+
+----
+@Listener (sync = false)
+public class MyAsyncListener { .... }
+
+----
+
+[[sid-68355087_ListenersandNotifications-Asynchronousthreadpool]]
+
+
+==== Asynchronous thread pool
+
+ To tune the thread pool used to dispatch such asynchronous notifications, use the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/config.html#ce_global_asyncListenerExecutor$$[&lt;asyncListenerExecutor /&gt;] XML element in your configuration file. 
+
+[[sid-68355087_ListenersandNotifications-ListenersonRemoteCacheManager]]
+
+
+=== Listeners on RemoteCacheManager
+
+ At the moment there is no support for registering listeners for the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCacheManager.html$$[RemoteCacheManager] . Whenever calling one of the add/remove/getListener methods on the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCacheManager.html$$[RemoteCacheManager] an UnsupportedOperationException will be thrown. There are plans to support remote listeners in future versions; in order to be notified when this feature will be added you can watch/vote for link:$$https://issues.jboss.org/browse/ISPN-374$$[ISPN-374] . 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-43-Eviction.adoc b/documentation/src/main/asciidoc/user_guide/chapter-43-Eviction.adoc
new file mode 100644
index 0000000..70d255d
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-43-Eviction.adoc
@@ -0,0 +1,116 @@
+[[sid-68355088]]
+
+==  Eviction
+
+Infinispan supports eviction of entries, such that you do not run out of memory.  Eviction is typically used in conjunction with a cache store, so that entries are not permanently lost when evicted, since eviction only removes entries from memory and not from cache stores or the rest of the cluster.
+
+
+[TIP]
+==== 
+Passivation is also a popular option when using eviction, so that only a single copy of an entry is maintained - either in memory or in a cache store, but not both. The main benefit of using passivation over a regular cache store is that updates to entries which exist in memory are cheaper since the update doesn't need to be made to the cache store as well.
+
+
+==== 
+
+
+ Note that eviction occurs on a _local_ basis, and is not cluster-wide.  Each node runs an eviction thread to analyse the contents of its in-memory container and decide what to evict. Eviction does not take into account the amount of free memory in the JVM as threshold to  starts evicting entries. You have to set maxEntries attribute of the eviction element to be greater than zero in order for eviction to be turned on. If maxEntries is too large you can run out of memory. maxEntries attribute will probably take some tuning in each use case. 
+
+[[sid-68355088_Eviction-Evictionin5.2]]
+
+
+=== Eviction in 5.2
+
+ Eviction is configured by adding the link:$$http://docs.jboss.org/infinispan/5.2/configdocs/urn_infinispan_config_5.2/complexType/configuration.eviction.html$$[&lt;eviction /&gt;] element to your &lt;default /&gt; or &lt;namedCache /&gt; configuration sections or using link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/configuration/cache/EvictionConfigurationBuilder.html$$[EvictionConfigurationBuilder] API programmatic approach. LIRS is default eviction algorithm in Infinispan 5.2 release. 
+
+All cache entry are evicted by piggybacking   on user threads that are hitting the cache. Periodic pruning   of expired cache entries from cache is done on a dedicated thread which is turned on   by enabling reaper in expiration configuration element/API.
+
+[[sid-68355088_Eviction-NONE]]
+
+
+==== NONE
+
+This eviction strategy effectively disables the eviction thread.
+
+[[sid-68355088_Eviction-UNORDERED]]
+
+
+==== UNORDERED
+
+UNORDERED eviction strategy is a legacy eviction strategy that has been deprecated. If UNORDERED strategy is specified LRU eviction algorithm will be used.
+
+[[sid-68355088_Eviction-LRU]]
+
+
+==== LRU
+
+If LRU eviction is used cache entries are selected for eviction using a well known least-recently-used pattern.
+
+[[sid-68355088_Eviction-LIRS]]
+
+
+==== LIRS
+
+LRU eviction algorithm, although simple and easy to understand, under performs in cases of weak access locality (one time access entries are not timely replaced, entries to be accessed soonest are unfortunately replaced, and so on). Recently, a new eviction algorithm - LIRS has gathered a lot of attention because it addresses weak access locality shortcomings of LRU yet it retains LRU's simplicity. Eviction in LIRS algorithm relies on history information of cache entries accesses using so called Inter-Reference Recency (a.k.a IRR) and the Recency. The IRR of a cache entry A refers to number of other distinct entries accessed between the last two consecutive accesses to cache entry A, while recency refers to the number of other entries accessed from last reference to A up to current time point. If we relied only on cache recency we would essentially have LRU functionality. However, in addition to recency LIRS tracks elements that are in low IRR and high IRR, aptly named LIR and HIR cache entry blocks respectively. LIRS eviction algorithm essentially keeps entries with a low IRR in the cache as much as possible while evicting high IRR entries if eviction is required. If recency of a LIR cache entry increases to a certain point and entry  in HIR gets accessed at a smaller recency than that of the LIR entry, the LIR/HIR statuses of the two blocks are switched. Entries in HIR may be evicted regardless of its recency, even if element was recently accessed.
+
+[[sid-68355088_Eviction-Configurationanddefaultsin5.2.x]]
+
+
+=== Configuration and defaults in 5.2.x
+
+By default when no &lt;eviction&gt; element is specified, no eviction takes place.
+
+In case there is an eviction element, this table describes behaviour of eviction based on information provided in the xml configuration ("-" in Supplied maxEntries or Supplied strategy column means that the attribute wasn't supplied)
+
+[options="header"]
+|===============
+|Supplied maxEntries|Supplied strategy|Example|Eviction behaviour
+|-|-| &lt;eviction /&gt; |no eviction
+|&gt; 0|-| &lt;eviction maxEntries="100" /&gt; |the strategy defaults to LIRS and eviction takes place
+|&gt; 0|NONE| &lt;eviction maxEntries="100" strategy="NONE" /&gt; | _the strategy defaults to LIRS and eviction takes place_ 
+|&gt; 0| != NONE | &lt;eviction maxEntries="100" strategy="LRU" /&gt; |eviction takes place with defined strategy
+|0|-| &lt;eviction maxEntries="0" /&gt; | no eviction 
+|0| NONE | &lt;eviction maxEntries="0" strategy="NONE" /&gt; | no eviction 
+|0| != NONE | &lt;eviction maxEntries="0" strategy="LRU" /&gt; | ConfigurationException 
+|&lt; 0|-| &lt;eviction maxEntries="-1" /&gt; | no eviction 
+|&lt; 0| NONE | &lt;eviction maxEntries="-1" strategy="NONE" /&gt; | no eviction 
+|&lt; 0| != NONE | &lt;eviction maxEntries="-1" strategy="LRU" /&gt; |ConfigurationException
+
+|===============
+
+
+[[sid-68355088_Eviction-AdvancedEvictionInternals]]
+
+
+=== Advanced Eviction Internals
+
+ Implementing eviction in a scalable, low lock contention  approach while  at the same time doing meaningful selection of entries for eviction is  not an easy feat. Data container needs to be locked until appropriate  eviction entries are selected. Having  such a lock protected data  container in turn causes high lock contention  offsetting any eviction  precision gained by sophisticated eviction  algorithms. In order to get  superior throughput while retaining high  eviction precision both low  lock contention data container and  high precision eviction algorithm  implementation are needed. Infinispan evicts entries from cache on a  segment level (segments  similar to ConcurrentHashMap), once segment is  full entries are evicted  according to eviction algorithm. However,  there are two drawbacks with this approach. Entries might get evicted  from cache even though maxEntries has not been reached yet and  maxEntries is a theoretical  limit for cache size but in practical   terms it will be slightly less  than maxEntries. For more details refer to link:$$http://infinispan.blogspot.com/2010/03/infinispan-eviction-batching-updates.html$$[Infinispan eviction design] . 
+
+[[sid-68355088_Eviction-Expiration]]
+
+
+=== Expiration
+
+Similar to, but unlike eviction, is expiration. Expiration allows you to attach lifespan and/or maximum idle times to entries. Entries that exceed these times are treated as invalid and are removed. When removed expired entries are not passivated like evicted entries (if passivation is turned on).
+
+
+[TIP]
+==== 
+Unlike eviction, expired entries are removed globally - from memory, cache stores, and cluster-wide.
+
+
+==== 
+
+
+ By default entries created are immortal and do not have a lifespan or maximum idle time.  Using the cache API, mortal entries can be created with lfiespans and/or maximum idle times.  Further, default lifespans and/or maximum idle times can be configured by adding the link:$$http://docs.jboss.org/infinispan/5.1/configdocs/urn_infinispan_config_5.1/complexType/configuration.expiration.html$$[&lt;expiration /&gt;] element to your &lt;default /&gt; or &lt;namedCache /&gt; configuration sections. 
+
+[[sid-68355088_Eviction-DifferencebetweenEvictionandExpiration]]
+
+
+=== Difference between Eviction and Expiration
+
+Both Eviction and Expiration are means of cleaning the cache of unused entries and thus guarding the heap against OutOfMemory exceptions, so now a brief explanation of the difference.
+
+ With _eviction_ you set _maximal number of entries_ you want to keep in the cache and if this limit is exceeded, some candidates are found to be removed according to a choosen _eviction strategy_ (LRU, LIRS, etc...). Eviction can be setup to work with passivation (evicting to a cache store). 
+
+ With _expiration_ you set _time criteria_ for entries, _how long you want to keep them_ in cache. Either you set maximum _lifespan_ of the entry - time it is allowed to stay in the cache or _maximum idle time_ , time it's allowed to be untouched (no operation performed with given key). 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-44-ServerHinting.adoc b/documentation/src/main/asciidoc/user_guide/chapter-44-ServerHinting.adoc
new file mode 100644
index 0000000..64b1a66
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-44-ServerHinting.adoc
@@ -0,0 +1,72 @@
+[[sid-68355089]]
+
+==  ServerHinting
+
+[[sid-68355089_ServerHinting-Whatisserverhinting%3F]]
+
+
+=== What is server hinting?
+
+The motivations behind this feature is to ensure when using distribution, backups are not picked to reside on the same physical server, rack or data centre. For obvious reasons it doesn't work with total replication.
+
+[[sid-68355089_ServerHinting-Version]]
+
+
+=== Version
+
+Server hinting was added in Infinspan 4.2.0 "Ursus". You'll need this release or later in order to use it.
+
+[[sid-68355089_ServerHinting-Configuration]]
+
+
+=== Configuration
+
+ The hints are configured at transport level: 
+
+
+----
+ <transport     clusterName = "MyCluster"
+     machineId = "LinuxServer01"
+     rackId = "Rack01"
+     siteId = "US-WestCoast" />
+
+----
+
+Following topology hints can be specified:
+
+
+* machineId - this is probably the most useful, to disambiguate between multiple JVM instances on the same node, or even multiple virtual hosts on the same physical host.
+
+
+* rackId - in larger clusters with nodes occupying more than a single rack, this setting would help prevent backups being stored on the same rack.
+
+
+* siteId - to differentiate between nodes in different data centres replicating to each other.    All of the above are optional, and if not provided, the distribution algorithms provide no guarantees that backups will not be stored in instances on the same host/rack/site.
+
+[[sid-68355089_ServerHinting-Algorithm]]
+
+
+=== Algorithm
+
+This is an advanced topic, useful e.g. if you need to change distribution behaviour.
+
+The consistent hash beyond this implementation is wheel based. Conceptually this works as follows: each node is placed on a wheel ordered by the hash code of its address. When an entry is added its owners are chosen using this algorithm:
+
+
+* key's hash code is calculated
+
+
+* the first node on the wheel with a value grater than key's hash code is the first owner
+
+
+* for subsequent nodes, walk clockwise and pick nodes that have a different site id
+
+
+* if not enough nodes found repeat walk again and pick nodes that have different site id and rack id
+
+
+* if not enough nodes found repeat walk again and pick nodes that have different site id, rack id and machine id
+
+
+* Ultimately cycle back to the first node selected, don't discard any nodes, regardless of machine id/rack
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-45-Java_Hot_Rod_client.adoc b/documentation/src/main/asciidoc/user_guide/chapter-45-Java_Hot_Rod_client.adoc
new file mode 100644
index 0000000..443f437
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-45-Java_Hot_Rod_client.adoc
@@ -0,0 +1,240 @@
+[[sid-68355091]]
+
+==  Java Hot Rod client
+
+[[sid-68355091_JavaHotRodclient-Introduction]]
+
+
+=== Introduction
+
+Hot Rod is a binary, language neutral protocol. This article explains how a Java client can interact with a server via the Hot Rod protocol. A reference implementation of the protocol written in Java can be found in all Infinispan distributions since 4.1, and this article focuses on the capabilities of this java client.
+
+[[sid-68355091_JavaHotRodclient-BasicAPI]]
+
+
+=== Basic API
+
+ Bellow is a sample code snippet on how the client API can be used to store or retrieve information from a Hot Rod server using the Java Hot Rod client. It assumes that a Hot Rod server has been started bound to the default location (localhost:11222) 
+
+
+----
+//API entry point, by default it connects to localhost:11222
+CacheContainer cacheContainer = new RemoteCacheManager();
+
+//obtain a handle to the remote default cache
+Cache<String, String> cache = cacheContainer.getCache();
+
+//now add something to the cache and make sure it is there
+cache.put("car", "ferrari");
+assert cache.get("car").equals("ferrari");
+
+//remove the data
+cache.remove("car");
+assert !cache.containsKey("car") : "Value must have been removed!";
+
+----
+
+ The client API maps the local API: link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCacheManager.html$$[RemoteCacheManager] corresponds to link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/manager/DefaultCacheManager.html$$[DefaultCacheManager] (both implement link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/manager/CacheContainer.html$$[CacheContainer] ). This common API facilitates an easy migration from local calls to remote calls through Hot Rod: all one needs to do is switch between link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/manager/DefaultCacheManager.html$$[DefaultCacheManager] and link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCacheManager.html$$[RemoteCacheManager] - which is further simplified by the common link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/manager/CacheContainer.html$$[CacheContainer] interface that both inherit. 
+
+Starting from Infinispan 5.2, all keys can be retrieved from the remote cache (whether it's local, replicated, or distributed) by using keySet() method. If the remote cache is a distributed cache, the server will start a map/reduce job to retrieve all keys from clustered nodes, and return all keys to the client.  Please use this method with care if there are large number of keys.
+
+
+----
+Set keys = remoteCache.keySet();
+
+----
+
+[[sid-68355091_JavaHotRodclient-VersionedAPI]]
+
+
+=== Versioned API
+
+ A RemoteCacheManager provides instances of link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCache.html$$[RemoteCache] interface that represents a handle to the named or default cache on the remote cluster. API wise, it extends the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html$$[Cache] interface to which it also adds some new methods, including the so called versioned API. Please find below some examples of this API link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737101$$[but to understand the motivation behind it, make sure you read this article] . 
+
+ The code snippet bellow depicts the usage of these versioned methods: 
+
+
+----
+// To use the versioned API, remote classes are specifically needed
+RemoteCacheManager remoteCacheManager = new RemoteCacheManager();
+RemoteCache<String, String> cache = remoteCacheManager.getCache();
+
+remoteCache.put("car", "ferrari");
+RemoteCache.VersionedValue valueBinary = remoteCache.getVersioned("car");
+
+// removal only takes place only if the version has not been changed
+// in between. (a new version is associated with 'car' key on each change)
+assert remoteCache.remove("car", valueBinary.getVersion());
+assert !cache.containsKey("car");
+
+----
+
+In a similar way, for replace:
+
+
+----
+remoteCache.put("car", "ferrari");
+RemoteCache.VersionedValue valueBinary = remoteCache.getVersioned("car");
+assert remoteCache.replace("car", "lamborghini", valueBinary.getVersion());
+
+----
+
+ For more details on versioned operations refer to link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/client/hotrod/RemoteCache.html$$[RemoteCache] 's javadoc. 
+
+[[sid-68355091_JavaHotRodclient-AsyncAPI]]
+
+
+=== Async API
+
+ This cool feature is "borrowed" from the Infinispan core and it is largely discussed link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737045$$[here] . 
+
+[[sid-68355091_JavaHotRodclient-Unsupportedmethods]]
+
+
+=== Unsupported methods
+
+ Some of the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html$$[Cache] methods are not being supported by the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCache.html$$[RemoteCache] . Calling one of these methods results in an link:$$http://download.oracle.com/javase/6/docs/api/java/lang/UnsupportedOperationException.html$$[UnsupportedOperationException] being thrown. Most of these methods do not make sense on the remote cache (e.g. listener management operations), or correspond to methods that are not supported by local cache as well (e.g. containsValue). Another set of unsupported operations are some of the atomic operations inherited from link:$$http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ConcurrentMap.html$$[ConcurrentMap] : 
+
+
+----
+boolean remove(Object key, Object value);
+boolean replace(Object key, Object value);
+boolean replace(Object key, Object oldValue, Object value);
+
+----
+
+ link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCache.html$$[RemoteCache] offers alternative versioned methods for these atomic operations, that are also network friendly, by not sending the whole value object over the network, but a version identifier. See the section on versioned API. 
+
+ Each one of these unsupported operation is documented in the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCache.html$$[RemoteCache] javadoc. 
+
+[[sid-68355091_JavaHotRodclient-Returnvalues]]
+
+
+=== Return values
+
+ There is a set of methods that alter an cached entry and return the previous existing value, e.g.: 
+
+
+----
+V remove(Object key);
+V put(K key, V value);
+----
+
+ By default on RemoteCache, these operations return null even if such a previous value exists. This approach reduces the amount of data sent over the network. However, if these return values are needed they can be enforced on an per invocation basis using flags: 
+
+
+----
+cache.put("aKey", "initialValue");
+assert null == cache.put("aKey", "aValue");
+assert "aValue".equals(cache.withFlags(Flag.FORCE_RETURN_VALUE).put("aKey",
+   "newValue"));
+
+----
+
+This default behaviour can can be changed through force-return-value=true configuration parameter (see configuration section bellow).
+
+[[sid-68355091_JavaHotRodclient-Intelligence]]
+
+
+=== Intelligence
+
+HotRod defines three level of intelligence for the clients:
+
+
+* basic client, interested in neither cluster nor hash information
+
+
+* topology-aware client, interested in cluster information
+
+
+* hash-distribution-aware client, that is interested in both cluster and hash information
+
+The java client supports all 3 levels of intelligence. It is transparently notified whenever a new server is added/removed from the HotRod cluster. At startup it only needs to know the address of one HotRod server (ip:host). On connection to the server the cluster topology is piggybacked to the client, and all further requests are being dispatched to all available servers. Any further topology change is also piggybacked.
+
+Hash-distribution-aware client is discussed in the next section.
+
+[[sid-68355091_JavaHotRodclient-Hashdistributionawareclient]]
+
+
+=== distribution-aware client
+
+Another aspect of the 3rd level of intelligence is the fact that it is hash-distribution-aware. This means that, for each operation, the client chooses the most appropriate remote server to go to: the data owner. As an example, for a put(k,v) operation, the client calculates k's hash value and knows exactly on which server the data resides on. Then it picks up a tcp connection to that particular server and dispatches the operation to it. This means less burden on the server side which would otherwise need to lookup the value based on the key's hash. It also results in a quicker response from the server, as an additional network roundtrip is skipped. This hash-distribution-aware aspect is only relevant to the distributed HotRod clusters and makes no difference for replicated server deployments.
+
+[[sid-68355091_JavaHotRodclient-RequestBalancing]]
+
+
+=== Request Balancing
+
+Request balancing is only relevant when the server side is configured with replicated infinispan cluster (on distributed clusters the hash-distribution-aware client logic is used, as discussed in the previos paragraph). Because the client is topology-aware, it knows the list of available servers at all the time. Request balancing has to do with how the client dispatches requests to the available servers.
+
+ The default strategy is round-robin: requests are being dispatched to all existing servers in a circular manner. E.g. given a cluster of servers {s1, s2, s3} here is how request will be dispatched: 
+
+
+----
+CacheContainer cacheContainer = new RemoteCacheManager();
+Cache<String, String> cache = cacheContainer.getCache();
+
+cache.put("key1", "aValue"); //this goes to s1
+cache.put("key2", "aValue"); //this goes to s2
+String value = cache.get("key1"); //this goes to s3
+
+cache.remove("key2"); //this is dispatched to s1 again, and so on...
+
+----
+
+ Custom types of balancing policies can defined by implementing the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/impl/transport/tcp/RequestBalancingStrategy.html$$[RequestBalancingStrategy] and by specifying it through the infinispan.client.hotrod.request-balancing-strategy configuration property. Please refer to configuration section for more details on this. 
+
+[[sid-68355091_JavaHotRodclient-Persistentconnections]]
+
+
+=== Persistent connections
+
+In order to avoid creating a TCP connection on each request (which is a costly operation), the client keeps a pool of persistent connections to all the available servers and it reuses these connections whenever it is possible. The validity of the connections is checked using an async thread that iterates over the connections in the pool and sends a HotRod ping command to the server. By using this connection validation process the client is being proactive: there's a hight chance for broken connections to be found while being idle in the pool and no on actual request from the application.
+
+ The number of connections per server, total number of connections, how long should a connection be kept idle in the pool before being closed - all these (and more) can be configured. Please refer to the javadoc of link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCacheManager.html$$[RemoteCacheManager] for a list of all possible configuration elements. 
+
+[[sid-68355091_JavaHotRodclient-Marshallingdata]]
+
+
+=== Marshalling data
+
+The Hot Rod client allows one to plug in a custom marshaller for transforming user objects into byte arrays and the other way around. This transformation is needed because of Hot Rod's binary nature - it doesn't know about objects.
+
+ The marshaller can be plugged through the "marshaller" configuration element (see Configuration section): the value should be the fully qualified name of a class implementing the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/marshall/Marshaller.html$$[Marshaller] interface. This is a optional parameter, if not specified it defaults to the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/marshall/jboss/GenericJBossMarshaller.html$$[GenericJBossMarshaller] - a highly optimized implementation based on the link:$$http://www.jboss.org/jbossmarshalling$$[JBoss Marshalling] library. 
+
+ Since version 5.0, there's a new marshaller available to Java Hot Rod clients based on Apache Avro which generates portable payloads. You can find more information about it <<sid-68355061,here>> 
+
+[[sid-68355091_JavaHotRodclient-Statistics]]
+
+
+=== Statistics
+
+ Various server usage statistics can be obtained through the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCache.html$$[RemoteCache] .stats() method. This returns an link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/ServerStatistics.html$$[ServerStatistics] object - please refer to javadoc for details on the available statistics. 
+
+[[sid-68355091_JavaHotRodclient-Configuration]]
+
+
+=== Configuration
+
+ All the configurations are passed to the RemoteCacheManager's constructor as key-value pairs, through an instance of link:$$http://download.oracle.com/javase/6/docs/api/java/util/Properties.html$$[java.util.Properties] or reference to a .properties file. Please refer to the javadoc of RemoteCacheManager for a exhaustive list of the possible configuration elements. 
+
+[[sid-68355091_JavaHotRodclient-MultiGetOperations]]
+
+
+=== Multi-Get Operations
+
+ The Java Hot Rod client does not provide multi-get functionality out of the box but clients can build it themselves with the given APIs. More information on this topic can be found in the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=9470083$$[Hot Rod protocol article] . 
+
+[[sid-68355091_JavaHotRodclient-Moreinfo]]
+
+
+=== More info
+
+It is highly recommended to read the following Javadocs (this is pretty much all the public API of the client):
+
+
+*  link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/client/hotrod/RemoteCacheManager.html$$[RemoteCacheManager] 
+
+
+*  link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/client/hotrod/RemoteCache.html$$[RemoteCache] 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-46-Configuring_cache.adoc b/documentation/src/main/asciidoc/user_guide/chapter-46-Configuring_cache.adoc
new file mode 100644
index 0000000..c85e11b
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-46-Configuring_cache.adoc
@@ -0,0 +1,114 @@
+[[sid-68355092]]
+
+==  Configuring cache
+
+ Infinispan offers both link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737097$$[Configuring Cache declaratively] and link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737033$$[Configuring cache programmatically] configuration approaches. 
+
+ Declarative configuration comes in a form of XML document that adheres to a provided Infinispan configuration XML link:$$http://www.infinispan.org/schemas/infinispan-config-4.0.xsd$$[schema] .  Every aspect of Infinispan that can be configured declaratively can also be configured programmatically. In fact, declarative configuration, behind the scenes, invokes programmatic configuration API as the XML configuration file is being processed. One can even use combination of these approaches. For example, you can read static XML configuration files and at runtime programmatically tune that same configuration. Or you can use a certain static configuration defined in XML as a starting point or template for defining additional configurations in runtime. 
+
+There are two main configuration abstractions in Infinispan: global and default configuration.
+
+ Global cache configuration defines global settings shared among all cache instances created by a single link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/manager/CacheManager.html$$[CacheManager] . Shared resources like thread pools, serialization/marshalling settings, transport and network settings, JMX domains are all part of global configuration. 
+
+ Default cache configuration is more specific to actual caching domain itself. It specifies eviction, locking, transaction, clustering, cache store settings etc. The default cache can be retrieved via the CacheManager.getCache() API. However, the real power of default cache mechanism comes to light when used in conjuction with _named caches_ . Named caches have the same XML schema as the default cache. Whenever they are specified, named caches inherit settings from the default cache while additional behavior can be specified or overridden. Named caches are retrieved via CacheManager.getCache(String name) API. Therefore, note that the _name_ attribute of named cache is both mandatory and unique for every named cache specified. 
+
+ Do not forget to refer to Infinispan configuration link:$$http://docs.jboss.org/infinispan/5.1/configdocs$$[reference] for more details. 
+
+For more details, refer to the following documents:
+
+
+*  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737097$$[Configuring Cache declaratively] 
+
+
+*  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737033$$[Configuring cache programmatically] 
+
+
+*  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=61702267$$[Dynamically Start and Stop Clustered Cache] 
+
+
+*  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737098$$[Configuration Migration Tools] 
+
+[[sid-68355093]]
+
+
+=== Dynamically Start and Stop Clustered Cache
+
+[[sid-68355093_DynamicallyStartandStopClusteredCache-LibraryMode]]
+
+
+==== Library Mode
+
+[[sid-68355093_DynamicallyStartandStopClusteredCache-NonClustered]]
+
+
+===== Clustered
+
+ Start start/stop cache in non-clustered mode is simple.  You can use _EmbeddedCacheManager.defineConfiguration(cacheName, configuration)_ to define a cache, and then call _EmbeddedCacheManager.getCache(cacheName)_ . 
+
+ If you don't define a specific configuration for the cache and directly call _EmbeddedCacheManager.getCache(...)_ , then a new cache would be created with default configurations. 
+
+ To stop a cache, call _EmbeddedCacheManager.remove(cacheName)_ ; 
+
+[[sid-68355093_DynamicallyStartandStopClusteredCache-Clustered]]
+
+
+===== Clustered
+
+To start a clustered cache, you'll need to do the above on every clustered node, while making sure the cache mode is clustered, of course.
+
+You can start the cache by calling _EmbeddedCacheManager.getCache(...).  _To do this on every single node though, you could write your own service to do that, or with JMX, or use DistributedExecutorService.
+
+For example, write a StartCacheCallable class:
+
+
+----
+
+ public class StartCacheCallable<K, V> implements DistributedCallable<K, V, Void>, Serializable {
+ private static final long serialVersionUID = 8331682008912636780L;
+ private final String cacheName;
+ private transient Cache<K, V> cache;
+
+
+ public StartCacheCallable(String cacheName) {
+    this.cacheName = cacheName;
+ }
+
+ @Override
+ public Void call() throws Exception {
+    cache.getCacheManager().getCache(cacheName); // start the cache
+    return null;
+ }
+
+ @Override
+ public void setEnvironment(Cache<K, V> cache, Set<K> inputKeys) {
+    this.cache = cache;
+ }
+
+}
+
+----
+
+Then submit the task to all nodes:
+
+
+----
+
+DistributedExecutorService des = new DefaultExecutorService(existingCacheSuchAsDefaultCache);
+List<Future<Void>> list = des.submitEverywhere(new StartCacheCallable<K, V>(cacheName));
+for (Future<Void> future : list) {
+   try {
+      future.get(); // wait for task to complete
+   } catch (InterruptedException e) {
+   } catch (ExecutionException e) {
+   }
+}
+
+----
+
+[[sid-68355093_DynamicallyStartandStopClusteredCache-ServerMode]]
+
+
+==== Server Mode
+
+Hot Rod client does not support dynamically start/stop of cache.
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-47-Write_Through_And_Write_Behind_Caching.adoc b/documentation/src/main/asciidoc/user_guide/chapter-47-Write_Through_And_Write_Behind_Caching.adoc
new file mode 100644
index 0000000..f90f41f
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-47-Write_Through_And_Write_Behind_Caching.adoc
@@ -0,0 +1,106 @@
+[[sid-68355094]]
+
+==  Write-Through And Write-Behind Caching
+
+[[sid-68355094_Write-ThroughAndWrite-BehindCaching-Introduction]]
+
+
+=== Introduction
+
+Infinispan can optionally be configured with one or several cache stores allowing it to store data in a persistent location such as shared JDBC database, a local filesystem...etc. Infinispan can handle updates to the cache store in two different ways:
+
+
+* Write-Through (Synchronous)
+
+
+* Write-Behind (Asynchronous)
+
+[[sid-68355094_Write-ThroughAndWrite-BehindCaching-WriteThrough%28Synchronous%29]]
+
+
+=== Write-Through (Synchronous)
+
+In this mode, which is supported in version 4.0, when clients update a cache entry, i.e. via a Cache.put() invocation, the call will not return until Infinispan has gone to the underlying cache store and has updated it. Normally, this means that updates to the cache store are done within the boundaries of the client thread.
+
+The main advantage of this mode is that the cache store is updated at the same time as the cache, hence the cache store is consistent with the cache contents. On the other hand, using this mode reduces performance because the latency of having to access and update the cache store directly impacts the duration of the cache operation.
+
+Configuring a write-through or synchronous cache store does not require any particular configuration option. By default, unless marked explicitly as write-behind or asynchronous, all cache stores are write-through or synchronous. Please find below a sample configuration file of a write-through unshared local file cache store:
+
+
+----
+<?xml version="1.0" encoding="UTF-8"?>
+<infinispan xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
+            xmlns="urn:infinispan:config:5.0">
+  <global />
+  <default />
+  <namedCache name="persistentCache">
+    <loaders shared="false">
+      <loader 
+          class="org.infinispan.loaders.file.FileCacheStore" 
+          fetchPersistentState="true" ignoreModifications="false"
+          purgeOnStartup="false">
+        <properties>
+          <property name="location" value="${java.io.tmpdir}" />
+        </properties>
+      </loader>
+    </loaders>
+  </namedCache>
+</infinispan>
+
+----
+
+[[sid-68355094_Write-ThroughAndWrite-BehindCaching-WriteBehind%28Asynchronous%29]]
+
+
+=== Write-Behind (Asynchronous)
+
+In this mode, updates to the cache are asynchronously written to the cache store. Normally, this means that updates to the cache store are done by a separate thread to the client thread interacting with the cache.
+
+One of the major advantages of this mode is that the performance of a cache operation does not get affected by the update of the underlying store. On the other hand, since the update happens asynchronously, there's a time window during the which the cache store can contain stale data compared to the cache. Even within write-behind, there are different strategies that can be used to store data:
+
+[[sid-68355094_Write-ThroughAndWrite-BehindCaching-UnscheduledWriteBehindStrategy]]
+
+
+=== Unscheduled Write-Behind Strategy
+
+In this mode, which is supported in version 4.0, Infinispan tries to store changes as quickly as possible by taking the pending changes and applying them in paralel. Normally, this means that there are several threads waiting for modifications to occur and once they're available, they apply them to underlying cache store.
+
+This strategy is suited for cache stores with low latency and cheap operation cost. One such example would a local unshared file based cache store, where the cache store is local to the cache itself. With this strategy, the window of inconsistency between the contents of the cache and the cache store are reduced to the lowest possible time. Please find below a sample configuration file of this strategy:
+
+
+----
+<?xml version="1.0" encoding="UTF-8"?>
+<infinispan xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
+            xmlns="urn:infinispan:config:5.0">
+  <global />
+  <default />
+  <namedCache name="persistentCache">
+    <loaders shared="false">
+      <loader 
+          class="org.infinispan.loaders.file.FileCacheStore" 
+          fetchPersistentState="true" ignoreModifications="false"
+          purgeOnStartup="false">
+        <properties>
+          <property name="location" value="${java.io.tmpdir}" />
+        </properties>
+        <!-- write-behind configuration starts here -->
+        <async enabled="true" threadPoolSize="10" />
+        <!-- write-behind configuration ends here -->
+      </loader>
+    </loaders>
+  </namedCache>
+</infinispan>
+
+----
+
+[[sid-68355094_Write-ThroughAndWrite-BehindCaching-ScheduledWriteBehindStrategy]]
+
+
+=== Scheduled Write-Behind Strategy
+
+ First of all, please note that this strategy is not included in version 4.0 but it will be implemented at a later stage. link:$$https://jira.jboss.org/jira/browse/ISPN-328$$[ISPN-328] has been created to track this feature request. If you want it implemented, please link:$$https://jira.jboss.org/jira/secure/ViewIssue.jspa?id=12402022&amp;vote=true$$[vote for it] and don't forget to link:$$https://jira.jboss.org/jira/secure/ViewIssue.jspa?id=12402022&amp;watch=true$$[watch it] to be notified of any changes. The following explanation refers to how we envision it to work. 
+
+In this mode, Infinispan would periodically store changes to the underlying cache store. The periodicity could be defined in seconds, minutes, days...etc.
+
+Since this strategy is oriented at cache stores with high latency or expensive operation cost, it makes sense to coalesce changes, so that if there are multiple operations queued on the same key, only the latest value is applied to cache store. With this strategy, the window of inconsistency between the contents of the cache and the cache store depends on the delay or periodicity configured. The higher the periodicity, the higher the chance of inconsistency.
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-48-Using_Hot_Rod_Server.adoc b/documentation/src/main/asciidoc/user_guide/chapter-48-Using_Hot_Rod_Server.adoc
new file mode 100644
index 0000000..eb23832
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-48-Using_Hot_Rod_Server.adoc
@@ -0,0 +1,43 @@
+[[sid-68355095]]
+
+==  Using Hot Rod Server
+
+[[sid-68355095_UsingHotRodServer-Introduction]]
+
+
+=== Introduction
+
+ Starting with version 4.1, Infinispan distribution contains a server module that implements link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=9470083$$[Infinispan's custom binary protocol called Hot Rod] . The protocol was designed to enable faster client/server interactions compared to other existing text based protocols and to allow clients to make more intelligent decisions with regards to load balancing, failover and even data location operations. 
+
+[[sid-68355095_UsingHotRodServer-StartinganInfinispanHotRodserver]]
+
+
+=== Starting an Infinispan Hot Rod server
+
+The simplest way to start up  Hot Rod  server is to simply unzip the all distribution and either run the startServer.bat or startServer.sh script passing 'hotrod' as the protocol to run. For example:
+
+
+----
+[g@eq]~/infinispan-4.1.0-SNAPSHOT% ./bin/startServer.sh -r hotrod
+----
+
+ When the script is called without any further parameters, the started Hot Rod server bounds to port 11222 (Infinispan 4.2.0.BETA1 or earlier listened on port 11311 by default) on localhost (127.0.0.1). If no further parameters is given at startup, this means that any cache instance queried will be based on the default cache instance which will be a local (unclustered) Infinispan cache instance configured with default values. Please visit the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/config.html$$[Configuration Reference Guide] for more information on these values. If you want to use non-default values, please check the next section on command line options. 
+
+[[sid-68355095_UsingHotRodServer-CommandLineOptions]]
+
+
+==== Command Line Options
+
+ You can optionally pass a set of parameters to the Hot Rod server that allow you to configure different parts of the server. You can find detailed information in the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737161$$[server command line options article] . 
+
+So, following the discussion earlier on configuring a Hot Rod server with a custom Infinispan configuration, you'd use -c parameter to pass the corresponding file. Hot Rod clients could then send requests to specific cache instances whose name match one of the names in the custom configuration file.
+
+[[sid-68355095_UsingHotRodServer-PredefiningHotRodCaches]]
+
+
+==== Predefining Hot Rod Caches
+
+In order to provide a more consistent experience when interacting with Hot Rod servers and avoid issues related to lazily started cache instances, on startup, Hot Rod server starts all defined caches in the Infinispan configuration file including the default cache. If no configuration file was provided, only the default cache will be started. Any request to an undefined cache will be rejected by the server.
+
+ So, as user, this means that any caches you interact with must be defined in the Infinispan configuration file by providing a namedCache XML element entry for each of them. Besides, as explained the 'Cache Name' section of the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=9470083$$[Hot Rod protocol] , you can also interact with the default cache by passing an empty cache name. 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-49-Cassandra_CacheStore.adoc b/documentation/src/main/asciidoc/user_guide/chapter-49-Cassandra_CacheStore.adoc
new file mode 100644
index 0000000..fdbcd9f
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-49-Cassandra_CacheStore.adoc
@@ -0,0 +1,96 @@
+[[sid-68355096]]
+
+==  Cassandra CacheStore
+
+ Infinispan's CassandraCacheStore leverages link:$$http://cassandra.apache.org/$$[Apache Cassandra] 's distributed database architecture to provide a virtually unlimited, horizontally scalable persistent store for Infinispan's caches. 
+
+[[sid-68355096_CassandraCacheStore-Version]]
+
+
+=== Version
+
+The Cassandra CacheStore was added in Infinspan 4.2.0 "Ursus". You'll need this release or later in order to use it.
+
+[[sid-68355096_CassandraCacheStore-]]
+
+
+=== 
+
+Configuration
+
+In order to use this CacheStore you need to create an appropriate  keyspace on your Cassandra database. The following storage-conf.xml  excerpt shows the declaration of the keyspace:
+
+
+----
+<Keyspace Name="Infinispan">
+      <ColumnFamily CompareWith="BytesType" Name="InfinispanEntries" KeysCached="10%" />
+      <ColumnFamily CompareWith="LongType" Name="InfinispanExpiration" KeysCached="10%" ColumnType="Super" CompareSubcolumnsWith="BytesType"/>
+      <ColumnFamily CompareWith="BytesType" Name="InfinispanEntries" KeysCached="0" />
+      <ColumnFamily CompareWith="LongType" Name="InfinispanExpiration" KeysCached="0" ColumnType="Super" CompareSubcolumnsWith="BytesType"/>
+      <ReplicaPlacementStrategy>org.apache.cassandra.locator.RackUnawareStrategy</ReplicaPlacementStrategy>
+      <ReplicationFactor>2</ReplicationFactor>
+      <EndPointSnitch>org.apache.cassandra.locator.EndPointSnitch</EndPointSnitch>
+</Keyspace>
+----
+
+ The important bits are the CompareWith, ColumnType and CompareSubColumnsWith declarations. Everything else can be changed at will. You can also have more than one Keyspace to accomodate for multiple caches. Also bear in mind that the current version of the CassandraCacheStore only supports the OrderPreservingPartitioner. You then need to add an appropriate cache declaration to your infinispan.xml (or whichever file you use to configure Infinispan): 
+
+
+----
+<namedCache name="cassandraCache">
+        <loaders passivation="false" shared="true" preload="false">
+                <loader
+                        class="org.infinispan.loaders.cassandra.CassandraCacheStore"
+                        fetchPersistentState="true" ignoreModifications="false"
+                        purgeOnStartup="false">
+                        <properties>
+                                <property name="host" value="localhost" />
+                                <property name="keySpace" value="Infinispan" />
+                                <property name="entryColumnFamily" value="InfinispanEntries" />
+                                <property name="expirationColumnFamily" value="InfinispanExpiration" />
+                                <property name="sharedKeyspace" value="false" />
+                                <property name="readConsistencyLevel" value="ONE" />
+                                <property name="writeConsistencyLevel" value="ONE" />
+                                <property name="configurationPropertiesFile" value="cassandrapool.properties" />         
+                                <property name="keyMapper" value="org.infinispan.loaders.keymappers.DefaultTwoWayKey2StringMapper" />
+                        </properties>
+                </loader>
+        </loaders>
+</namedCache>
+----
+
+ It is important the the shared property on the loader element is set to true because all the Infinispan nodes will share the same Cassandra cluster. Since the Cassandra client library doesn't provide connection pooling, a separate project has been created at link:$$http://github.com/tristantarrant/cassandra-connection-pool$$[] . Configuration of the connection pool can be done by creating an appropriate properties file and specifying its name in the configuration ( _configurationPropertiesFile_ ). The following is an example file: 
+
+
+----
+socketTimeout = 5000
+initialSize = 10
+maxActive = 100
+maxIdle = 20
+minIdle = 10
+maxWait = 30000testOnBorrow = false
+testOnReturn = false
+testWhileIdle = false
+timeBetweenEvictionRunsMillis = 5000removeAbandoned = false
+removeAbandonedTimeout = 60
+logAbandoned = false
+
+----
+
+Here is a description of the various properties which can be configured:
+
+
+|===============
+|host|a hostname (or a comma-separated list of hostnames)
+|port|the thrift port (usually 9160)
+|keySpace|the keyspace to use (defaults to Infinispan)
+|entryColumnFamily|the column family where entry values will be stored. Make sure you configure your keyspace accordingly (defaults to InfinispanEntries)
+|expirationColumnFamily|the column family where element expiration information is stored. Make sure your  (defaults to InfinispanExpiration)
+|sharedKeyspace|whether multiple caches are to be stored in a single keyspace. In this case the cache name is prefixed to the key entries (defaults to false).
+|readConsistencyLevel| The consistency level to use when reading from Cassandra. Possible values are ONE, QUORUM, DCQUORUM, ALL. For an explanation of these refer to the link:$$http://wiki.apache.org/cassandra/API$$[Cassandra API documentation.] (defaults to ONE) 
+|writeConsistencyLevel| The consistency level to use when writing to Cassandra. Possible values are ZERO, ANY, ONE, QUORUM, DCQUORUM, ALL. For an explanation of these refer to the link:$$http://wiki.apache.org/cassandra/API$$[Cassandra API documentation.] (defaults to ONE) 
+|keyMapper|A class which implements Infinispan's TwoWayKey2StringMapper interface for mapping cache keys to Cassandra row keys (defaults to org.infinispan.loaders.keymappers.DefaultTwoWayKey2StringMapper)
+
+|===============
+
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-5-Integration_with_other_frameworks.adoc b/documentation/src/main/asciidoc/user_guide/chapter-5-Integration_with_other_frameworks.adoc
new file mode 100644
index 0000000..7241746
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-5-Integration_with_other_frameworks.adoc
@@ -0,0 +1,19 @@
+[[sid-68355028_UserGuide-Integrationwithotherframeworks]]
+
+==  Integration with other frameworks
+
+
+.  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737110$$[Using Infinispan as JPA/Hibernate Second Level Cache Provider] 
+
+
+.  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737126$$[Standalone JTA for JPA/Hibernate using Infinispan as 2LC] 
+
+
+.  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737057$$[Infinispan as Hibernate 2nd-Level Cache in JBoss AS 5.x] 
+
+
+.  link:$$http://community.jboss.org/docs/16180$$[Using Infinispan in JBoss Application Server 6] 
+
+
+.  link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737118$$[Using Infinispan as Spring Cache provider] 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-50-Infinispan_Custom_Interceptors.adoc b/documentation/src/main/asciidoc/user_guide/chapter-50-Infinispan_Custom_Interceptors.adoc
new file mode 100644
index 0000000..d4c3b31
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-50-Infinispan_Custom_Interceptors.adoc
@@ -0,0 +1,69 @@
+[[sid-68355097]]
+
+==  Infinispan Custom Interceptors
+
+[[sid-68355097_InfinispanCustomInterceptors-Introduction]]
+
+
+=== Introduction
+
+ It is possible to add custom interceptors to Infinispan, both declaratively and programatically. Custom interceptors are an way of extending Infinispan by being able to influence or respond to any modifications to cache. Example of such modifications are: elements are added/removed/updated or transactions are committed. For a detailed list refer to link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/interceptors/base/CommandInterceptor.html$$[CommandInterceptor] API. 
+
+[[sid-68355097_InfinispanCustomInterceptors-Addingcustominterceptorsdeclaratively]]
+
+
+=== Adding custom interceptors declaratively
+
+ Custom interceptors can be added on a per named cache basis. This is because each named cache have it's own interceptor stack. Following xml snippet depicts the ways in which an custom interceptor can be added. 
+
+
+----
+   <namedCache name="cacheWithCustomInterceptors">
+      <!--
+      Define custom interceptors.  All custom interceptors need to extend org.jboss.cache.interceptors.base.CommandInterceptor
+      -->
+      <customInterceptors>
+         <interceptor position="FIRST" class="com.mycompany.CustomInterceptor1">
+            <properties>
+               <property name="attributeOne" value="value1" />
+               <property name="attributeTwo" value="value2" />
+            </properties>
+         </interceptor>
+         <interceptor position="LAST" class="com.mycompany.CustomInterceptor2"/>
+         <interceptor index="3" class="com.mycompany.CustomInterceptor1"/>
+         <interceptor before="org.infinispanpan.interceptors.CallInterceptor" class="com.mycompany.CustomInterceptor2"/>
+         <interceptor after="org.infinispanpan.interceptors.CallInterceptor" class="com.mycompany.CustomInterceptor1"/>
+      </customInterceptors>
+   </namedCache>
+
+
+----
+
+ _Adding custom interceptors programatically_ 
+
+ In order to do that one needs to obtain a reference to the link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/AdvancedCache.html$$[AdvancedCache] . This can be done ass follows: 
+
+
+----
+CacheManager cm = getCacheManager();//magic
+Cache aCache = cm.getCache("aName");
+AdvancedCache advCache = aCache.getAdvancedCache();
+
+----
+
+ Then one of the _addInterceptor()_ methods should be used to add the actual interceptor. For further documentation refer to link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/AdvancedCache.html$$[AdvancedCache] javadoc. 
+
+[[sid-68355097_InfinispanCustomInterceptors-Custominterceptordesign]]
+
+
+=== Custom interceptor design
+
+
+*  Custom interceptors must extend link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/interceptors/base/BaseCustomInterceptor.html$$[BaseCustomInterceptor] 
+
+
+* Custom interceptors must declare a public, empty constructor to enable construction.
+
+
+* Custom  interceptors will have setters for any property defined through property tag.
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-51-Talking_To_Infinispan_Memcached_Servers_From_Non_Java_Clients.adoc b/documentation/src/main/asciidoc/user_guide/chapter-51-Talking_To_Infinispan_Memcached_Servers_From_Non_Java_Clients.adoc
new file mode 100644
index 0000000..708857f
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-51-Talking_To_Infinispan_Memcached_Servers_From_Non_Java_Clients.adoc
@@ -0,0 +1,49 @@
+[[sid-68355098]]
+
+==  Talking To Infinispan Memcached Servers From Non-Java Clients
+
+This wiki shows how to talk to Infinispan memcached server via non-java client, such as a python script.
+
+[[sid-68355098_TalkingToInfinispanMemcachedServersFromNon-JavaClients-MultiClusteredServerTutorial]]
+
+
+=== Multi Clustered Server Tutorial
+
+The second example showcases the distribution capabilities of Infinispan memcached severs that are not available in the original memcached implementation.
+
+
+* Start first Infinispan memcached server giving to it a port number and an Infinispan configuration supporting distribution. This configuration is the same one used for the GUI demo:
+
+
+* 
+----
+./bin/startServer.sh -r memcached -c etc/config-samples/gui-demo-cache-config.xml -p 12211
+----
+
+
+* Start a second Infinispan memcached server passing to it a different port number:
+
+
+* 
+----
+./bin/startServer.sh -r memcached -c etc/config-samples/gui-demo-cache-config.xml -p 13211
+----
+
+
+*  Execute link:$$http://anonsvn.jboss.org/repos/infinispan/branches/4.1.x/server/memcached/src/test/resources/test_memcached_read.py$$[test_memcached_write.py] script which basically executes several write operations againts the Infinispan memcached server bound to port 12211. If the script is executed successfully, you should see an output similar to this: 
+
+
+* 
+----
+<li>Connecting to 127.0.0.1:12211</li><li>Testing set ['Simple_Key': Simple value] ... OK</li><li>Testing set ['Expiring_Key' : 999 : 3] ... OK</li><li>Testing increment 3 times ['Incr_Key' : starting at 1 ]</li><li>Initialise at 1 ... OK</li><li>Increment by one ... OK</li><li>Increment again ... OK</li><li>Increment yet again ... OK</li><li>Testing decrement 1 time ['Decr_Key' : starting at 4 ]</li><li>Initialise at 4 ... OK</li><li>Decrement by one ... OK</li><li>Testing decrement 2 times in one call ['Multi_Decr_Key' : 3 ]</li><li>Initialise at 3 ... OK</li><li>Decrement by 2 ... OK</li>
+----
+
+
+*  Execute link:$$http://anonsvn.jboss.org/repos/infinispan/branches/4.1.x/server/memcached/src/test/resources/test_memcached_read.py$$[test_memcached_read.py] script which connects to server bound to 127.0.0.1:13211 and verifies that it can read the data that was written by the writer script to the first server. If the script is executed successfully, you should see an output similar to this: 
+
+
+* 
+----
+<li>Connecting to 127.0.0.1:13211</li><li>Testing get ['Simple_Key'] should return Simple value ... OK</li><li>Testing get ['Expiring_Key'] should return nothing... OK</li><li>Testing get ['Incr_Key'] should return 4 ... OK</li><li>Testing get ['Decr_Key'] should return 3 ... OK</li><li>Testing get ['Multi_Decr_Key'] should return 1 ... OK</li>
+----
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-52-Plugging_Infinispan_With_User_Defined_Externalizers.adoc b/documentation/src/main/asciidoc/user_guide/chapter-52-Plugging_Infinispan_With_User_Defined_Externalizers.adoc
new file mode 100644
index 0000000..2ccad87
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-52-Plugging_Infinispan_With_User_Defined_Externalizers.adoc
@@ -0,0 +1,277 @@
+[[sid-68355099]]
+
+==  Plugging Infinispan With User Defined Externalizers
+
+[[sid-68355099_PluggingInfinispanWithUserDefinedExternalizers-Introduction]]
+
+
+=== Introduction
+
+One of the key aspects of Infinispan is that it often needs to marshall/unmarshall objects in order to provide some of its functionality. For example, if it needs to store objects in a write-through or write-behind cache store, the stored objects need marshalling. If a cluster of Infinispan nodes is formed, objects shipped around need marshalling. Even if you enable lazy deserialization, objects need to be marshalled so that they can be lazily unmarshalled with the correct classloader.
+
+ Using standard JDK serialization is slow and produces payloads that are too big and can affect bandwidth usage. On top of that, JDK serialization does not work well with objects that are supposed to be immutable. In order to avoid these issues, Infinispan uses link:$$http://jboss.org/jbossmarshalling$$[JBoss Marshalling] for marshalling/unmarshalling objects. JBoss Marshalling is fast, produces very space efficient payloads, and on top of that  during unmarshalling, it enables users to have full control over how to construct objects, hence allowing objects to carry on being immutable. 
+
+Starting with 5.0, users of Infinispan can now benefit from this marshalling framework as well, and they can provide their own externalizer implementations, but before finding out how to provide externalizers, let's look at the benefits they bring.
+
+[[sid-68355099_PluggingInfinispanWithUserDefinedExternalizers-BenefitsofExternalizers]]
+
+
+=== Benefits of Externalizers
+
+ The JDK provides a simple way to serialize objects which, in its simplest form, is just a matter of extending link:$$http://download.oracle.com/javase/6/docs/api/java/io/Serializable.html$$[java.io.Serializable] , but as it's well known, this is known to be slow and it generates payloads that are far too big. An alternative way to do serialization, still relying on JDK serialization, is for your objects to extend link:$$http://download.oracle.com/javase/6/docs/api/java/io/Externalizable.html$$[java.io.Externalizable] . This allows for users to provide their own ways to marshall/unmarshall classes, but has some serious issues because, on top of relying on slow JDK serialization, it forces the class that you want to serialize to extend this interface, which has two side effects: The first is that you're forced to modify the source code of the class that you want to marshall/unmarshall which you might not be able to do because you either, don't own the source, or you don't even have it. Secondly, since Externalizable implementations do not control object creation, you're forced to add set methods in order to restore the state, hence potentially forcing your immutable objects to become mutable. 
+
+ Instead of relying on JDK serialization, Infinispan uses JBoss Marshalling to serialize objects and requires any classes to be serialized to be associated with an link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/marshall/Externalizer.html$$[Externalizer] interface implementation that knows how to transform an object of a particular class into a serialized form and how to read an object of that class from a given input. Infinispan does not force the objects to be serialized to implement Externalizer. In fact, it is recommended that a separate class is used to implement the Externalizer interface because, contrary to JDK serialization, Externalizer implementations control how objects of a particular class are created when trying to read an object from a stream. This means that readObject() implementations are responsible of creating object instances of the target class, hence giving users a lot of flexibility on how to create these instances (whether direct instantiation, via factory or reflection), and more importantly, allows target classes to carry on being immutable. This type of externalizer architecture promotes good OOP designs principles, such as the principle of link:$$http://en.wikipedia.org/wiki/Single_responsibility_principle$$[single responsibility] . 
+
+It's quite common, and in general recommended, that Externalizer implementations are stored as inner static public classes within classes that they externalize. The advantages of doing this is that related code stays together, making it easier to maintain. In Infinispan, there are two ways in which Infinispan can be plugged with user defined externalizers:
+
+[[sid-68355099_PluggingInfinispanWithUserDefinedExternalizers-UserFriendlyExternalizers]]
+
+
+==== User Friendly Externalizers
+
+ In the simplest possible form, users just need to provide an link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/marshall/Externalizer.html$$[Externalizer] implementation for the type that they want to marshall/unmarshall, and then annotate the marshalled type class with {@link SerializeWith} annotation indicating the externalizer class to use. For example: 
+
+
+----
+import org.infinispan.marshall.Externalizer;
+import org.infinispan.marshall.SerializeWith;
+
+@SerializeWith(Person.PersonExternalizer.class)
+public class Person {
+
+   final String name;
+   final int age;
+
+   public Person(String name, int age) {
+      this.name = name;
+      this.age = age;
+   }
+
+   public static class PersonExternalizer implements Externalizer<Person> {
+      @Override
+      public void writeObject(ObjectOutput output, Person person) 
+            throws IOException {
+         output.writeObject(person.name);
+         output.writeInt(person.age);
+      }
+
+      @Override
+      public Person readObject(ObjectInput input) 
+            throws IOException, ClassNotFoundException {
+         return new Person((String) input.readObject(), input.readInt());
+      }
+   }
+}
+
+----
+
+At runtime JBoss Marshalling will inspect the object and discover that's marshallable thanks to the annotation and so marshall it using the externalizer class passed. To make externalizer implementations easier to code and more typesafe, make sure you define type &lt;T&gt; as the type of object that's being marshalled/unmarshalled.
+
+Even though this way of defining externalizers is very user friendly, it has some disadvantages:
+
+
+* Due to several constraints of the model, such as support different versions of the same class or the need to marshall the Externalizer class, the payload sizes generated via this method are not the most efficient.
+
+
+* This model requires for the marshalled class to be annotated with {@link SerializeWith} but a user might need to provide an Externalizer for a class for which source code is not available, or for any other constraints, it cannot be modified.
+
+
+* The use of annotations by this model might be limiting for framework developers or service providers that try to abstract lower level details, such as the marshalling layer, away from the user.
+
+If you're affected by any of these disadvantages, an alternative method to provide externalizers is available via more advanced externalizers:
+
+[[sid-68355099_PluggingInfinispanWithUserDefinedExternalizers-AdvancedExternalizers]]
+
+
+==== Advanced Externalizers
+
+ link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/marshall/AdvancedExternalizer.html$$[AdvancedExternalizer] provides an alternative way to provide externalizers for marshalling/unmarshalling user defined classes that overcome the deficiencies of the more user-friendly externalizer definition model explained in Externalizer. For example: 
+
+
+----
+import org.infinispan.marshall.AdvancedExternalizer;
+
+public class Person {
+
+   final String name;
+   final int age;
+
+   public Person(String name, int age) {
+      this.name = name;
+      this.age = age;
+   }
+
+   public static class PersonExternalizer implements AdvancedExternalizer<Person> {
+      @Override
+      public void writeObject(ObjectOutput output, Person person)
+            throws IOException {
+         output.writeObject(person.name);
+         output.writeInt(person.age);
+      }
+
+      @Override
+      public Person readObject(ObjectInput input)
+            throws IOException, ClassNotFoundException {
+         return new Person((String) input.readObject(), input.readInt());
+      }
+
+      @Override
+      public Set<Class<? extends Person>> getTypeClasses() {
+         return Util.<Class<? extends Person>>asSet(Person.class);
+      }
+
+      @Override
+      public Integer getId() {
+         return 2345;
+      }
+   }
+}
+
+----
+
+ The first noticeable difference is that this method does not require user classes to be annotated in anyway, so it can be used with classes for which source code is not available or that cannot be modified. The bound between the externalizer and the classes that are marshalled/unmarshalled is set by providing an implementation for link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/marshall/AdvancedExternalizer.html#getTypeClasses()$$[getTypeClasses()] which should return the list of classes that this externalizer can marshall: 
+
+[[sid-68355099_PluggingInfinispanWithUserDefinedExternalizers-LinkingExternalizerswithMarshallerClasses]]
+
+
+===== Linking Externalizers with Marshaller Classes
+
+Once the Externalizer's readObject() and writeObject() methods have been implemented, it's time to link them up together with the type classes that they externalize. To do so, the Externalizer implementation must provide a getTypeClasses() implementation. For example:
+
+
+----
+import org.infinispan.util.Util;
+...
+@Override
+public Set<Class<? extends ReplicableCommand>> getTypeClasses() {
+  return Util.asSet(LockControlCommand.class, RehashControlCommand.class,
+      StateTransferControlCommand.class, GetKeyValueCommand.class,
+      ClusteredGetCommand.class, MultipleRpcCommand.class,
+      SingleRpcCommand.class, CommitCommand.class,
+      PrepareCommand.class, RollbackCommand.class,
+      ClearCommand.class, EvictCommand.class,
+      InvalidateCommand.class, InvalidateL1Command.class,
+      PutKeyValueCommand.class, PutMapCommand.class,
+      RemoveCommand.class, ReplaceCommand.class);
+}
+
+----
+
+In the code above, ReplicableCommandExternalizer indicates that it can externalize several type of commands. In fact, it marshalls all commands that extend ReplicableCommand interface, but currently the framework only supports class equality comparison and so, it's not possible to indicate that the classes to marshalled are all children of a particular class/interface.
+
+However there might sometimes when the classes to be externalized are private and hence it's not possible to reference the actual class instance. In this situations, users can attempt to look up the class with the given fully qualified class name and pass that back. For example:
+
+
+----
+@Override
+public Set<Class<? extends List>> getTypeClasses() {
+  return Util.<Class<? extends List>>asSet(
+         Util.loadClass("java.util.Collections$SingletonList"));
+}
+
+----
+
+[[sid-68355099_PluggingInfinispanWithUserDefinedExternalizers-ExternalizerIdentifier]]
+
+
+===== Externalizer Identifier
+
+ Secondly, in order to save the maximum amount of space possible in the payloads generated, advanced externalizers require externalizer implementations to provide a positive identified via link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/marshall/AdvancedExternalizer.html#getId()$$[getId()] implementations or via XML/programmatic configuration that identifies the externalizer when unmarshalling a payload.  In order for this to work however, advanced externalizers require externalizers to be registered on cache manager creation time via XML or programmatic configuration which will be explained in next section. On the contrary, externalizers based on Externalizer and SerializeWith require no pre-registration whatsoever. Internally, Infinispan uses this advanced externalizer mechanism in order to marshall/unmarshall internal classes. 
+
+So, getId() should return a positive integer that allows the externalizer to be identified at read time to figure out which Externalizer should read the contents of the incoming buffer, or it can return null. If getId() returns null, it is indicating that the id of this advanced externalizer will be defined via XML/programmatic configuration, which will be explained in next section.
+
+Regardless of the source of the the id, using a positive integer allows for very efficient variable length encoding of numbers, and it's much more efficient than shipping externalizer implementation class information or class name around. Infinispan users can use any positive integer as long as it does not clash with any other identifier in the system. It's important to understand that a user defined externalizer can even use the same numbers as the externalizers in the Infinispan Core project because the internal Infinispan Core externalizers are special and they use a different number space to the user defined externalizers. On the contrary, users should avoid using numbers that are within the pre-assigned identifier ranges which can be found at the end of this article. Infinispan checks for id duplicates on startup, and if any are found, startup is halted with an error.
+
+When it comes to maintaining which ids are in use, it's highly recommended that this is done in a centralized way. For example, getId() implementations could reference a set of statically defined identifiers in a separate class or interface. Such class/interface would give a global view of the identifiers in use and so can make it easier to assign new ids.
+
+[[sid-68355099_PluggingInfinispanWithUserDefinedExternalizers-RegisteringAdvancedExternalizers]]
+
+
+===== Registering Advanced Externalizers
+
+The following example shows the type of configuration required to register an advanced externalizer implementation for Person object shown earlier stored as a static inner class within it:
+
+XML:
+
+
+----
+<infinispan>
+  <global>
+    <serialization>
+      <advancedExternalizers>
+        <advancedExternalizer externalizerClass="Person$PersonExternalizer"/>
+      </advancedExternalizers>
+    </serialization>
+  </global>
+  ...
+</infinispan>
+
+----
+
+Programmatically:
+
+
+----
+GlobalConfigurationBuilder builder = ...
+builder.serialization()
+   .addAdvancedExternalizer(new Person.PersonExternalizer());
+
+----
+
+As mentioned earlier, when listing these externalizer implementations, users can optionally provide the identifier of the externalizer via XML or programmatically instead of via getId() implementation. Again, this offers a centralized way to maintain the identifiers but it's important that the rules are clear: An AdvancedExternalizer implementation, either via XML/programmatic configuration or via annotation, needs to be associated with an identifier. If it isn't, Infinispan will throw an error and abort startup. If a particular AdvancedExternalizer implementation defines an id both via XML/programmatic configuration and annotation, the value defined via XML/programmatically is the one that will be used. Here's an example of an externalizer whose id is defined at registration time:
+
+
+----
+<infinispan>
+  <global>
+    <serialization>
+      <advancedExternalizers>
+        <advancedExternalizer id="123" 
+                              externalizerClass="Person$PersonExternalizer"/>
+      </advancedExternalizers>
+    </serialization>
+  </global>
+  ...
+</infinispan>
+
+----
+
+Programmatically:
+
+
+----
+GlobalConfigurationBuilder builder = ...
+builder.serialization()
+   .addAdvancedExternalizer(123, new Person.PersonExternalizer());
+
+----
+
+Finally, a couple of notes about the programmatic configuration. GlobalConfiguration.addExternalizer() takes varargs, so it means that it is possible to register multiple externalizers in just one go, assuming that their ids have already been defined via @Marshalls annotation. For example:
+
+
+----
+builder.serialization()
+   .addAdvancedExternalizer(new Person.PersonExternalizer(),
+                            new Address.AddressExternalizer());
+
+----
+
+[[sid-68355099_PluggingInfinispanWithUserDefinedExternalizers-PreassignedExternalizerIdRanges]]
+
+
+===== Preassigned Externalizer Id Ranges
+
+This is the list of Externalizer identifiers that are used by Infinispan based modules or frameworks. Infinispan users should avoid using ids within these ranges.
+
+
+|===============
+|Infinispan Tree Module:|1000 - 1099
+|Infinispan Server Modules:|1100 - 1199
+|Hibernate Infinispan Second Level Cache:|1200 - 1299
+|Infinispan Lucene Directory:|1300 - 1399
+|Hibernate OGM:|1400 - 1499
+|Hibernate Search:|1500 - 1599
+
+|===============
+
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-53-Using_the_Cache_API.adoc b/documentation/src/main/asciidoc/user_guide/chapter-53-Using_the_Cache_API.adoc
new file mode 100644
index 0000000..9e27b09
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-53-Using_the_Cache_API.adoc
@@ -0,0 +1,128 @@
+[[sid-68355100]]
+
+==  Using the Cache API
+
+[[sid-68355100_UsingtheCacheAPI-TheCacheinterface]]
+
+
+=== The Cache interface
+
+ Infinispan exposes a simple, link:$$http://jcp.org/en/jsr/detail?id=107$$[JSR-107] compliant link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html$$[Cache] interface. 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+The Cache interface exposes simple methods for adding, retrieving and removing entries, including atomic mechanisms exposed by the JDK's ConcurrentMap interface.  Based on the cache mode used, invoking these methods will trigger a number of things to happen, potentially even including replicating an entry to a remote node or looking up an entry from a remote node, or potentially a cache store.
+
+
+----
+Note: For simple usage, using the Cache API should be no different from using the JDK Map API, and hence migrating from simple in-memory caches based on a Map to Infinispan's Cache should be trivial.
+
+----
+
+[[sid-68355100_UsingtheCacheAPI-LimitationsofCertainMapMethods]]
+
+
+==== Limitations of Certain Map Methods
+
+ Certain methods exposed in Map have certain limitations when used with Infinispan, such as link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html#size%28%29$$[size()] , link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html#values%28%29$$[values()] , link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html#keySet%28%29$$[keySet()] and link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html#entrySet%28%29$$[entrySet()] .  Specifically, these methods are _unreliable_ and only provide a best-effort guess.  They do not acquire locks, either local or global, and concurrent modifications, additions and removals will not be considered in the result of any of these calls.  Further, they only operate on the local node, and as such, do not give you a global(cluster) view of the state. 
+
+Attempting to perform these operations globally would have large performance impact as well as become a scalability bottleneck.  As such, these methods should only be used for informational or debugging purposes only.
+
+[[sid-68355100_UsingtheCacheAPI-MortalandImmortalData]]
+
+
+==== Mortal and Immortal Data
+
+ Further to simply storing entries, Infinispan's cache API allows you to attach mortality information to data.  For example, simply using link:$$http://java.sun.com/javase/6/docs/api/java/util/Map.html#put%28K,%20V%29$$[put(key, value)] would create an _immortal_ entry, i.e., an entry that lives in the cache forever, until it is removed (or evicted from memory to prevent running out of memory).  If, however, you put data in the cache using link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html#put%28K,%20V,%20long,%20java.util.concurrent.TimeUnit%29$$[put(key, value, lifespan, timeunit)] , this creates a _mortal_ entry, i.e., an entry that has a fixed lifespan and expires after that lifespan. 
+
+ In addition to _lifespan_ , Infinispan also supports _maxIdle_ as an additional metric with which to determine expiration.  Any combination of lifespans or maxIdles can be used. 
+
+[[sid-68355100_UsingtheCacheAPI-ExampleofUsingExpiryandMortalData]]
+
+
+==== Example of Using Expiry and Mortal Data
+
+ See link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737114$$[this page] for an example of using mortal data with Infinispan 
+
+[[sid-68355100_UsingtheCacheAPI-%7B%7BputForExternalRead%7D%7Doperation]]
+
+
+==== putForExternalRead operation
+
+ Infinispan's link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/Cache.html$$[Cache] class contains a different 'put' operation called link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/Cache.html#putForExternalRead(K, V)$$[putForExternalRead] . This operation is particularly useful when Infinispan is used as a temporary cache for data that is persisted elsewhere.  Under heavy read scenarios, contention in the cache should not delay the real transactions at hand, since caching should just be an optimization and not something that gets in the way. 
+
+ To achieve this, putForExternalRead acts as a put call that only operates if the key is not present in the cache, and fails fast and silently if another thread is trying to store the same key at the same time. In this particular scenarion, caching data is a way to optimise the system and it's not desirable that a failure in caching affects the on-going transaction, hence why failure is handled differently. putForExternalRead is consider to be a fast operation because regardless of whether it's successful or not, it doesn't wait for any locks, and so returns to the caller promptly. 
+
+ To understand how to use this operation, let's look at basic example. Imagine a cache of Person instances, each keyed by a PersonId , whose data originates in a separate data store. The following code shows the most common pattern of using link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/Cache.html#putForExternalRead(K, V)$$[putForExternalRead] within the context of this example: 
+
+
+----
+
+// Id of the person to look up, provided by the application
+PersonId id = ...;
+
+// Get a reference to the cache where person instances will be stored
+Cache<PersonId, Person> cache = ...;
+
+// First, check whether the cache contains the person instance
+// associated with with the given id
+Person cachedPerson = cache.get(id);
+
+if (cachedPerson == null) {
+   // The person is not cached yet, so query the data store with the id
+   Person person = dataStore.lookup(id);
+
+   // Cache the person along with the id so that future requests can
+   // retrieve it from memory rather than going to the data store
+   cache.putForExternalRead(id, person);
+} else {
+   // The person was found in the cache, so return it to the application
+   return cachedPerson;
+}
+
+----
+
+ Please note that link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/Cache.html#putForExternalRead(K, V)$$[putForExternalRead] should never be used as a mechanism to update the cache with a new Person instance originating from application execution (i.e. from a transaction that modifies a Person's address). When updating cached values, please use the standard link:$$http://java.sun.com/javase/6/docs/api/java/util/Map.html?is-external=true#put(K, V)$$[put] operation, otherwise the possibility of caching corrupt data is likely. 
+
+[[sid-68355100_UsingtheCacheAPI-TheAdvancedCacheinterface]]
+
+
+=== The AdvancedCache interface
+
+ In addition to the simple Cache interface, Infinispan offers an link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/AdvancedCache.html$$[AdvancedCache] interface, geared towards extension authors.  The AdvancedCache offers the ability to inject custom interceptors, access certain internal components and to apply flags to alter the default behavior of certain cache methods.  The following code snippet depicts how an AdvancedCache can be obtained: 
+
+
+----
+AdvancedCache advancedCache = cache.getAdvancedCache();
+
+----
+
+[[sid-68355100_UsingtheCacheAPI-Flags]]
+
+
+==== Flags
+
+ Flags are applied to regular cache methods to alter the behavior of certain methods.  For a list of all available flags, and their effects, see the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/context/Flag.html$$[Flag] enumeration.  Flags are applied using link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/AdvancedCache.html#withFlags%28org.infinispan.context.Flag...%29$$[AdvancedCache.withFlags()] .  This builder method can be used to apply any number of flags to a cache invocation, for example: 
+
+
+----
+advancedCache.withFlags(Flag.CACHE_MODE_LOCAL, Flag.SKIP_LOCKING)
+   .withFlags(Flag.FORCE_SYNCHRONOUS)
+   .put("hello", "world");
+
+
+----
+
+[[sid-68355100_UsingtheCacheAPI-CustomInterceptors]]
+
+
+==== Custom Interceptors
+
+The AdvancedCache interface also offers advanced developers a mechanism with which to attach custom interceptors.  Custom interceptors allow developers to alter the behavior of the cache API methods, and the AdvancedCache interface allows developers to attach these interceptors programmatically, at run-time.  See the AdvancedCache Javadocs for more details.
+
+ For more information on writing custom interceptors, see link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737149$$[/javascript:;] 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-54-Local_mode_cache.adoc b/documentation/src/main/asciidoc/user_guide/chapter-54-Local_mode_cache.adoc
new file mode 100644
index 0000000..110b779
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-54-Local_mode_cache.adoc
@@ -0,0 +1,70 @@
+[[sid-68355101]]
+
+==  Local mode cache
+
+ _Introduction_ 
+
+ Even though Infinispan's biggest potential is as distributed, in-memory data grid platform, one aspect of it often gets overlooked - it can be used as a standalone cache node. But why would anyone use Infinispan over, say, a link:$$http://java.sun.com/javase/6/docs/api/java/util/concurrent/ConcurrentHashMap.html$$[ConcurrentHashMap] ? Here are some reasons: _$$__$$_ 
+
+
+*  _Eviction._ Built-in eviction ensures you don't run out of memory. 
+
+
+*  _Write-through and write-behind caching._ Going beyond memory and onto disk (or any other pluggable link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/loaders/CacheStore.html$$[CacheStore] ) means that your state survives restarts, and preloaded hot caches can be configured. 
+
+
+*  _JTA support and XA compliance._ Participate in ongoing transactions with any link:$$http://java.sun.com/javaee/technologies/jta/index.jsp$$[JTA] -compliant transaction manager. 
+
+
+*  _MVCC-based concurrency._ Highly optimized for fast, non-blocking readers. 
+
+
+*  _Manageability._ link:$$http://docs.jboss.org/infinispan/4.0/apidocs/jmxComponents.html$$[Simple JMX] or rich GUI management console via link:$$http://community.jboss.org/docs/DOC-13721$$[JOPR] , you have a choice. 
+
+
+*  _Not just for the JVM._ link:$$http://community.jboss.org/docs/DOC-14095$$[RESTful API] , and upcoming link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3736765$$[client/server modules] speaking Memcached and link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=9470083$$[HotRod] protocols help non-JVM platforms use Infinispan. 
+
+
+*  _Cluster-ready._ Should the need arise. _$$__$$_ So how do you get started with Infinispan in local mode? The simplest configuration file containing just 
+
+
+----
+<infinispan/>
+
+----
+
+ is enough to get you started, or you can create DefaultCacheManager with _no_ - _argument_ constructor. Either approach creates local default cache. 
+
+ All the features above are exposed via an easy-to-use link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html$$[Cache] interface, which extends link:$$http://java.sun.com/javase/6/docs/api/java/util/concurrent/ConcurrentMap.html$$[ConcurrentMap] and is compatible with many other cache systems. Infinispan even ships with link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737098$$[migration tools] to help you move off other cache solutions onto Infinispan, whether you need a cache to store data retrieved remotely or simply as a link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737110$$[2nd level cache for Hibernate] . 
+
+ _Performance_ 
+
+ In the process of testing and tuning Infinispan on very large clusters, we have started to put together a link:$$http://cachebenchfwk.sourceforge.net/$$[benchmarking framework] . As a part of this framework, we have the ability to measure cache performance in standalone, local mode. We compared Infinispan 4.0 in local mode against the latest JBoss Cache release (3.2.2.GA) and EHCache (1.7.2). Some background on the tests: 
+
+
+*  Used a latest snapshot of the link:$$http://cachebenchfwk.sourceforge.net/$$[CacheBenchFwk] 
+
+
+*  Run on a link:$$http://www.redhat.com/rhel/$$[RHEL] 5 server with 4 Intel Xeon cores, 4GB of RAM 
+
+
+* Sun JDK 1.6.0_18, with -Xms1g -Xmx1g
+
+
+* Test run on a single node, with 25 concurrent threads, using randomly generated Strings as keys and values and a 1kb payload for each entry, with a 80/20 read/write ratio.
+
+
+* Performance measured in transactions per second (higher = better).
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ In summary, what we have here is that when run in local mode, Infinispan is a high-performance standalone caching engine which offers a rich set of features while still being trivially simple to configure and use. 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-55-Infinispan_Command_line_Console.adoc b/documentation/src/main/asciidoc/user_guide/chapter-55-Infinispan_Command_line_Console.adoc
new file mode 100644
index 0000000..6ebfe0a
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-55-Infinispan_Command_line_Console.adoc
@@ -0,0 +1,518 @@
+[[sid-68355102]]
+
+==  Infinispan Command-line Console
+
+Documentation for ispncon version 0.8.1
+
+[[sid-68355102_InfinispanCommand-lineConsole-Whatisispncon%3F]]
+
+
+=== What is ispncon ?
+
+ Ispncon (Infinispan Command-Line Console) is a simple command-line interface to infinispan cache written in python. It accesses the cache in client/server fashion, whereby infinispan link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737048$$[server modules] ( link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737146$$[Hot Rod] , link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737037$$[Memcached] , link:$$http://community.jboss.org/docs/DOC-14095$$[REST] ) have to be properly configured. Once you have a running instance of infinispan with one of the server modules, you can issue simple cache requests via command line, like: 
+
+
+----
+$ ispncon put keyA "Sample value under keyA"
+$ ispncon get keyA
+$ ispncon delete keyA
+
+----
+
+Furthermore it creates an abstraction above the specifics of the client/server protocol you use to access the cache. The basic commands look the same whether you use Hot Rod, memcached or REST. The client/protocol specifics are handled via protocol-specific configuration options or command arguments.
+
+Your shell scripts should look basically the same for all the client modes, if you don't use any protocol specific features.
+
+Behind the scenes the console tool uses existing python clients to handle the communication with particular server modules. The implementations are listed in the following table:
+
+[options="header"]
+|===============
+| _Client_ | _Client implementation_ | _Web_ 
+|Hot Rod|python-client for hotrod| link:$$https://github.com/infinispan/python-client$$[] 
+|Memcached|python-memcached| link:$$https://launchpad.net/python-memcached$$[] 
+|REST|httplib (standard module for python)| link:$$http://docs.python.org/library/httplib.html$$[] 
+
+|===============
+
+
+ The source code and issue reporting for ispncon can be found here: link:$$https://github.com/infinispan/ispncon$$[] 
+
+[[sid-68355102_InfinispanCommand-lineConsole-Installation]]
+
+
+=== Installation
+
+Ispncon requires
+
+
+* python 2.6
+
+
+* python modules: python-devel, setuptools, infinispan, python-memcached
+
+ Installation steps: 
+
+
+----
+$ git clone <a class="jive-link-external-small" href="https://github.com/infinispan/ispncon.git" target="_blank">https://github.com/infinispan/ispncon.git</a>
+$ cd ispncon/src
+$ sudo python setup.py install
+
+----
+
+Make this part of your .bashrc or whatever so you have ispncon command on path
+
+
+----
+export ISPNCON_HOME=/path/to/ispncon
+export PATH=$ISPNCON_HOME/bin:$PATH
+
+----
+
+[[sid-68355102_InfinispanCommand-lineConsole-Basicusage]]
+
+
+=== Basic usage
+
+ _Format_ 
+
+
+----
+ispncon [options] <operation> [operation_options] <op_arguments>
+
+----
+
+ _Options_ 
+
+[options="header"]
+|===============
+| _Option_ | _Meaning_ 
+|-c --client| Client to use, possible values: memcached, rest, hotrod (default) Configuration key: ispncon.client_type 
+|-h --host &lt;host&gt;| Host/ip address to connect to. Default: localhost. Configuration key: ispncon.host 
+|-p --port &lt;port&gt;| Port to connect to. Default: 11222 (hotrod default port) Configuration key: ispncon.port 
+|-C --cache-name &lt;name&gt;| Named cache to use. Default: use default cache (no value) Configuration key: ispncon.cache 
+|-v --version|Print ispncon version and exit
+|-e --exit-on-error|If true and operation fails, then fail with an exit code. If false just  print ERROR message and continue. This mostly makes sense for batch  files.
+|-P --config "&lt;key&gt; &lt;value&gt;"|override configuration option &lt;key&gt; with value &lt;value&gt;.  NOTE: the quotes are necessary, because getopt parser needs to get these  as one string.
+
+|===============
+
+
+ The possible Operations are _put, get, delete, clear, exists, help, config, include_ and each one is described in the sections _Cache operations_ and _Other commands_ . 
+
+[[sid-68355102_InfinispanCommand-lineConsole-Configuration]]
+
+
+=== Configuration
+
+On start-up ispncon reads the file ~/.ispncon to configure some of the default values to use, so that the user doesn't have to enter the options like host, port, client type and cache name everytime he types a cache command.
+
+The format of the config file is like this:
+
+
+----
+[ispncon]
+host = localhost
+port = 8080
+client_type = rest
+cache =
+exit_on_error = False
+default_codec = None
+[rest]
+server_url = /infinispan-server-rest/rest
+content_type = text/plain
+[hotrod]
+use_river_string_keys = True
+
+----
+
+ The config parameters in the section _ispncon_ are described in the_Basic usage_  section. The rest is described here: 
+
+[options="header"]
+|===============
+| _Config key_ | _Meaning_ 
+|rest.server_url| location of the REST server service, in the above example the HTTP requests would be sent to link:$$http://localhost:8080/infinispan-server-rest/rest$$[] 
+|rest.content_type|default MIME content type for entries stored via REST interface
+|default_codec| Default codec to use to encode/decode values. Possible values: None, RiverString, RiverByteArray see section Interoperability with java clients for further info 
+| hotrod.use_river_string_keys | If set to True, hotrod client will encode keys with RiverString codec - this is necessary to be able to access the same data as via Java HotRod Client using the same string keys. see section Interoperability with java clients for further info 
+
+|===============
+
+
+[[sid-68355102_InfinispanCommand-lineConsole-Cacheoperations]]
+
+
+=== Cache operations
+
+[[sid-68355102_InfinispanCommand-lineConsole-put]]
+
+
+==== put
+
+Put data under a specified key.
+
+ _Format_ 
+
+
+----
+put [options] <key> <value>
+
+----
+
+ _Options_ 
+
+.Return values
+[options="header"]
+|===============
+| _Option_ | _Meaning_ 
+|-i --input-filename &lt;filename&gt;|Don't specify the value, instead put the contents of the specified file.
+|-v --version &lt;version&gt;| Put only if version equals version given. Version format differs between protocols: HotRod: 64-bit integer version number Memcached: 64-bit integer unique version id REST: ETag string Not yet implemented for REST client in infinispan, watch link:$$https://issues.jboss.org/browse/ISPN-1084$$[ISPN-1084] for more info. 
+| -l --lifespan &lt;seconds&gt; |Specifies lifespan of the entry. Integer, number of seconds.
+| -I --max-idle &lt;seconds&gt; |Specifies max idle time for the entry. Integer, number of seconds.
+|-a --put-if-absent|Return CONFLICT if value already exists and don't put anything in that case
+| -e --encode &lt;codec&gt; | Encode value using the specified codec 
+
+|===============
+
+
+[options="header"]
+|===============
+| _Exit code_ | _Output_ | _Result description_ 
+|0|STORED|Entry was stored sucessfully
+|1|ERROR &lt;msg&gt;|General error occurred
+|2|NOT_FOUND|-v option was used and entry doesn't exist
+|3|CONFLICT|-a option was used and the entry already exists, or -v was used and versions don't match
+
+|===============
+
+
+NOTE: memcached client won't distinguish between states NOT_FOUND, CONFLICT and ERROR and always will return ERROR if operation wasn't successfull. this is a limitation of python-memcached client.
+
+see issues:
+
+ link:$$https://bugs.launchpad.net/python-memcached/+bug/684689$$[] 
+
+ link:$$https://bugs.launchpad.net/python-memcached/+bug/684690$$[] 
+
+for discussion.
+
+In later ispncon versions python-memcached client might get replaced by a customized version.
+
+[[sid-68355102_InfinispanCommand-lineConsole-get]]
+
+
+==== get
+
+Get the data stored under the specified key.
+
+ _Format_ 
+
+
+----
+get [options] <key>
+
+----
+
+ _Options_ 
+
+.Return values
+[options="header"]
+|===============
+| _Option_ | _Meaning_ 
+|-o --output-filename &lt;filename&gt;|Stores the output of the get operation into the file specified.
+|-v --version| Get version along with the data. Version format differs between protocols: HotRod: 64-bit integer version number Memcached: 64-bit integer unique version id REST: ETag string 
+| -d --decode &lt;codec&gt; | Decode the value using the specified codec. 
+
+|===============
+
+
+[options="header"]
+|===============
+| _Exit code_ | _Output_ | _Result description_ 
+|0| In case no filename was specified: &lt;data, possibly multi-line&gt; (NOTE: the data might contain binary content, that is not suitable for reading in terminal) In case a filename was specified, nothing is printed on standard output. In case -v was specified, the output is prepended with one line: VERSION &lt;version&gt; |Entry was found and is returned.
+| 1 |ERROR &lt;msg&gt;|General error occurred
+| 2 |NOT_FOUND|Requested entry wasn't found in the cache
+
+|===============
+
+
+[[sid-68355102_InfinispanCommand-lineConsole-delete]]
+
+
+==== delete
+
+Delete the entry with the specified key.
+
+ _Format_ 
+
+
+----
+delete [options] <key>
+
+----
+
+ _Options_ 
+
+.Return values
+[options="header"]
+|===============
+| _Option_ | _Meaning_ 
+|-v --version &lt;version&gt;| Deletes only if the specified version matches the version in the cache NOTE: versioned delete is not supported with memcached client. attempt to delete with -v flag will end in ERROR message. with REST client the situation is different, the protocol allows this, but it's not yet implemented in infinispan, watch link:$$https://issues.jboss.org/browse/ISPN-1084$$[ISPN-1084] for more info 
+
+|===============
+
+
+[options="header"]
+|===============
+| _Exit code_ | _Output_ | _Result description_ 
+| 0 |DELETED|Entry was successfully deleted
+| 1 |ERROR &lt;msg&gt;|General error occurred
+| 2 |NOT_FOUND|Entry wasn't found in the cache.
+| 3 |CONFLICT|Option -v was used and versions don't match
+
+|===============
+
+
+[[sid-68355102_InfinispanCommand-lineConsole-clear]]
+
+
+==== clear
+
+Clear the cache
+
+ _Format_ 
+
+
+----
+clear
+
+----
+
+ _Return values_ 
+
+[options="header"]
+|===============
+| _Exit code_ | _Output_ | _Result description_ 
+| 0 |DELETED|Cache was sucessfully cleared
+| 1 |ERROR &lt;msg&gt;|General error occurred
+
+|===============
+
+
+[[sid-68355102_InfinispanCommand-lineConsole-exists]]
+
+
+==== exists
+
+Verify if the entry exists in the cache
+
+ _Format_ 
+
+
+----
+exists <key>
+
+----
+
+ _Return values_ 
+
+[options="header"]
+|===============
+| _Exit code_ | _Output_ | _Result description_ 
+| 0 |EXISTS|Entry with the given key exists
+| 1 |ERROR &lt;msg&gt;|General error occurred
+| 2 |NOT_FOUND|Entry with the given key wasn't found in the cache
+
+|===============
+
+
+NOTE: memcached protocol doesn't support querying for existence of an entry in the cache so exists operation is implemented (inefficiently) by get opeartion, that gets the whole entry with all the data from the server.
+
+[[sid-68355102_InfinispanCommand-lineConsole-version]]
+
+
+==== version
+
+Get version of the entry. Version format differs between protocols:
+
+HotRod: 64-bit integer version number
+
+Memcached: 64-bit integer unique version id
+
+REST: ETag string
+
+NOTE: The purpose of this command is to facilitate the parsing of the version string. HotRod and Memcached client don't support efficient implementation of this operation. They transfer the whole entry from the server to determine the version, so if applicable you are encouraged to use "get -v" command to obtain version together with the data.
+
+REST client implements this operation efficiently by executing HEAD method.
+
+ _Format_ 
+
+
+----
+version <key>
+
+----
+
+ _Return values_ 
+
+[options="header"]
+|===============
+| _Exit code_ | _Output_ | _Result description_ 
+| 0 |&lt;version&gt;|If the entry exists.
+| 1 |ERROR &lt;msg&gt;|General error occurred
+| 2 |NOT_FOUND|Requested entry wasn't found in the cache
+
+|===============
+
+
+[[sid-68355102_InfinispanCommand-lineConsole-Othercommands]]
+
+
+=== Other commands
+
+[[sid-68355102_InfinispanCommand-lineConsole-help]]
+
+
+==== help
+
+Print help about an operation
+
+ _Format_ 
+
+
+----
+help <operation>
+
+----
+
+NOTE: if no operation is supplied, prints list of supported operations
+
+[[sid-68355102_InfinispanCommand-lineConsole-config]]
+
+
+==== config
+
+Change internal state/config of the client. This opeartion has only client-side effect.
+
+ _Format_ 
+
+
+----
+config                - to print current config
+config save           - to save config to ~/.ispncon
+config <key> <value>  - to change config for currently running session
+
+----
+
+ _Configuration values_ 
+
+see section Configuration for the meaning of different configuration options. Currently supported keys are:
+
+
+* cache
+
+
+* host
+
+
+* port
+
+
+* client_type
+
+
+* exit_on_error
+
+
+* rest.server_url
+
+
+* rest.content_type
+
+ These values directly correspond to the keys in the ~/.ispncon config file. The format of the key is 
+
+
+----
+<section>.<config_key>
+
+----
+
+If no section is given, "ispncon" is implied.
+
+ _Return values_ 
+
+[options="header"]
+|===============
+| _Exit code_ | _Output_ | _Result description_ 
+| 0 |STORED|If configuration/client state was updated successfully.
+| 0 |multi-line output with config values|If config command with no parameters was entered.
+| 1 |ERROR &lt;msg&gt;|General error occurred
+
+|===============
+
+
+[[sid-68355102_InfinispanCommand-lineConsole-include]]
+
+
+==== include
+
+Process cache commands from the specified batch file. The commands will be processed line by line.
+
+ _Format_ 
+
+
+----
+include <filename>
+
+----
+
+ _Return values_ 
+
+[options="header"]
+|===============
+| _Exit code_ | _Output_ | _Result description_ 
+|exit code of the last command in the file.|The output depends on the commands present in the input file|depends on the commands in the batch file
+
+|===============
+
+
+NOTE: The name of this command and it's behaviour is going to change in the next version.
+
+[[sid-68355102_InfinispanCommand-lineConsole-Interoperabilitywithjavaclients]]
+
+
+=== Interoperability with java clients
+
+[[sid-68355102_InfinispanCommand-lineConsole-HTTPclients]]
+
+
+==== HTTP clients
+
+when exchanging data via REST interface, the values are interpreted by any client as sequence of bytes. The meaning is given to this byte-sequence by using MIME type specified via "Content-Type" HTTP header. No special interoperability measures are needed here.
+
+[[sid-68355102_InfinispanCommand-lineConsole-HotRodJavaClient]]
+
+
+==== Hot Rod Java Client
+
+ If we want to read in ispncon the entries that were put with Hot Rod Java client, we need to use a special option _$$hotrod.use_river_string_keys = True$$_ . This will cause the string keys to be encoded the same way the Java client does it. 
+
+ Using _$$hotrod.use_river_string_keys = True$$_ we're able to access the data that has been writen by the java client, but we still see the raw binary values. To be able to see a value that has been put by Hot Rod java client in a readable form and vice versa - to be able to see in Hot Rod Java client what we've put via ispncon we need to use a _codec_ . Currently there are two types of codecs: _RiverString_ and _RiverByteArray_ 
+
+ _RiverString_ - will decode a value that has been put as java.lang.String and vice versa - a value encoded with this codec will be returned as java.lang.String on the java side 
+
+ _RiverByteArray_ - analogous to RiverString but works with byte[] (java byte array) 
+
+ Codecs can be used either by specifying a _$$default_codec$$_ option in the ~/.ispncon config file (in section ispncon) or by specifying a codec on each put resp get using _-e (--encode)_ resp _-d (--decode) options_ . 
+
+[[sid-68355102_InfinispanCommand-lineConsole-SpyMemcachedJavaClient]]
+
+
+==== SpyMemcached Java Client
+
+ Tested with link:$$http://code.google.com/p/spymemcached/$$[spymemcached] 2.7. 
+
+Value that is put by ispncon is interpreted as an UTF-8 string. meaning if we supply some bytes, on the java side it will be recreated as new java.lang.String(bytes, "UTF-8")
+
+This also works reversely: values put by java side as java.lang.String will be returned as UTF-8 bytes in ispncon
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-56-Server_Command_Line_Options.adoc b/documentation/src/main/asciidoc/user_guide/chapter-56-Server_Command_Line_Options.adoc
new file mode 100644
index 0000000..925fbaf
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-56-Server_Command_Line_Options.adoc
@@ -0,0 +1,103 @@
+[[sid-68355103]]
+
+==  Server Command Line Options
+
+ Infinispan ships several link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737048$$[server modules] , some of which can be started via calling startServer.sh or startServer.bat scripts from command line. These currently include link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737146$$[Hot Rod] , link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737037$$[Memcached] and link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737036$$[Web Socket] servers. Please find below the set of common command line parameters that can be passed to these servers: 
+
+ 
+.TODO Gliffy image title empty
+image::[]
+
+ Note that starting with Infinispan 4.2.0.CR1, default Hot Rod port has changed from 11311 to 11222. 
+
+
+----
+[g@eq]~/infinispan-4.1.0-SNAPSHOT% ./bin/startServer.sh -h
+usage: startServer [options]
+
+options:
+  -h, --help                         
+        Show this help message
+
+  -V, --version
+        Show version information
+
+  --                  
+        Stop processing options
+
+  -p, --port=<num>                   
+        TCP port number to listen on
+        (default: 11211 for Memcached, 11222 for Hot Rod
+        and 8181 for WebSocket server)
+
+  -l, --host=<host or ip>
+        Interface to listen on
+        (default: 127.0.0.1, localhost)
+
+  -m, --master_threads=<num>
+        Number of threads accepting incoming connections
+        (default: unlimited while resources are available)
+
+  -t, --work_threads=<num>
+        Number of threads processing incoming requests and sending responses
+        (default: unlimited while resources are available)
+
+  -c, --cache_config=<filename>
+        Cache configuration file
+        (default: creates cache with default values)
+
+  -r, --protocol=[memcached|hotrod|websocket]
+        Protocol to understand by the server.
+        This is a mandatory option and you should choose one of these options          
+ 
+  -i, --idle_timeout=<num>
+        Idle read timeout, in seconds, used to detect stale connections
+        (default: -1)
+        If no new messages have been read within this time, 
+        the server disconnects the channel.
+        Passing -1 disables idle timeout.
+
+  -n, --tcp_no_delay=[true|false]
+        TCP no delay flag switch (default: true)
+ 
+  -s, --send_buf_size=<num>
+        Send buffer size (default: as defined by the OS).
+ 
+  -e, --recv_buf_size=<num>
+        Receive buffer size (default: as defined by the OS).
+ 
+  -o, --proxy_host=<host or ip>
+        Host address to expose in topology information sent to clients.
+        If not present, it defaults to configured host.
+        Servers that do not transmit topology information ignore this setting.
+
+  -x, --proxy_port=<num>
+        Port to expose in topology information sent to clients.
+        If not present, it defaults to configured port.
+        Servers that do not transmit topology information ignore this setting.
+ 
+  -k, --topo_lock_timeout=<num>
+        Controls lock timeout (in milliseconds) for those servers that maintain
+        the topology information in an internal cache.
+ 
+  -u, --topo_repl_timeout=<num>
+        Sets the maximum replication time (in milliseconds) for transfer of 
+        topology information between servers.
+        If state transfer is enabled, this setting also controls the topology 
+        cache state transfer timeout.
+        If state transfer is disabled, it controls the amount of time to wait 
+        for this topology data to be lazily loaded from a different node when 
+        not present locally.
+
+  -a, --topo_state_trasfer=[true|false]
+        Enabling topology information state transfer means that when a server
+        starts it retrieves this information from a different node.
+        Otherwise, if set to false, the topology information is lazily loaded
+        if not available locally.
+ 
+  -D<name>[=<value>]
+        Set a system property
+ 
+
+----
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-57-Interacting_With_Hot_Rod_Server_From_Within_Same_JVM.adoc b/documentation/src/main/asciidoc/user_guide/chapter-57-Interacting_With_Hot_Rod_Server_From_Within_Same_JVM.adoc
new file mode 100644
index 0000000..72891c2
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-57-Interacting_With_Hot_Rod_Server_From_Within_Same_JVM.adoc
@@ -0,0 +1,147 @@
+[[sid-68355104]]
+
+==  Interacting With Hot Rod Server From Within Same JVM
+
+[[sid-68355104_InteractingWithHotRodServerFromWithinSameJVM-Introduction]]
+
+
+=== Introduction
+
+ Normally, a link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737146$$[Hot Rod server] is accessed via a Hot Rod protocol client such as the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737142$$[Java Hot Rod client] . However, there might be situations where not only do you want to access the Hot Rod server remotely, you might also want to access it locally from within the same JVM that the Hot Rod server is running. For example, you might have an Infinispan cache pushing changes link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737163$$[via the RemoteCacheStore to a Hot Rod server] , and if the cache goes down, you might want to access the data directly from the Hot Rod server itself. 
+
+ In this situations, we have to remember that link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=9470083$$[the Hot Rod protocol] specifies that keys and values are stored as byte arrays. This means that if the client code, using an existing Hot Rod client, stored Strings or Integers, or any other complex serializable or externalizable object, you won't be able to retrieve these objects straight from the cache that the Hot Rod server uses. 
+
+ To actually get the fully constructed objects that you're after, you're gonna need to take the byte arrays stored within the Hot Rod server and unmarshall them into something that you can use. In the future, this is something that might be done for you, as suggested in link:$$https://jira.jboss.org/browse/ISPN-706$$[ISPN-706] (superseded by link:$$https://issues.jboss.org/browse/ISPN-2281$$[ISPN-2281] ), but for the time being, clients wanting to access Hot Rod server data will have to do it themselves. 
+
+Two different use cases need to be differentiated at this stage and to explain how to transform the Hot Rod server data into something usable, we'll assume that the clients are java clients:
+
+[[sid-68355104_InteractingWithHotRodServerFromWithinSameJVM-DataStoredDirectlyViaAHotRodClient]]
+
+
+=== Data Stored Directly Via A Hot Rod Client
+
+ The most common case is for a client to use a Hot Rod client library directly to store data in the Hot Rod server. In this case, assuming that the client used the existing link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737142$$[Java Hot Rod client] , the default marshaller used to marshall objects into byte arrays is the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/marshall/jboss/GenericJBossMarshaller.html$$[GenericJBossMarshaller] . So, if a user wants to read data from the Hot Rod server directly, it would need to execute something along the lines of: 
+
+
+----
+import org.infinispan.marshall.jboss.GenericJBossMarshaller;
+import org.infinispan.util.ByteArrayKey;
+import org.infinispan.server.core.CacheValue;
+...
+
+// Create a new instance of the marshaller:
+GenericJBossMarshaller marshaller = new GenericJBossMarshaller();
+Object key = ...
+
+// Take the cache key and convert into a byte array,
+// and wrap it with an instance of ByteArrayKey
+ByteArrayKey bytesKey = new ByteArrayKey(marshaller.objectToByteBuffer(key));
+
+// Internally, Hot Rod stores values wrapped in a CacheValue, so retrieve it
+CacheValue cacheValue = (CacheValue) cache.get(bytesKey);
+
+// Take the data part which is byte array and unmarshall it to retrieve the value
+Object value = marshaller.objectFromByteBuffer(cacheValue.data());
+
+----
+
+If you want to store data directly in the HotRod server, you'd have to execute something like this:
+
+
+----
+import org.infinispan.marshall.jboss.GenericJBossMarshaller;
+import org.infinispan.util.ByteArrayKey;
+import org.infinispan.server.core.CacheValue;
+...
+
+// Create a new instance of the marshaller:
+GenericJBossMarshaller marshaller = new GenericJBossMarshaller();
+Object key = ...
+Object value = ...
+
+// Take the cache key and convert into a byte array,
+// and wrap it with an instance of ByteArrayKey
+ByteArrayKey bytesKey = new ByteArrayKey(marshaller.objectToByteBuffer(key));
+
+// Internally, Hot Rod stores values wrapped in a CacheValue, so create instance
+// Remember that you need to give it a version number, so either:
+// 1. Increment previous value's version
+// 2. Or generate a new version number that minimises potential clash
+//    with a concurrent update to the same key in the cluster
+CacheValue cacheValue = new CacheValue(marshaller.objectToByteBuffer(value), 1)
+
+// Finally, store it in the cache
+cache.put(bytesKey, cacheValue);
+
+----
+
+[[sid-68355104_InteractingWithHotRodServerFromWithinSameJVM-DataStoredViaRemoteCacheStore]]
+
+
+=== Data Stored Via Remote Cache Store
+
+ Other times, Hot Rod server might be storing data coming from a link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737163$$[RemoteCacheStore] , rather than user code. In this case, there're a couple of differences to the code above. First of all, the marshaller is slightly different. Instead, the RemoteCacheStore uses the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/marshall/VersionAwareMarshaller.html$$[VersionAwareMarshaller] which all it does is add Infinispan version information to the byte array generated. The second difference is that RemoteCacheStore stores internal cache entry classes, which apart from the value part, they contain other extra information. So, any code trying to read these directly from the Hot Rod server would need to take in account. For example, to read data from such Hot Rod server: 
+
+
+----
+import org.infinispan.marshall.VersionAwareMarshaller;
+import org.infinispan.util.ByteArrayKey;
+import org.infinispan.server.core.CacheValue;
+import org.infinispan.container.entries.CacheEntry;
+...
+
+// Create a new instance of the marshaller
+VersionAwareMarshaller marshaller = new VersionAwareMarshaller();
+Object key = ...
+
+// Take the cache key and convert into a byte array,
+// and wrap it with an instance of ByteArrayKey
+ByteArrayKey bytesKey = new ByteArrayKey(marshaller.objectToByteBuffer(key));
+
+// Internally, Hot Rod stores values wrapped in a CacheValue, so retrieve it
+CacheValue cacheValue = (CacheValue) cache.get(bytesKey);
+
+// However, in this case the data part of CacheValue does not contain directly
+// the value Instead, it contains an instance of CacheEntry, so we need to
+// unmarshall that and then get the actual value
+CacheEntry cacheEntry = (CacheEntry)
+   marshaller.objectFromByteBuffer(cacheValue.data());
+Object value = cacheEntry.getValue();
+
+----
+
+And to actually write data back into the Hot Rod server directly:
+
+
+----
+import org.infinispan.marshall.VersionAwareMarshaller;
+import org.infinispan.util.ByteArrayKey;
+import org.infinispan.server.core.CacheValue;
+import org.infinispan.container.entries.CacheEntry;
+import org.infinispan.container.entries.InternalEntryFactory;
+...
+
+// Create a new instance of the marshaller:
+VersionAwareMarshaller marshaller = new VersionAwareMarshaller();
+Object key = ...
+Object value = ...
+
+// Take the cache key and convert into a byte array
+ByteArrayKey bytesKey = new ByteArrayKey(marshaller.objectToByteBuffer(key));
+
+// With the value to store, a new CacheEntry instance needs to be created:
+CacheEntry cacheEntry = InternalEntryFactory.create(bytesKey, value, ...)
+
+// Internally, Hot Rod stores values wrapped in a CacheValue, so create instance
+// Remember that you need to give it a version number, so either:
+// 1. Increment previous value's version
+// 2. Or generate a new version number that minimises potential clash
+//    with a concurrent update to the same key in the cluster
+CacheValue cacheValue = new CacheValue(
+   marshaller.objectToByteBuffer(cacheEntry), 1)
+
+// Finally, store it in the cache
+cache.put(bytesKey, cacheValue);
+
+----
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-58-Multiple_Tiers_of_Caches.adoc b/documentation/src/main/asciidoc/user_guide/chapter-58-Multiple_Tiers_of_Caches.adoc
new file mode 100644
index 0000000..d97e387
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-58-Multiple_Tiers_of_Caches.adoc
@@ -0,0 +1,48 @@
+[[sid-68355105]]
+
+==  Multiple Tiers of Caches
+
+[[sid-68355105_MultipleTiersofCaches-Introduction]]
+
+
+=== Introduction
+
+ The introduction of link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=9470083$$[HotRod] protocol and link:$$http://community.jboss.org/docs/DOC-14893?uniqueTitle=false#Remote_cache_loader$$[RemoteCacheLoader] opened the way for a set of new architectures in Infinispan, where layers of caches can exists and interact. This article takes a look at such an layered architecture. 
+
+[[sid-68355105_MultipleTiersofCaches-Buildingblocks]]
+
+
+=== Building blocks
+
+ link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=9470083$$[HotRod] is a binary protocol defined for exposing an Infinispan cluster as an caching server to multiple platforms. It has support for load balancing and smart routing. 
+
+ link:$$http://community.jboss.org/docs/DOC-14893?uniqueTitle=false#Remote_cache_loader$$[RemoteCacheLoader] is a cache loader that knows how to read/store data in a remote infinispan cluster. For that it makes use of the java hotrod client. 
+
+[[sid-68355105_MultipleTiersofCaches-Samplearchitecture%2Fnearcaching]]
+
+
+=== Sample architecture/near caching
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ The diagram above shows an Infinispan server cluster running 3 hotrod servers. This cluster is accessed remotely, through HotRod, by another infinispan cluster:  client cluster (upper part of the image). All the nodes in the server cluster are configured to run HotRod servers, so requests from remote loader are being balanced between them. The client cluster is configured with invalidation as cluster mode and a <<sid-68355053,RemoteCacheLoader>> to acess data stored in the server cluster. Application data is held on the server cluster which runs in DIST mode for scalability. 
+
+ In this deployment the client code, running in same address space with the client cluster,  holds all its data in the server cluster. Client cluster acts as an _near-cache_ for frequently accessed entries. 
+
+[[sid-68355105_MultipleTiersofCaches-Wanttoknowmore%3F]]
+
+
+=== Want to know more?
+
+ On the link:$$http://community.jboss.org/infinispan$$[documentation  main page] : 
+
+
+* cache loaders are described in the "Cache loaders" section
+
+
+* Hotrod's specification, server and client in the "Hot Rod" section
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-59-Infinispan_REST_Server.adoc b/documentation/src/main/asciidoc/user_guide/chapter-59-Infinispan_REST_Server.adoc
new file mode 100644
index 0000000..85ed74d
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-59-Infinispan_REST_Server.adoc
@@ -0,0 +1,275 @@
+[[sid-68355107]]
+
+==  Infinispan REST Server
+
+[[sid-68355107_InfinispanRESTServer-Introduction]]
+
+
+=== Introduction
+
+ This server provides easy to use link:$$http://en.wikipedia.org/wiki/Representational_State_Transfer$$[RESTful] HTTP access to the Infinispan data grid, build on RESTEasy.  This application is delivered (currently) as a war, which you can deploy to a servlet container (as many instances as you need). 
+
+[[sid-68355107_InfinispanRESTServer-Configuration]]
+
+
+=== Configuration
+
+Out of the box, Infinispan will create and use a new LOCAL mode cache. To set a custom configuration:
+
+
+.  Unzip the REST WAR file (or use an link:$$http://community.jboss.org/docs/DOC-9719$$[exploded] deployment) 
+
+
+.  Create an Infinispan link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737143$$[configuration XML file] and name this infinispan.xml 
+
+
+.  Place this file in infinispan-server-rest.war/WEB-INF/classes 
+
+Alternatively, you could:
+
+
+.  Unzip the REST WAR file (or use an link:$$http://community.jboss.org/docs/DOC-9719$$[exploded] deployment) 
+
+
+.  Create an Infinispan link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737143$$[configuration XML file] , call it whatever you want and place it wherever you want 
+
+
+.  Edit infinispan-server-rest.war/WEB-INF/web.xml and look for the infinispan.config init-param. Change the value of this init-param to the full path to your Infinispan configuration. 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ Please note that the REST server only allows interaction with either the default cache (named ___defaultcache ) or one of the named caches in the configuration file. This is because the REST server starts the default and pre-defined caches on startup in order to provide consistent behaivor. 
+
+
+[WARNING]
+.Warning
+==== 
+Creation of new named caches on the fly is not supported.
+
+
+==== 
+
+
+As a result, if you don't use a custom configuration file, you'll only be able to interact with the default cache. To interact with more caches, use a configuration file with the desired named caches.
+
+[[sid-68355107_InfinispanRESTServer-AccessingDataviaURLs]]
+
+
+=== Accessing Data - via URLs
+
+ HTTP PUT and POST methods are used to place data in the cache, with URLs to address the cache name and key(s) - the data being the body of the request (the data can be anything you like). It is important that a Content-Type header is set. GET/HEAD are used to retrieve data link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737132$$[Please see here for the details] . Other headers are used to control the cache settings and behaviour (detailed in that link). 
+
+[[sid-68355107_InfinispanRESTServer-Clientsidecode]]
+
+
+=== Client side code
+
+Part of the point of a RESTful service is that you don't need to have tightly coupled client libraries/bindings. All you need is a HTTP client library. For Java, Apache HTTP Commons Client works just fine (and is used in the integration tests), or you can use java.net API.
+
+[[sid-68355107_InfinispanRESTServer-Rubyclientcode%3A]]
+
+
+==== Ruby client code:
+
+
+----
+# Shows how to interact with Infinispan REST api from ruby.
+# No special libraries, just standard net/http
+#
+# Author: Michael Neale
+#
+require 'net/http'
+
+http = Net::HTTP.new('localhost', 8080)
+
+#Create new entry
+http.post('/infinispan/rest/MyData/MyKey', 'DATA HERE', {"Content-Type" => "text/plain"})
+
+#get it back
+puts http.get('/infinispan/rest/MyData/MyKey').body
+
+#use PUT to overwrite
+http.put('/infinispan/rest/MyData/MyKey', 'MORE DATA', {"Content-Type" => "text/plain"})
+
+#and remove...
+http.delete('/infinispan/rest/MyData/MyKey')
+
+#Create binary data like this... just the same...
+http.put('/infinispan/rest/MyImages/Image.png', File.read('/Users/michaelneale/logo.png'), {"Content-Type" => "image/png"})
+
+
+#and if you want to do json...
+require 'rubygems'
+require 'json'
+
+#now for fun, lets do some JSON !
+data = {:name => "michael", :age => 42 }
+http.put('/infinispan/rest/Users/data/0', data.to_json, {"Content-Type" => "application/json"})
+
+----
+
+[[sid-68355107_InfinispanRESTServer-Pythonclientcode%3A]]
+
+
+==== Python client code:
+
+
+----
+
+# Sample python code using the standard http lib only
+#
+
+import httplib
+
+
+#putting data in
+conn = httplib.HTTPConnection("localhost:8080")
+data = "SOME DATA HERE \!" #could be string, or a file...
+conn.request("POST", "/infinispan/rest/Bucket/0", data, {"Content-Type": "text/plain"})
+response = conn.getresponse()
+print response.status
+
+#getting data out
+import httplib
+conn = httplib.HTTPConnection("localhost:8080")
+conn.request("GET", "/infinispan/rest/Bucket/0")
+response = conn.getresponse()
+print response.status
+print response.read()
+
+----
+
+[[sid-68355107_InfinispanRESTServer-Javaclientcode%3A]]
+
+
+==== Java client code:
+
+
+[listing]
+....
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.net.HttpURLConnection;
+import java.net.URL;
+
+/**
+ * Rest example accessing Infinispan Cache.
+ * @author Samuel Tauil (samuel@redhat.com)
+ *
+ */
+public class RestExample {
+
+   /**
+    * Method that puts a String value in cache.
+    * @param urlServerAddress
+    * @param value
+    * @throws IOException
+    */
+   public void putMethod(String urlServerAddress, String value) throws IOException {
+      System.out.println("----------------------------------------");
+      System.out.println("Executing PUT");
+      System.out.println("----------------------------------------");
+      URL address = new URL(urlServerAddress);
+      System.out.println("executing request " + urlServerAddress);
+      HttpURLConnection connection = (HttpURLConnection) address.openConnection();
+      System.out.println("Executing put method of value: " + value);
+      connection.setRequestMethod("PUT");
+      connection.setRequestProperty("Content-Type", "text/plain");
+      connection.setDoOutput(true);
+
+      OutputStreamWriter outputStreamWriter = new OutputStreamWriter(connection.getOutputStream());
+      outputStreamWriter.write(value);
+         
+      connection.connect();
+      outputStreamWriter.flush();
+       
+      System.out.println("----------------------------------------");
+      System.out.println(connection.getResponseCode() + " " + connection.getResponseMessage());
+      System.out.println("----------------------------------------");
+         
+      connection.disconnect();
+   }
+
+   /**
+    * Method that gets an value by a key in url as param value.
+    * @param urlServerAddress
+    * @return String value
+    * @throws IOException
+    */
+   public String getMethod(String urlServerAddress) throws IOException {
+      String line = new String();
+      StringBuilder stringBuilder = new StringBuilder();
+
+      System.out.println("----------------------------------------");
+      System.out.println("Executing GET");
+      System.out.println("----------------------------------------");
+
+      URL address = new URL(urlServerAddress);
+      System.out.println("executing request " + urlServerAddress);
+
+      HttpURLConnection connection = (HttpURLConnection) address.openConnection();
+      connection.setRequestMethod("GET");
+      connection.setRequestProperty("Content-Type", "text/plain");
+      connection.setDoOutput(true);
+
+      BufferedReader&nbsp; bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+
+      connection.connect();
+
+      while ((line = bufferedReader.readLine()) \!= null) {
+         stringBuilder.append(line + '\n');
+      }
+
+      System.out.println("Executing get method of value: " + stringBuilder.toString());
+
+      System.out.println("----------------------------------------");
+      System.out.println(connection.getResponseCode() + " " + connection.getResponseMessage());
+      System.out.println("----------------------------------------");
+
+      connection.disconnect();
+
+      return stringBuilder.toString();
+   }
+
+   /**
+    * Main method example.
+    * @param args
+    * @throws IOException
+    */
+   public static void main(String\[\] args) throws IOException {
+      //Attention to the cache name "cacheX" it was configured in xml file with tag <namedCache name="cacheX">
+      RestExample restExample = new RestExample();
+      restExample.putMethod("http://localhost:8080/infinispan/rest/cacheX/1", "Infinispan REST Test");
+      restExample.getMethod("http://localhost:8080/infinispan/rest/cacheX/1");         
+   }
+}
+
+....
+
+[[sid-68355107_InfinispanRESTServer-Future%3A]]
+
+
+=== Future:
+
+
+* Sample persistence options to make this a long term data grid
+
+
+* Query and indexing (of known MIME types, and JSON, XML etc)
+
+
+* Returning both lists of buckets + entries as &lt;link&gt; relations (where it makes sense)
+
+
+* Monitoring of stats via Web interface
+
+
+* (optional: WADL?)
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-6-Querying_Infinispan.adoc b/documentation/src/main/asciidoc/user_guide/chapter-6-Querying_Infinispan.adoc
new file mode 100644
index 0000000..453fbc4
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-6-Querying_Infinispan.adoc
@@ -0,0 +1,358 @@
+[[sid-68355029]]
+
+==  Querying Infinispan
+
+[[sid-68355029_QueryingInfinispan-Theinfinispanquerymodule]]
+
+
+=== The infinispan-query module
+
+ This module adds querying capabilities to Infinispan. It uses link:$$http://hibernate.org/subprojects/search$$[Hibernate Search] and link:$$http://lucene.apache.org/$$[Apache Lucene] to index and search objects in the cache. It allows users to obtain objects within the cache without needing to know the keys to each object that they want to obtain, so you can search your objects basing on some of it's properties, for example to retrieve all red cars (exact metadata match), or all books about a specific topic (full text search and relevance scoring). 
+
+[[sid-68355029_QueryingInfinispan-Configuration]]
+
+
+==== Configuration
+
+ Indexing must be enabled in the configuration (as explained in <<sid-68355029,XML Configuration>> or <<sid-68355029,Programmatic configuration>> ). This will trigger automatic indexing of objects stored in the cache; there are several different ways to specify how these objects need to be indexed explained in the following paragraphs. To run queries you use the _SearchManager_ which exposes all necessary methods to get started. 
+
+[[sid-68355029_QueryingInfinispan-Simpleexample]]
+
+
+=== Simple example
+
+ We're going to store _Book_ instances in Infinispan; each _Book_ will be defined as in the following example; we have to choose which properties are indexed, and for each property we can optionally choose advanced indexing options using the annotations defined in the Hibernate Search project. 
+
+
+----
+// example values stored in the cache and indexed:
+import org.hibernate.search.annotations.*;
+
+//Values you want to index need to be annotated with @Indexed, then you pick which fields and how they are to be indexed:
+@Indexed
+public class Book {
+   @Field String title;
+   @Field String description;
+   @Field @DateBridge(resolution=Resolution.YEAR) Date publicationYear;
+   @IndexedEmbedded Set<Author> authors = new HashSet<Author>();
+}
+
+public class Author {
+   @Field String name;
+   @Field String surname;
+   // hashCode() and equals() omitted
+}
+
+----
+
+ Now assuming we stored several _Book_ instances in our Infinispan _Cache_ , we can search them for any matching field as in the following example. 
+
+
+----
+// get the search manager from the cache:
+SearchManager searchManager = org.infinispan.query.Search.getSearchManager(cache);
+
+// create any standard Lucene query, via Lucene's QueryParser or any other means:
+org.apache.lucene.search.Query fullTextQuery = //any Apache Lucene Query
+
+// convert the Lucene query to a CacheQuery:
+CacheQuery cacheQuery = searchManager.getQuery( fullTextQuery );
+
+// get the results:
+List<Object> found = cacheQuery.list();
+
+
+----
+
+ A Lucene Query is often created by parsing a query in text format such as "title:infinispan AND authors.name:sanne", or by using the query builder provided by Hibernate Search. 
+
+
+----
+// get the search manager from the cache:
+SearchManager searchManager = org.infinispan.query.Search.getSearchManager( cache );
+
+// you could make the queries via Lucene APIs, or use some helpers:
+QueryBuilder queryBuilder = searchManager.buildQueryBuilderForClass(Book.class).get();
+
+// the queryBuilder has a nice fluent API which guides you through all options.
+// this has some knowledge about your object, for example which Analyzers
+// need to be applied, but the output is a failry standard Lucene Query.
+org.apache.lucene.search.Query luceneQuery = queryBuilder.phrase()
+                  .onField("description")
+                  .andField("title")
+                  .sentence("a book on highly scalable query engines")
+                  .createQuery();
+
+// the query API itself accepts any Lucene Query, and on top of that
+// you can restrict the result to selected class types:
+CacheQuery query = searchManager.getQuery(luceneQuery, Book.class);
+
+// and there are your results!
+List objectList = query.list();
+
+for (Object book : objectList) {
+      System.out.println(book);
+}
+
+----
+
+ A part from _list()_ you have the option for streaming results, or use pagination. 
+
+ This barely scratches the surface of all what is possible to do: see the link:$$http://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single$$[Hibernate Search reference documentation] to learn about sorting, numeric fields, declarative filters, caching filters, complex object graph indexing, custom types and the powerful faceting search API. 
+
+[[sid-68355029_QueryingInfinispan-NotabledifferenceswithHibernateSearch]]
+
+
+==== Notable differences with Hibernate Search
+
+ Using _@DocumentId_ to mark a field as identifier does not apply to Infinispan values; in Infinispan Query the identifier for all _@Indexed_ objects is the key used to store the value. You can still customize how the key is indexed using a combination of _@Transformable_ , _@ProvidedId_ , custom types and custom _FieldBridge_ implementations. 
+
+[[sid-68355029_QueryingInfinispan-RequirementsfortheKey%3A@Transformableand@ProvidedId]]
+
+
+==== Requirements for the Key: @Transformable and @ProvidedId
+
+ The key for each value needs to be indexed as well, and the key instance must be transformed in a String. Infinispan includes some default transformation routines to encode common primitivies, but to use a custom key you must provide an implementation of _org.infinispan.query.Transformer_ . 
+
+[[sid-68355029_QueryingInfinispan-RegisteringaTransformerviaannotations]]
+
+
+===== Registering a Transformer via annotations
+
+ You can annotate your key type with _org.infinispan.query.Transformable_ : 
+
+
+----
+
+@Transformable(transformer = CustomTransformer.class)
+public class CustomKey {
+   ...
+}
+
+public class CustomTransformer implements Transformer {
+   @Override
+   public Object fromString(String s) {
+      ...
+      return new CustomKey(...);
+   }
+
+   @Override
+   public String toString(Object customType) {
+      CustomKey ck = (CustomKey) customType;
+      return ...
+   }
+}
+
+----
+
+[[sid-68355029_QueryingInfinispan-RegisteringaTransformerprogrammatically]]
+
+
+===== Registering a Transformer programmatically
+
+Using this technique, you don't have to annotated your custom key type:
+
+
+----
+org.infinispan.query.SearchManager.registerKeyTransformer(Class<?>, Class<? extends Transformer>)
+----
+
+[[sid-68355029_QueryingInfinispan-@ProvidedId]]
+
+
+===== @ProvidedId
+
+ The _org.hibernate.search.annotations.ProvidedId_ annotation lets you apply advanced indexing options to the key field: the field name to be used, and/or specify a custom _FieldBridge_ . 
+
+[[sid-68355029_QueryingInfinispan-Configurationx]]
+
+
+=== Configuration
+
+[[sid-68355029_QueryingInfinispan-ConfigurationviaXML]]
+
+
+==== Configuration via XML
+
+ To enable indexing via XML, you need to add the &lt;indexing ... /&gt; element to your cache configuration, and optionally pass additional properties to the embedded Hibernate Search engine: 
+
+
+----
+<?xml version="1.0" encoding="UTF-8"?>
+<infinispan
+      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+      xsi:schemaLocation="urn:infinispan:config:5.2 http://www.infinispan.org/schemas/infinispan-config-5.2.xsd"
+      xmlns="urn:infinispan:config:5.2">
+   <default>
+      <indexing enabled="true" indexLocalOnly="true">
+         <properties>
+            <property name="default.directory_provider" value="ram" />
+         </properties>
+      </indexing>
+   </default>
+</infinispan>
+
+----
+
+ In this example the index is stored in memory, so when this nodes is shutdown the index is lost: good for a quick demo, but in real world cases you'll want to use the default (store on filesystem) or store the index in Infinispan as well. For the complete reference of properties to define, refer to the link:$$http://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/#search-configuration$$[Hibernate Search documentation] . 
+
+[[sid-68355029_QueryingInfinispan-LuceneDirectory]]
+
+
+==== Lucene Directory
+
+ Infinispan Query isn't aware of where you store the indexes, it just passes the configuration of which _Lucene Directory_ implementation you want to use to the Hibernate Search engine. There are several _Lucene Directory_ implementations bundled, and you can plug your own or add third party implementations: the Directory is the IO API for Lucene to store the indexes. 
+
+ The most common _Lucene Directory_ implementations used with _Infinispan Query_ are: 
+
+
+* Ram - stores the index in a local map to the node. This index can't be shared.
+
+
+* Filesystem - stores the index in a locally mounted filesystem. This could be a network shared FS, but sharing this way is generally not recommended.
+
+
+*  Infinispan - stores the index in a different dedicated Infinispan cache. This cache can be configured as replicated or distributed, to share the index among nodes. See also <<sid-68355039>> . 
+
+Of course having a shared index vs. an independent index on each node directly affects behaviour of the Query module; some combinations might not make much sense.
+
+[[sid-68355029_QueryingInfinispan-Usingprogrammaticconfigurationandindexmapping]]
+
+
+==== Using programmatic configuration and index mapping
+
+ In the following example we start Infinispan programmatically, avoiding XML configuration files, and also map an object _Author_ which is to be stored in the grid and made searchable on two properties but without annotating the class. 
+
+
+----
+
+SearchMapping mapping = new SearchMapping();
+mapping.entity(Author.class).indexed().providedId()
+      .property("name", ElementType.METHOD).field()
+      .property("surname", ElementType.METHOD).field();
+
+Properties properties = new Properties();
+properties.put(org.hibernate.search.Environment.MODEL_MAPPING, mapping);
+properties.put("hibernate.search.[other options]", "[...]");
+
+Configuration infinispanConfiguration = new ConfigurationBuilder()
+      .indexing()
+         .enable()
+         .indexLocalOnly(true)
+         .withProperties(properties)
+      .build();
+
+DefaultCacheManager cacheManager = new DefaultCacheManager(infinispanConfiguration);
+
+Cache<Long, Author> cache = cacheManager.getCache();
+SearchManager sm = Search.getSearchManager(cache);
+
+Author author = new Author(1, "Manik", "Surtani");
+cache.put(author.getId(), author);
+
+QueryBuilder qb = sm.buildQueryBuilderForClass(Author.class).get();
+Query q = qb.keyword().onField("name").matching("Manik").createQuery();
+CacheQuery cq = sm.getQuery(q, Author.class);
+Assert.assertEquals(cq.getResultSize(), 1);
+
+----
+
+[[sid-68355029_QueryingInfinispan-Cachemodesandmanagingindexes]]
+
+
+=== Cache modes and managing indexes
+
+ Index management is currently controlled by the _Configuration.setIndexLocalOnly()_ setter, or the &lt;indexing indexLocalOnly="true" /&gt; XML element. If you set this to true, only modifications made locally on each node are considered in indexing. Otherwise, remote changes are considered too. 
+
+ Regarding actually configuring a Lucene directory, refer to the link:$$http://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/#search-configuration$$[Hibernate Search documentation] on how to pass in the appropriate Lucene configuration via the Properties object passed to QueryHelper. 
+
+[[sid-68355029_QueryingInfinispan-LOCAL]]
+
+
+==== LOCAL
+
+ In local mode, you may use any Lucene Directory implementation. Also the option _indexLocalOnly_ isn't meaningful. 
+
+[[sid-68355029_QueryingInfinispan-REPLICATION]]
+
+
+==== REPLICATION
+
+ In replication mode, each node can have it's own local copy of the index. So indexes can either be stored locally on each node (RAMDirectory, FSDirectory, etc) but you need to set _indexLocalOnly_ to _false_ , so that each node will apply needed updates it receives from other nodes in addition to the updates started locally. Any Directory implementation can be used, but you have to make sure that when a new node is started it receives an up to date copy of the index; typically rsync is well suited for this task, but being an external operation you might end up with a slightly out-of-sync index, especially if updates are very frequent. 
+
+ Alternately, if you use some form of shared storage for indexes (see _Sharing the Index_ ), you then have to set _indexLocalOnly_ to _true_ so that each node will apply only the changes originated locally; in this case there's no risk in having an out-of-sync index, but to avoid write contention on the index you should make sure that a single node is "in charge" of updating the index. Again, the Hibernate Search reference documentation describes means to use link:$$http://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/#jms-backend$$[a JMS queue] or link:$$http://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/#jgroups-backend$$[JGroups] to send indexing tasks to a master node. 
+
+The diagram below shows a replicated deployment, in which each node has a local index.
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+[[sid-68355029_QueryingInfinispan-DISTRIBUTION]]
+
+
+==== DISTRIBUTION
+
+ For these 2 cache modes, you _need_ to use a shared index and set _indexLocalOnly_ to true. 
+
+The diagram below shows a deployment with a shared index. Note that while not mandatory, a shared index can be used for replicated (vs. distributed) caches as well.
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+[[sid-68355029_QueryingInfinispan-INVALIDATION]]
+
+
+==== INVALIDATION
+
+Indexing or searching of elements under INVALIDATION mode is not supported.
+
+[[sid-68355029_QueryingInfinispan-SharingtheIndex]]
+
+
+=== Sharing the Index
+
+ The most simple way to share an index is to use some form of shared storage for the indexes, like an _FSDirectory_ on a shared disk; however this form is problematic as the _FSDirectory_ relies on specific locking semantics which are often incompletely implemented on network filesystems, or not reliable enough; if you go for this approach make sure to search for potential problems on the Lucene mailing lists for other experiences and workarounds. Good luck, test well. 
+
+ There are many alternative Directory implementations you can find, one of the most suited approaches when working with Infinispan is of course to store the index in an Infinispan cache: have a look at the <<sid-68355039,InfinispanDirectoryProvider>> , as all Infinispan based layers it can be combined with persistent CacheLoaders to keep the index on a shared filesystem without the locking issues, or alternatively in a database, cloud storage, or any other CacheLoader implementation; you could backup the index in the same store used to backup your values. 
+
+ For full documentation on clustering the Lucene engine, refer to the link:$$http://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/#search-configuration$$[Hibernate Search documentation] to properly configure it clustered. 
+
+[[sid-68355029_QueryingInfinispan-ClusteringtheIndexinInfinispan]]
+
+
+=== Clustering the Index in Infinispan
+
+ Again the configuration details are in the Hibernate Search reference, in particular in the link:$$http://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/#infinispan-directories$$[infinispan-directories] section. This backend will by default start a secondary Infinispan CacheManager, and optionally take another Infinispan configuration file: don't reuse the same configuration or you will start grids recursively! It is currently not possible to share the same CacheManager. 
+
+[[sid-68355029_QueryingInfinispan-RebuildingtheIndex]]
+
+
+=== Rebuilding the Index
+
+ Occasionally you might need to rebuild the Lucene index by reconstructing it from the data stored in the Cache. You need to rebuild the index if you change the definition of what is indexed on your types, or if you change for example some _Analyzer_ parameter, as Analyzers affect how the index is defined. Also, you might need to rebuild the index if you had it destroyed by some system administration mistake. To rebuild the index just get a reference to the MassIndexer and start it; beware if might take some time as it needs to reprocess all data in the grid! 
+
+
+----
+
+SearchManager searchManager = Search.getSearchManager(cache);
+searchManager.getMassIndexer().start();
+
+----
+
+This is also available as a JMX operation.
+
+
+[WARNING]
+==== 
+There is currently one limitation: the MassIndexer is implemented using Map/Reduce, which in Infinispan 5.2 requires the underlying caches to use distribution. In other words, the MassIndexer isn't currently functional in LOCAL and REPL cache modes.
+
+
+==== 
+
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-60-CDI_Support.adoc b/documentation/src/main/asciidoc/user_guide/chapter-60-CDI_Support.adoc
new file mode 100644
index 0000000..2ab3613
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-60-CDI_Support.adoc
@@ -0,0 +1,444 @@
+[[sid-68355108]]
+
+==  CDI Support
+
+[[sid-68355108_CDISupport-Introduction]]
+
+
+=== Introduction
+
+ Infinispan includes integration with CDI in the infinispan-cdi module. Configuration and injection of the Inifispan's Cache API is provided, and it is planned to bridge Cache listeners to the CDI event system. The module also provide partial support of the JCache (JSR-107) caching annotations - for further details see link:$$https://docs.google.com/document/d/1YZ-lrH6nW871Vd9Z34Og_EqbX_kxxJi55UrSn4yL2Ak/edit?hl=en&amp;pli=1#heading=h.jdfazu3s6oly$$[Chapter 8] of the JCACHE specification. 
+
+[[sid-68355108_CDISupport-MavenDependencies]]
+
+
+=== Maven Dependencies
+
+ All you need is org.infinispan:infinispan-cdi 
+
+
+----
+
+<dependency>
+    <groupId>org.infinispan</groupId>
+    <artifactId>infinispan-cdi</artifactId>
+    <version>${infinispan.version}</version>
+</dependency>
+
+----
+
+
+[TIP]
+.Which version of Infinispan should I use?
+==== 
+ We recommend using the latest final version of the infinispan-cdi module. This module is available since Infinispan version 5.0.0.CR8 . 
+
+
+==== 
+
+
+[[sid-68355108_CDISupport-Embeddedcacheintegration]]
+
+
+=== Embedded cache integration
+
+[[sid-68355108_CDISupport-Injectanembeddedcache]]
+
+
+==== Inject an embedded cache
+
+By default you can inject the default Infinispan cache. Let's look at the following example:
+
+
+----
+
+...
+import javax.inject.Inject;
+
+public class GreetingService {
+    @Inject
+    private Cache<String, String> cache;
+
+    public String greet(String user) {
+        String cachedValue = cache.get(user);
+        if (cachedValue == null) {
+            cachedValue = "Hello " + user;
+            cache.put(user, cachedValue);
+        }
+        return cachedValue;
+    }
+}
+
+----
+
+ If you want to use a specific cache you just have to provide your own cache configuration and cache qualifier. For example, if you want to use a custom cache for the GreetingService you should write your own qualifier (here GreetingCache ) and define its configuration: 
+
+
+[NOTE]
+.The new configuration system is used since 5.1.0.CR2
+==== 
+ As you probably know Infinispan 5.1.0 comes with a new way to configure your cache programmatically and a bit more (more information are available link:$$http://infinispan.blogspot.com/2012/01/configuration-changes-in-infinispan.html$$[here] ). Now to configure a cache you must use this new configuration system. 
+
+
+==== 
+
+
+
+----
+
+...
+import javax.inject.Qualifier;
+
+@Qualifier
+@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD})
+@Retention(RetentionPolicy.RUNTIME)
+@Documented
+public @interface GreetingCache {
+}
+
+----
+
+
+----
+
+...
+import org.infinispan.configuration.cache.Configuration;
+import org.infinispan.configuration.cache.ConfigurationBuilder;
+import org.infinispan.cdi.ConfigureCache;
+import javax.enterprise.inject.Produces;
+
+public class Config {
+    @ConfigureCache("greeting-cache") // This is the cache name.
+    @GreetingCache // This is the cache qualifier.
+    @Produces
+    public Configuration greetingCacheConfiguration() {
+        return new ConfigurationBuilder()
+                    .eviction()
+                        .strategy(EvictionStrategy.LRU)
+                        .maxEntries(1000)
+                    .build();
+    }
+
+    // The same example without providing a custom configuration.
+    // In this case the default cache configuration will be used.
+    @ConfigureCache("greeting-cache")
+    @GreetingCache
+    @Produces
+    public Configuration greetingCacheConfiguration;
+}
+
+----
+
+ To use this cache in the GreetingService add the @GeetingCache qualifier on your cache injection point. Simple! 
+
+[[sid-68355108_CDISupport-Overridethedefaultembeddedcachemanagerandconfiguration]]
+
+
+==== Override the default embedded cache manager and configuration
+
+
+[NOTE]
+.Since 5.1.0.CR1 @OverrideDefault is deprecated
+==== 
+To migrate your code remove this annotation from your producers as detailed in the following section.
+
+
+==== 
+
+
+ You can override the default cache configuration used by the default embedded cache manager. For that, you just have to create one Configuration producer with the @Default qualifier as illustrated in the following snippet: 
+
+
+----
+
+public class Config {
+    // By default CDI adds the @Default qualifier if no other qualifier is provided.
+    @Produces
+    public Configuration defaultEmbeddedCacheConfiguration() {
+        return new ConfigurationBuilder()
+                    .eviction()
+                        .strategy(EvictionStrategy.LRU)
+                        .maxEntries(100)
+                    .build();
+    }
+}
+
+----
+
+ It's also possible to override the default embedded cache manager used. The new default cache manager produced must have the @Default qualifier and the scope @ApplicationScoped . 
+
+
+----
+
+...
+import javax.enterprise.context.ApplicationScoped;
+
+public class Config {
+    @Produces
+    @ApplicationScoped
+    public EmbeddedCacheManager defaultEmbeddedCacheManager() {
+      return new DefaultCacheManager(new ConfigurationBuilder()
+                                          .eviction()
+                                              .strategy(EvictionStrategy.LRU)
+                                              .maxEntries(100)
+                                          .build());
+   }
+}
+
+----
+
+[[sid-68355108_CDISupport-Configurethetransportforclustereduse]]
+
+
+==== Configure the transport for clustered use
+
+ To use Infinispan in a clustered mode you have to configure the transport with the GlobalConfiguration . To achieve that override the default cache manager as explained in the previous section. Look at the following snippet: 
+
+
+----
+
+...
+package org.infinispan.configuration.global.GlobalConfigurationBuilder;
+
+@Produces
+@ApplicationScoped
+public EmbeddedCacheManager defaultClusteredCacheManager() {
+    return new DefaultCacheManager(
+        new GlobalConfigurationBuilder().transport().defaultTransport().build(),
+        new ConfigurationBuilder().eviction().maxEntries(7).build()
+    );
+}
+
+----
+
+[[sid-68355108_CDISupport-Remotecacheintegration]]
+
+
+=== Remote cache integration
+
+[[sid-68355108_CDISupport-Injectaremotecache]]
+
+
+==== Inject a remote cache
+
+ With the CDI integration it's also possible to use a remote cache. For example you can inject the default RemoteCache as illustrated in the following snippet: 
+
+
+----
+
+public class GreetingService {
+    @Inject
+    private RemoteCache<String, String> cache;
+
+    public String greet(String user) {
+        String cachedValue = cache.get(user);
+        if (cachedValue == null) {
+            cachedValue = "Hello " + user;
+            cache.put(user, cachedValue);
+        }
+        return cachedValue;
+    }
+}
+
+----
+
+ If you want to use another cache, for example the greeting-cache, add the @Remote qualifier on the cache injection point which contains the cache name. 
+
+
+----
+
+public class GreetingService {
+    @Inject @Remote("greeting-cache")
+    private RemoteCache<String, String> cache;
+
+    ...
+}
+
+----
+
+ Adding the @Remote cache qualifier on each injection point might be error prone. That's why the remote cache integration provides another way to achieve the same goal. For that you have to create your own qualifier annotated with @Remote : 
+
+
+----
+
+@Remote("greeting-cache")
+@Qualifier
+@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD})
+@Retention(RetentionPolicy.RUNTIME)
+@Documented
+public @interface RemoteGreetingCache {
+}
+
+----
+
+ To use this cache in the GreetingService add the qualifier @RemoteGreetingCache qualifier on your cache injection. 
+
+[[sid-68355108_CDISupport-Overridethedefaultremotecachemanager]]
+
+
+==== Override the default remote cache manager
+
+Like the embedded cache integration, the remote cache integration comes with a default remote cache manager producer. This default remote cache manager can be overridden as illustrated in the following snippet:
+
+
+----
+
+public class Config {
+    @Produces
+    @ApplicationScoped
+    public RemoteCacheManager defaultRemoteCacheManager() {
+        return new RemoteCacheManager(localhost, 1544);
+    }
+}
+
+----
+
+[[sid-68355108_CDISupport-Useacustomremote%2Fembeddedcachemanagerforoneormorecache]]
+
+
+=== Use a custom remote/embedded cache manager for one or more cache
+
+It's possible to use a custom cache manager for one or more cache. You just need to annotate the cache manager producer with the cache qualifiers. Look at the following example:
+
+
+----
+
+public class Config {
+   @GreetingCache
+   @Produces
+   @ApplicationScoped
+   public EmbeddedCacheManager specificEmbeddedCacheManager() {
+      return new DefaultCacheManager(new ConfigurationBuilder()
+                                          .expiration()
+                                              .lifespan(60000l)
+                                          .build());
+   }
+
+   @RemoteGreetingCache
+   @Produces
+   @ApplicationScoped
+   public RemoteCacheManager specificRemoteCacheManager() {
+       return new RemoteCacheManager("localhost", 1544);
+   }
+}
+
+----
+
+ With the above code the GreetingCache or the RemoteGreetingCache will be associated with the produced cache manager. 
+
+
+[NOTE]
+.Producer method scope
+==== 
+ To work properly the producers must have the scope @ApplicationScoped . Otherwise each injection of cache will be associated to a new instance of cache manager. 
+
+
+==== 
+
+
+[[sid-68355108_CDISupport-UseaJBossAS7configuredcache]]
+
+
+=== Use a JBoss AS 7 configured cache
+
+ With JBoss AS 7, you can setup an Infinispan cache manager in the server configuration file. This allows you to externalize your Infinispan configuration and also to lookup the cache manager from JNDI, normally with the @Resource annotation. 
+
+As we mentioned earlier, you can override the default cache manager used by the Infinispan CDI extension. To use a JBoss AS 7 configured cache, you need to use the cache manager defined in JBoss AS 7. You only need to annotate the default cache manager producer with @Resource. The following example shows how use an embedded cache manager configured in JBoss AS 7.
+
+
+----
+
+...
+import javax.annotation.Resource;
+
+public class Config {
+    @Produces
+    @ApplicationScoped
+    @Resource(lookup="java:jboss/infinispan/my-container-name")
+    private EmbeddedCacheManager defaultCacheManager;
+}
+
+----
+
+[[sid-68355108_CDISupport-UseJCachecachingannotations]]
+
+
+=== Use JCache caching annotations
+
+ The infinispan-cdi module provides a partial support of JCache caching annotations. These annotations provide a simple way to handle common use cases. The following caching annotations are defined in this specification: 
+
+
+*  @CacheResult caches the result of a method call 
+
+
+*  @CachePut caches a method parameter 
+
+
+*  @CacheRemoveEntry removes an entry from a cache 
+
+
+*  @CacheRemoveAll removes all entries from a cache 
+
+
+[NOTE]
+.Annotations target type
+==== 
+These annotations must only be used on methods.
+
+
+==== 
+
+
+ To use these annotations the following interceptors must be declared in your application beans.xml . 
+
+
+----
+
+<beans xmlns="http://java.sun.com/xml/ns/javaee"
+       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+       xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/beans_1_0.xsd">
+    <interceptors>
+        <class>org.infinispan.cdi.interceptor.CacheResultInterceptor</class>
+        <class>org.infinispan.cdi.interceptor.CachePutInterceptor</class>
+        <class>org.infinispan.cdi.interceptor.CacheRemoveEntryInterceptor</class>
+        <class>org.infinispan.cdi.interceptor.CacheRemoveAllInterceptor</class>
+    </interceptors>
+</beans>
+
+----
+
+ The following snippet of code illustrates the use of @CacheResult annotation. As you can see it simplifies the caching of the Greetingservice#greet method results. 
+
+
+----
+
+import javax.cache.interceptor.CacheResult;
+
+public class GreetingService {
+    @CacheResult
+    public String greet(String user) {
+        return "Hello" + user;
+    }
+}
+
+----
+
+ The first version of the GreetingService and the above version have exactly the same behavior. The only difference is the cache used. By default it's the fully qualified name of the annotated method with its parameter types (e.g. org.infinispan.example.GreetingService.greet(java.lang.String) ). 
+
+
+[TIP]
+.Can I use a different cache?
+==== 
+ To use another cache specify its name with the cacheName attribute of the cache annotation. For example: 
+
+
+----
+
+@CacheResult(cacheName = "greeting-cache")
+
+----
+
+
+==== 
+
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-61-Marshalling.adoc b/documentation/src/main/asciidoc/user_guide/chapter-61-Marshalling.adoc
index 54b6fcd..70ef1ff 100644
--- a/documentation/src/main/asciidoc/user_guide/chapter-61-Marshalling.adoc
+++ b/documentation/src/main/asciidoc/user_guide/chapter-61-Marshalling.adoc
@@ -1,8 +1,8 @@
-[[sid-8093979]]
+[[sid-68355106]]
 
 ==  Marshalling
 
-[[sid-8093979_Marshalling-Introduction]]
+[[sid-68355106_Marshalling-Introduction]]
 
 
 === Introduction
@@ -18,14 +18,14 @@ Marshalling is the process of converting Java POJOs into something that can be w
 
 * Store data in Infinispan in a wire format to provide lazy deserialization capabilities.
 
-[[sid-8093979_Marshalling-TheRoleOfJBossMarshalling]]
+[[sid-68355106_Marshalling-TheRoleOfJBossMarshalling]]
 
 
 === The Role Of JBoss Marshalling
 
 Since performance is a very important factor in this process, Infinispan uses JBoss Marshalling framework instead of standard Java Serialization in order to marshall/unmarshall Java POJOs. Amongst other things, this framework enables Infinispan to provide highly efficient ways to marshall internal Infinispan Java POJOs that are constantly used. Apart from providing more efficient ways to marshall Java POJOs, including internal Java classes, JBoss Marshalling uses highly performant java.io.ObjectOutput and java.io.ObjectInput implementations compared to standard java.io.ObjectOutputStream and java.io.ObjectInputStream.
 
-[[sid-8093979_Marshalling-SupportForNonSerializableObjects]]
+[[sid-68355106_Marshalling-SupportForNonSerializableObjects]]
 
 
 === Support For Non-Serializable Objects
@@ -45,19 +45,19 @@ From a users perspective, a very common concern is whether Infinispan supports s
 
  If you're unable to retrofit Serializable or Externalizable into the classes whose instances are stored in Infinispan, you could alternatively use something like link:$$http://xstream.codehaus.org/$$[XStream] to convert your Non-Serializable objects into an String that can be stored into Infinispan. You can find an example on how to use XStream link:$$http://anonsvn.jboss.org/repos/infinispan/trunk/core/src/test/java/org/infinispan/marshall/TestObjectStreamMarshaller.java$$[here] . The one caveat about using XStream is that it slows down the process of storing key/value objects due to the XML transformation that it needs to do. 
 
-[[sid-8093979_Marshalling-LazyDeserialization%28storeAsBinary%29]]
+[[sid-68355106_Marshalling-StoreAsBinary]]
 
 
-==== Lazy Deserialization (storeAsBinary)
+==== Store As Binary
 
-Lazy deserialization is the mechanism by which Infinispan by which serialization and deserialization of objects is deferred till the point in time in which they are used and needed. This typically means that any deserialization happens using the thread context class loader of the invocation that requires deserialization, and is an effective mechanism to provide classloader isolation. By default lazy deserialization is disabled but if you want to enable it, you can do it like this:
+Store as binary enables data to be stored in its serialized form. This can be useful to achieve lazy deserialization, which is the mechanism by which Infinispan by which serialization and deserialization of objects is deferred till the point in time in which they are used and needed. This typically means that any deserialization happens using the thread context class loader of the invocation that requires deserialization, and is an effective mechanism to provide classloader isolation. By default lazy deserialization is disabled but if you want to enable it, you can do it like this:
 
 
 * Via XML at the Cache level, either under &lt;namedCache&gt; or &lt;default&gt; elements:
 
 
 ----
-<lazyDeserialization enabled="true"/>
+<storeAsBinary enabled="true"/>
 ----
 
 
@@ -65,44 +65,62 @@ Lazy deserialization is the mechanism by which Infinispan by which serialization
 
 
 ----
-Configuration configuration = ...
-configuration.setUseLazyDeserialization(true);
+ConfigurationBuilder builder = ...
+builder.storeAsBinary().enable();
 
 ----
 
- _Note:_ Since 5.0 onwards, lazyDeserialization has been renamed to storeAsBinary to better represent its functionality: 
+[[sid-68355106_Marshalling-EqualityConsiderations]]
 
 
-----
-<storeAsBinary enabled="true"/>
-----
+===== Equality Considerations
 
-The programmatic configuration has changed as well together with a move towards more fluent configuration:
+ When using lazy deserialization/storing as binary, keys and values are wrapped as link:$$http://docs.jboss.org/infinispan/5.3/apidocs/org/infinispan/marshall/MarshalledValue$$[MarshalledValue] s.  It is this wrapper class that transparently takes care of serialization and deserialization on demand, and internally may have a reference to the object itself being wrapped, or the serialized, byte array representation of this object. 
 
+ This has a particular effect on the behavior of equality. The equals() method of this class will either compare binary representations (byte arrays) or delegate to the wrapped object instance's equals() method, depending on whether both instances being compared are in serialized or deserialized form at the time of comparison.  If one of the instances being compared is in one form and the other in another form, then one instance is either serialized or deserialized.  The preference will be to compare object representations, unless the cache is link:$$http://docs.jboss.org/infinispan/5.3/apidocs/org/infinispan/Cache.html#compact()$$[compacted] , in which case byte array comparison is favored. 
+
+This will affect the way keys stored in the cache will work, when {{storeAsBinary]} is used, since comparisons happen on the key which will be wrapped by a MarshalledValue. Implementers of equals() methods on their keys need to be aware of the behavior of equality comparison, when a key is wrapped as a MarshalledValue, as detailed above.
+
+[[sid-68355106_Marshalling-Storebyvalueviadefensivecopying]]
+
+
+===== Store-by-value via defensive copying
+
+ Starting with Infinispan 5.3.0.Final, storeAsBinary configuration offers the possibility to enable defensive copying, which allows for store-by-value like behaviour. 
+
+When defensive copying is disabled (default), Infinispan keeps object references around and stores them in a binary format lazily. So clients can still modify entries via original object references, and marshalling only happens when entries are to be replicated/distributed, or stored in a cache store. Since client references are valid, clients can make changes to entries in the cache using those references, but these modifications are only local and you still need to call one of the cache's put/replace... methods in order for changes to replicate. This is essentially store-by-reference. This is the default mode for performance reasons.
+
+When defensive copies are enabled, Infinispan marshalls objects the moment they're stored, hence changes made to object references are not stored in the cache, not even for local caches. This provides store-by-value like behaviour. Enabling defensive copying can be achieved:
+
+
+*  Via XML at the Cache level, either under &lt;namedCache&gt; or &lt;default&gt; elements: 
 
-----
-Configuration configuration = ...
-configuration.fluent().storeAsBinary();
 
 ----
+<storeAsBinary enabled="true" defensive="true"/>
+----
 
-Equality Considerations
 
- When using lazy deserialization/storing as binary, keys and values are wrapped as link:$$http://docs.jboss.org/infinispan/5.0/apidocs/?org/infinispan/marshall/MarshalledValue$$[MarshalledValue] s.  It is this wrapper class that transparently takes care of serialization and deserialization on demand, and internally may have a reference to the object itself being wrapped, or the serialized, byte array representation of this object This has a particular effect on the behavior of equality.  The equals() method of this class will either compare binary representations (byte arrays) or delegate to the wrapped object instance's equals() method, depending on whether both instances being compared are in serialized or deserialized form at the time of comparison.  If one of the instances being compared is in one form and the other in another form, then one instance is either serialized or deserialized.  The preference will be to compare object representations, unless the cache is link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/Cache.html#compact()$$[compacted] , in which case byte array comparison is favored. 
+* Programmatically:
 
-This will affect the way keys stored in the cache will work, when storeAsBinary is used, since comparisons happen on the key which will be wrapped by a MarshalledValue.  Implementers of equals() methods on their keys need to be aware of the behavior of equality comparison, when a key is wrapped as a MarshalledValue, as detailed above.
 
-[[sid-8093979_Marshalling-AdvancedConfiguration]]
+----
+ConfigurationBuilder builder = ...
+builder.storeAsBinary().enable().defensive(true);
+
+----
+
+[[sid-68355106_Marshalling-AdvancedConfiguration]]
 
 
 === Advanced Configuration
 
  Internally, Infinispan uses an implementation of link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/marshall/Marshaller.html$$[this Marshaller interface] in order to marshall/unmarshall Java objects so that they're sent other nodes in the grid, or so that they're stored in a cache store, or even so to transform them into byte arrays for lazy deserialization. 
 
- By default, Infinispan uses the link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/marshall/VersionAwareMarshaller.html$$[VersionAwareMarshaller] which, as the name suggests, adds a version short to the start of any stream when writing, enabling similar VersionAwareMarshaller instances to read the version short and know which specific marshaller implementation to delegate the call to. Using a VersionAwareMarshaller helps achieve wire protocol compatibility between minor releases but still affords us the flexibility to tweak and improve the wire protocol between minor or micro releases. Optionally, Infinispan users to optionally provide their own marshaller, for example: 
+ By default, Infinispan uses the link:$$http://docs.jboss.org/infinispan/5.3/apidocs/org/infinispan/marshall/VersionAwareMarshaller.html$$[VersionAwareMarshaller] which, as the name suggests, adds a version short to the start of any stream when writing, enabling similar VersionAwareMarshaller instances to read the version short and know which specific marshaller implementation to delegate the call to. Using a VersionAwareMarshaller helps achieve wire protocol compatibility between minor releases but still affords us the flexibility to tweak and improve the wire protocol between minor or micro releases. Optionally, Infinispan users to optionally provide their own marshaller, for example: 
 
 
-* Via XML at the CacheManager level, under &lt;global&gt; element:
+*  Via XML at the CacheManager level, under &lt;global&gt; element: 
 
 
 ----
@@ -114,12 +132,15 @@ This will affect the way keys stored in the cache will work, when storeAsBinary
 
 
 ----
-GlobalConfiguration globalConfiguration = ...
-globalConfiguration.setMarshallerClass("com.acme.MyMarshaller")
+GlobalConfigurationBuilder builder = ...
+builder.serialization().marshaller(myMarshaller); // needs an instance of the marshaller
 
 ----
 
-Troubleshooting
+[[sid-68355106_Marshalling-Troubleshooting]]
+
+
+==== Troubleshooting
 
 Sometimes it might happen that the Infinispan marshalling layer, and in particular JBoss Marshalling, might have issues marshalling/unmarshalling some user object. In Infinispan 4.0, marshalling exceptions will contain further information on the objects that were being marshalled. Example:
 
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-62-Batching.adoc b/documentation/src/main/asciidoc/user_guide/chapter-62-Batching.adoc
index 721d201..7c77f26 100644
--- a/documentation/src/main/asciidoc/user_guide/chapter-62-Batching.adoc
+++ b/documentation/src/main/asciidoc/user_guide/chapter-62-Batching.adoc
@@ -1,15 +1,15 @@
-[[sid-8093959]]
+[[sid-68355084]]
 
 ==  Batching
 
-[[sid-8093959_Batching-Introduction]]
+[[sid-68355084_Batching-Introduction]]
 
 
 === Introduction
 
 Generally speaking, one should use batching API whenever the only participant in the transaction is an Infinispan cluster. On the other hand, JTA transactions (involving TransactionManager) should be used whenever the transactions involves multiple systems. E.g. considering the "Hello world!" of transactions: transferring money from one bank account to the other. If both accounts are stored within Infinispan, then batching can be used. If one account is in a database and the other is Infinispan, then distributed transactions are required.
 
-[[sid-8093959_Batching-Configuringbatching]]
+[[sid-68355084_Batching-Configuringbatching]]
 
 
 === Configuring batching
@@ -34,7 +34,7 @@ By default, invocation batching is disabled.
 
 Note that you do not have to have a transaction manager defined to use batching.
 
-[[sid-8093959_Batching-BatchingAPI]]
+[[sid-68355084_Batching-BatchingAPI]]
 
 
 === Batching API
@@ -61,7 +61,7 @@ cache.endBatch(false); // This will "discard" changes made in the batch
 
 ----
 
-[[sid-8093959_Batching-Advanced%3AbatchingandJTA]]
+[[sid-68355084_Batching-Advanced%3AbatchingandJTA]]
 
 
 === Advanced: batching and JTA
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-63-Hot_Rod_Hash_Functions.adoc b/documentation/src/main/asciidoc/user_guide/chapter-63-Hot_Rod_Hash_Functions.adoc
new file mode 100644
index 0000000..04ceb33
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-63-Hot_Rod_Hash_Functions.adoc
@@ -0,0 +1,18 @@
+[[sid-68355116]]
+
+==  Hot Rod Hash Functions
+
+Infinispan makes use of a consistent hash function to place nodes on a hash wheel, and to place keys of entries on the same wheel to determine where entries live.
+
+ In Infinispan 4.2 and earlier, the hash space was hardcoded to 10240, but since 5.0, the hash space is link:$$http://download.oracle.com/javase/6/docs/api/java/lang/Integer.html#MAX_VALUE$$[Integer.MAX_INT] . Please note that since Hot Rod clients should not assume a particular hash space by default, everytime a hash-topology change is detected, this value is sent back to the client via the <<sid-68355112,Hot Rod protocol>> . 
+
+When interacting with Infinispan via the Hot Rod protocol, it is mandated that keys (and values) are byte arrays, to ensure platform neutral behavior.  As such, smart-clients which are aware of hash distribution on the backend would need to be able to calculate the hash codes of such byte array keys, again in a platform-neutral manner. To this end, the hash functions used by Infinispan are versioned and documented, so that it can be re-implemented by non-Java clients if needed.
+
+ The version of the hash function in use is provided in the <<sid-68355112,Hot Rod protocol>> , as the hash function version parameter. 
+
+
+.  Version 1 (single byte, 0x01) The initial version of the hash function in use is link:$$https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/util/hash/MurmurHash2.java$$[Austin Appleby's MurmurHash 2.0 algorithm] , a fast, non-cryptographic hash that exhibits excellent distribution, collision resistance and avalanche behavior.  The specific version of the algorithm used is the slightly slower, endian-neutral version that allows consistent behavior across both big- and little-endian CPU architectures.  Infinispan's version also hard-codes the hash seed as -1. For details of the algorithm, please visit link:$$http://sites.google.com/site/murmurhash/$$[Austin Appleby's MurmurHash 2.0 page] .  Other implementations are detailed on link:$$http://en.wikipedia.org/wiki/MurmurHash$$[Wikipedia] . This hash function was the default one used by the Hot Rod server until Infinispan 4.2.1. 
+
+
+.  Version 2 (single byte, 0x02) Since Infinispan 5.0, a new hash function is used by default which is link:$$https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/util/hash/MurmurHash3.java$$[Austin Appleby's MurmurHash 3.0 algorithm] . Detailed information about the hash function can be found in this link:$$http://code.google.com/p/smhasher/wiki/MurmurHash3$$[wiki] . Compared to 2.0, it provides better performance and spread. 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-64-Hot_Rod_Protocol.adoc b/documentation/src/main/asciidoc/user_guide/chapter-64-Hot_Rod_Protocol.adoc
new file mode 100644
index 0000000..4d02bc9
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-64-Hot_Rod_Protocol.adoc
@@ -0,0 +1,2035 @@
+[[sid-68355112]]
+
+==  Hot Rod Protocol
+
+
+.  <<sid-68355113,Hot Rod protocol version 1.0>> 
+
+
+.  <<sid-68355114,Hot Rod protocol version 1.1>> 
+
+
+.  <<sid-68355115,Hot Rod protocol version 1.2>> 
+
+[[sid-68355113]]
+
+
+=== Hot Rod Protocol - Version 1.0
+
+[[sid-68355113_HotRodProtocol-Version1.0-Introduction]]
+
+
+==== Introduction
+
+This article provides detailed information about the first version of the custom TCP client/server Hot Rod protocol.
+
+
+[TIP]
+.Infinispan versions
+==== 
+This version of the protocol is implemented since Infinispan 4.1.0.Final
+
+
+==== 
+
+
+
+[IMPORTANT]
+==== 
+All key and values are sent and stored as byte arrays. Hot Rod makes no assumptions about their types. Some clarifications about the other types:
+
+
+*  vInt : Refers to unsigned variable length integer values as specified in link:$$http://lucene.apache.org/java/2_4_0/fileformats.html#VInt$$[here] . They're between 1 and 5 bytes long. 
+
+
+*  vLong : Refers to unsigned variable length long values similar to vInt but applied to longer values. They're between 1 and 9 bytes long. 
+
+
+*  String : Strings are always represented using UTF-8 encoding. 
+
+
+==== 
+
+
+[[sid-68355113_HotRodProtocol-Version1.0-RequestHeader]]
+
+
+==== Request Header
+
+The header for a request is composed of:
+
+
+|===============
+| Magic [ 1b ] | Message Id [ vLong ] | Version [ 1b ] | Opcode [ 1b ] | Cache Name Length [ vInt ] | Cache Name [ string ] | Flags [ vInt ] | Client Intelligence [ 1b ] | Topology Id [ vInt ] | Transaction Type [ 1b ] | Transaction Id [ byte-array ] 
+
+|===============
+
+
+
+*  _Magic_ : Possible values are: 
+
+
+*  0xA0 - Infinispan Cache Request Marker 
+
+
+*  0xA1 - Infinispan Cache Response Marker 
+
+
+*  _Message Id_ : Id of the message that will be copied back in the response. This allows for hot rod clients to implement the protocol in an asynchronous way. 
+
+
+*  _Version_ : Infinispan hot rod server version. In this particular case, this is 10 
+
+
+*  _Opcode_ : Possible values are only the ones on the request column: 
+
+[options="header"]
+|===============
+|Request operation codes|Response operation codes
+| 0x01 - put request | 0x02 - put response 
+| 0x03 - get request | 0x04 - get response 
+| 0x05 - putIfAbsent request | 0x06 - putIfAbsent response 
+| 0x07 - replace request | 0x08 - replace response 
+| 0x09 - replaceIfUnmodified request | 0x0A - replaceIfUnmodified response 
+| 0x0B - remove request | 0x0C - remove response 
+| 0x0D - removeIfUnmodified request | 0x0E - removeIfUnmodified response 
+| 0x0F - containsKey request | 0x10 - containsKey response 
+| 0x11 - getWithVersion request | 0x12 - getWithVersion response 
+| 0x13 - clear request | 0x14 - clear response 
+| 0x15 - stats request | 0x16 - stats response 
+| 0x17 - ping request | 0x18 - ping response 
+| 0x19 - bulkGet request | 0x1A - bulkGet response 
+|-| 0x50 - error response 
+
+|===============
+
+
+
+*  _Cache Name Length_ : Length of cache name. If the passed length is 0 (followed by no cache name), the operation will interact with the default cache. 
+
+
+*  _Cache Name_ : Name of cache on which to operate. This name must match the name of predefined cache in the Infinispan configuration file. 
+
+
+*  _Flags_ : A variable length number representing flags passed to the system. Each flags is represented by a bit. Note that since this field is sent as variable length, the most significant bit in a byte is used to determine whether more bytes need to be read, hence this bit does not represent any flag. Using this model allows for flags to be combined in a short space. Here are the current values for each flag: 
+
+
+|===============
+| 0x0001 |ForceReturnPreviousValue
+
+|===============
+
+
+
+*  _Client Intelligence_ : This byte hints the server on the client capabilities: 
+
+
+*  0x01 - basic client, interested in neither cluster nor hash information 
+
+
+*  0x02 - topology-aware client, interested in cluster information 
+
+
+*  0x03 - hash-distribution-aware client, that is interested in both cluster and hash information 
+
+
+*  _Topology Id_ : This field represents the last known view in the client. Basic clients will only send 0 in this field. When topology-aware or hash-distribution-aware clients will send 0 until they have received a reply from the server with the current view id. Afterwards, they should send that view id until they receive a new view id in a response 
+
+
+*  _Transaction Type_ : This is a 1 byte field, containing one of the following well-known supported transaction types (For this version of the protocol, the only supported transaction type is 0): 
+
+
+*  0 - Non-transactional call, or client does not support transactions. The subsequent TX_ID field will be omitted. 
+
+
+*  1 - X/Open XA transaction ID (XID). This is a well-known, fixed-size format. 
+
+
+*  _Transaction Id_ : The byte array uniquely identifying the transaction associated to this call. It's length is determined by the transaction type. If transaction type is 0, no transaction id will be present. 
+
+[[sid-68355113_HotRodProtocol-Version1.0-ResponseHeader]]
+
+
+==== Response Header
+
+
+|===============
+| Magic [ 1b ] | Message Id [ vLong ] | Op code [ 1b ] | Status [ 1b ] | Topology Change Marker [ 1b ] 
+
+|===============
+
+
+
+*  _Opcode_ : Op code representing a response to a particular operation, or error condition. 
+
+
+*  _Status_ : Status of the response, possible values: 
+
+
+|===============
+| 0x00 - No error | 0x01 - Not put/removed/replaced | 0x02 - Key does not exist 
+| 0x81 - Invalid magic or message id | 0x82 - Unknown command | 0x83 - Unknown version 
+| 0x84 - Request parsing error | 0x85 - Server Error | 0x86 - Command timed out 
+
+|===============
+
+
+ Exceptional error status responses, those that start with 0x8 ..., are followed by the length of the error message (as a vInt ) and error message itself as String. 
+
+
+*  _Topology Change Marker_ : This is a marker byte that indicates whether the response is prepended with topology change information. When no topology change follows, the content of this byte is 0. If a topology change follows, its contents are 1. 
+
+[[sid-68355113_HotRodProtocol-Version1.0-TopologyChangeHeaders]]
+
+
+===== Topology Change Headers
+
+The following section discusses how the response headers look for topology-aware or hash-distribution-aware clients when there's been a cluster or view formation change. Note that it's the server that makes the decision on whether it sends back the new topology based on the current topology id and the one the client sent. If they're different, it will send back the new topology.
+
+[[sid-68355113_HotRodProtocol-Version1.0-TopologyAwareClientTopologyChangeHeader]]
+
+
+===== =Topology-Aware Client Topology Change Header
+
+This is what topology-aware clients receive as response header when a topology change is sent back:
+
+[options="header"]
+|===============
+|Response header with topology change marker| Topology Id [ vInt ] | Num servers in topology [ vInt ] 
+| m1: Host/IP length [ vInt ] | m1: Host/IP address [ string ] | m1: Port [ 2b - Unsigned Short ] 
+| m2: Host/IP length [ vInt ] | m2: Host/IP address [ string ] | m2: Port [ 2b - Unsigned Short ] 
+|...etc||
+
+|===============
+
+
+
+*  _Num servers in topology_ : Number of Infinispan Hot Rod servers running within the cluster. This could be a subset of the entire cluster if only a fraction of those nodes are running Hot Rod servers. 
+
+
+*  _Host/IP address length_ : Length of hostname or IP address of individual cluster member that Hot Rod client can use to access it. Using variable length here allows for covering for hostnames, IPv4 and IPv6 addresses. 
+
+
+*  _Host/IP address_ : String containing hostname or IP address of individual cluster member that Hot Rod client can use to access it. 
+
+
+*  _Port_ : Port that Hot Rod clients can use to communicat with this cluster member. 
+
+[[sid-68355113_HotRodProtocol-Version1.0-HashDistributionAwareClientTopologyChangeHeader]]
+
+
+===== =Distribution-Aware Client Topology Change Header
+
+This is what hash-distribution-aware clients receive as response header when a topology change is sent back:
+
+[options="header"]
+|===============
+|Response header with topology change marker| Topology Id [ vInt ] | Num Key Owners [ 2b - Unsigned Short ] | Hash Function Version [ 1b ] | Hash space size [ vInt ] |Num servers in topology [vInt]
+| m1: Host/IP length [ vInt ] | m1: Host/IP address [ string ] | m1: Port [ 2b - unsigned short ] | m1: Hashcode [ 4b ] ||
+| m2: Host/IP length [ vInt ] | m2: Host/IP address [ string ] | m2: Port [ 2b - unsigned short ] | m2: Hashcode [ 4b ] ||
+|...etc|||||
+
+|===============
+
+
+ It's important to note that since hash headers rely on the consistent hash algorithm used by the server and this is a factor of the cache interacted with, hash-distribution-aware headers can only be returned to operations that target a particular cache. Currently ping command does not target any cache (this is to change as per link:$$https://jira.jboss.org/jira/browse/ISPN-424$$[ISPN-424] , hence calls to ping command with hash-topology-aware client settings will return a hash-distribution-aware header with "Num Key Owners", "Hash Function Version", "Hash space size" and each individual host's hash code all set to 0. This type of header will also be returned as response to operations with hash-topology-aware client settings that are targeting caches that are not configured with distribution. 
+
+
+*  _Number key owners_ : Globally configured number of copies for each Infinispan distributed key 
+
+
+*  _Hash function version_ : Hash function version, pointing to a specific hash function in use. See <<sid-68355116,Hot Rod hash functions>> for details. 
+
+
+*  _Hash space size_ : Modulus used by Infinispan for for all module arithmetic related to hash code generation. Clients will likely require this information in order to apply the correct hash calculation to the keys. 
+
+
+*  _Num servers in topology_ : If virtual nodes are disabled, this number represents the number of Hot Rod servers in the cluster. If virtual nodes are enabled, this number represents all the virtual nodes in the cluster which are calculated as (num configured virtual nodes) * (num cluster members). Regardless of whether virtual nodes are configured or not, the number represented by this field indicates the number of 'host:port:hashId' tuples to be read in the response. 
+
+
+*  _Hashcode_ : 32 bit integer representing the hashcode of a cluster member that a Hot Rod client can use indentify in which cluster member a key is located having applied the CSA to it. 
+
+[[sid-68355113_HotRodProtocol-Version1.0-Operations]]
+
+
+==== Operations
+
+[[sid-68355113_HotRodProtocol-Version1.0-Get%2FRemove%2FContainsKey%2FGetWithVersion]]
+
+
+===== Get/Remove/ContainsKey/GetWithVersion
+
+
+* Common request format:
+
+
+|===============
+|Header| Key Length [ vInt ] | Key [ byte-array ] 
+
+|===============
+
+
+
+*  _Key Length_ : Length of key. Note that the size of a vint can be up to 5 bytes which in theory can produce bigger numbers than Integer.MAX_VALUE . However, Java cannot create a single array that's bigger than Integer.MAX_VALUE, hence the protocol is limiting vint array lengths to Integer.MAX_VALUE. 
+
+
+*  _Key_ : Byte array containing the key whose value is being requested. 
+
+
+* Response status:
+
+
+*  0x00 - success, if key present/retrieved/removed 
+
+
+*  0x02 - if key does not exist 
+
+
+* Get response:
+
+
+|===============
+|Header| Value Length [ vInt ] | Value [ byte-array ] 
+
+|===============
+
+
+
+*  _Value Length_ : Length of value 
+
+
+*  _Value_ : The requested value. If key does not exist, status returned in 0x02. See encoding section for more info. 
+
+
+*  Remove response: If ForceReturnPreviousValue has been passed, remove response will contain previous value (including value length) for that key. If the key does not exist or previous was null, value length would be 0. Otherwise, if no ForceReturnPreviousValue was sent, the response would be empty. 
+
+
+*  ContainsKey response: Empty 
+
+
+* GetWithVersion response:
+
+
+|===============
+|Header| Entry Version [ 8b ] | Value Length [ vInt ] | Value [ byte-array ] 
+
+|===============
+
+
+
+*  _Entry Version_ : Unique value of an existing entry's modification. The protocol does not mandate that entry_version values are sequential. They just need to be unique per update at the key level. 
+
+[[sid-68355113_HotRodProtocol-Version1.0-BulkGet]]
+
+
+===== BulkGet
+
+
+* Request format:
+
+
+|===============
+|Header| Entry Count [ vInt ] 
+
+|===============
+
+
+
+*  _Entry Count_ : Maximum number of Infinispan entries to be returned by the server (entry == key + associated value). Needed to support CacheLoader.load(int). If 0 then all entries are returned (needed for CacheLoader.loadAll()). 
+
+
+* Response:
+
+
+|===============
+|Header| More [ 1b ] |Key Size 1|Key 1|Value Size 1|Value 1| More [ 1b ] |Key Size 2|Key 2|Value Size 2|Value 2| More [ 1b ] ... 
+
+|===============
+
+
+
+*  _More_ : One byte representing whether more entries need to be read from the stream. So, when it's set to 1, it means that an entry followes, whereas when it's set to 0, it's the end of stream and no more entries are left to read. For more information on BulkGet look link:$$http://community.jboss.org/docs/DOC-15592$$[here] 
+
+[[sid-68355113_HotRodProtocol-Version1.0-Put%2FPutIfAbsent%2FReplace]]
+
+
+===== Put/PutIfAbsent/Replace
+
+
+* Common request format:
+
+
+|===============
+|Header| Key Length [ vInt ] | Key [ byte-array ] | Lifespan [ vInt ] | Max Idle [ vInt ] | Value Length [ vInt ] | Value [ byte-array ] 
+
+|===============
+
+
+
+*  _Lifespan_ : Number of seconds that a entry during which the entry is allowed to life. If number of seconds is bigger than 30 days, this number of seconds is treated as UNIX time and so, represents the number of seconds since 1/1/1970. If set to 0, lifespan is unlimited. 
+
+
+*  _Max Idle_ : Number of seconds that a entry can be idle before it's evicted from the cache. If 0, no max idle time. 
+
+
+* Put response status:
+
+
+*  0x00 if stored 
+
+
+* Replace response status:
+
+
+*  0x00 if stored 
+
+
+*  0x01 if store did not happen because key does not exist 
+
+
+* PutIfAbsent response status:
+
+
+*  0x00 if stored 
+
+
+*  0x01 if store did not happen because key was present 
+
+
+*  Put/PutIfAbsent/Replace response: If ForceReturnPreviousValue has been passed, these responses will contain previous value (and corresponding value length) for that key. If the key does not exist or previous was null, value length would be 0. Otherwise, if no ForceReturnPreviousValue was sent, the response would be empty. 
+
+[[sid-68355113_HotRodProtocol-Version1.0-ReplaceIfUnmodified]]
+
+
+===== ReplaceIfUnmodified
+
+
+* Request format:
+
+
+|===============
+|Header| Key Length [ vInt ] | Key [ byte-array ] | Lifespan [ vInt ] | Max Idle [ vInt ] | Entry Version [ 8b ] | Value Length [ vInt ] | Value [ byte-array ] 
+
+|===============
+
+
+
+*  _Entry Version_ : Use the value returned by GetWithVersion operation. 
+
+
+* Response status
+
+
+*  0x00 status if replaced/removed 
+
+
+*  0x01 status if replace/remove did not happen because key had been modified 
+
+
+*  0x02 status if key does not exist 
+
+
+*  Response: If ForceReturnPreviousValue has been passed, this responses will contain previous value (and corresponding value length) for that key. If the key does not exist or previous was null, value length would be 0. Otherwise, if no ForceReturnPreviousValue was sent, the response would be empty. 
+
+[[sid-68355113_HotRodProtocol-Version1.0-RemoveIfUnmodified]]
+
+
+===== RemoveIfUnmodified
+
+
+* Request format:
+
+
+|===============
+|Header| Key Length [ vInt ] | Key [ byte-array ] | Entry Version [ 8b ] 
+
+|===============
+
+
+
+* Response status
+
+
+*  0x00 status if replaced/removed 
+
+
+*  0x01 status if replace/remove did not happen because key had been modified 
+
+
+*  0x02 status if key does not exist 
+
+
+*  Response: If ForceReturnPreviousValue has been passed, this responses will contain previous value (and corresponding value length) for that key. If the key does not exist or previous was null, value length would be 0. Otherwise, if no ForceReturnPreviousValue was sent, the response would be empty. 
+
+[[sid-68355113_HotRodProtocol-Version1.0-Clear]]
+
+
+===== Clear
+
+
+* Request format:
+
+
+|===============
+|Header
+
+|===============
+
+
+
+* Response status:
+
+
+*  0x00 status if infinispan was cleared 
+
+[[sid-68355113_HotRodProtocol-Version1.0-Stats]]
+
+
+===== Stats
+
+Returns a summary of all available statistics. For each statistic returned, a name and a value is returned both in String UTF-8 format. The supported stats are the following:
+
+[options="header"]
+|===============
+|Name|Explanation
+| timeSinceStart |Number of seconds since Hot Rod started.
+| currentNumberOfEntries |Number of entries currently in the Hot Rod server.
+| totalNumberOfEntries |Number of entries stored in Hot Rod server.
+| stores |Number of put operations.
+| retrievals |Number of get operations.
+| hits |Number of get hits.
+| misses |Number of get misses.
+| removeHits |Number of removal hits.
+| removeMisses |Number of removal misses.
+
+|===============
+
+
+
+* Response
+
+
+|===============
+|Header| Number of stats [ vInt ] | Name1 length [ vInt ] | Name1 [ string ] | Value1 length [ vInt ] | Value1 [ String ] |Name2 length|Name2|Value2 length|Value2|...
+
+|===============
+
+
+
+*  _Number of stats_ : Number of individual stats returned 
+
+
+*  _Name length_ : Length of named statistic 
+
+
+*  _Name_ : String containing statistic name 
+
+
+*  _Value length_ : Length of value field 
+
+
+*  _Value_ : String containing statistic value. 
+
+[[sid-68355113_HotRodProtocol-Version1.0-Ping]]
+
+
+===== Ping
+
+Application level request to see if the server is available.
+
+
+* Response status:
+
+
+*  0x00 - if no errors 
+
+[[sid-68355113_HotRodProtocol-Version1.0-ErrorHandling]]
+
+
+==== Error Handling
+
+
+|===============
+|Response header| Error Message Length vInt | Error Message string 
+
+|===============
+
+
+Response header contains error op code response and corresponding error status number as well as the following two:
+
+
+*  _Error Message Length_ : Length of error message 
+
+
+*  _Error message_ : Error message. In the case of 0x84 , this error field contains the latest version supported by the hot rod server. Length is defined by total body length. 
+
+[[sid-68355113_HotRodProtocol-Version1.0-MultiGetOperations]]
+
+
+==== Multi-Get Operations
+
+A multi-get operation is a form of get operation that instead of requesting a single key, requests a set of keys. The Hot Rod protocol does not include such operation but remote Hot Rod clients could easily implement this type of operations by either parallelizing/pipelining individual get requests. Another possibility would be for remote clients to use async or non-blocking get requests. For example, if a client wants N keys, it could send send N async get requests and then wait for all the replies. Finally, multi-get is not to be confused with bulk-get operations. In bulk-gets, either all or a number of keys are retrieved, but the client does not know which keys to retrieve, whereas in multi-get, the client defines which keys to retrieve.
+
+[[sid-68355113_HotRodProtocol-Version1.0-ExamplePutrequest]]
+
+
+==== Example - Put request
+
+
+* Coded request
+
+[options="header"]
+|===============
+|Byte|0|1|2|3|4|5|6|7
+|8| 0xA0 | 0x09 | 0x41 | 0x01 | 0x07 | 0x4D ('M') | 0x79 ('y') | 0x43 ('C') 
+|16| 0x61 ('a') | 0x63 ('c') | 0x68 ('h') | 0x65 ('e') | 0x00 | 0x03 | 0x00 | 0x00 
+|24| 0x00 | 0x05 | 0x48 ('H') | 0x65 ('e') | 0x6C ('l') | 0x6C ('l') | 0x6F ('o') | 0x00 
+|32| 0x00 | 0x05 | 0x57 ('W') | 0x6F ('o') | 0x72 ('r') | 0x6C ('l') | 0x64 ('d') | 
+
+|===============
+
+
+
+* Field explanation
+
+[options="header"]
+|===============
+|Field Name|Value|Field Name|Value
+|Magic (0)| 0xA0 |Message Id (1)| 0x09 
+|Version (2)| 0x41 |Opcode (3)| 0x01 
+|Cache name length (4)| 0x07 |Cache name(5-11)| 'MyCache' 
+|Flag (12)| 0x00 |Client Intelligence (13)| 0x03 
+|Topology Id (14)| 0x00 |Transaction Type (15)| 0x00 
+|Transaction Id (16)| 0x00 |Key field length (17)| 0x05 
+|Key (18 - 22)| 'Hello' |Lifespan (23)| 0x00 
+|Max idle (24)| 0x00 |Value field length (25)| 0x05 
+|Value (26-30)| 'World' ||
+
+|===============
+
+
+
+* Coded response
+
+[options="header"]
+|===============
+|Byte|0|1|2|3|4|5|6|7
+|8| 0xA1 | 0x09 | 0x01 | 0x00 | 0x00 | | | 
+
+|===============
+
+
+
+* Field Explanation
+
+[options="header"]
+|===============
+|Field Name|Value|Field Name|Value
+|Magic (0)| 0xA1 |Message Id (1)| 0x09 
+|Opcode (2)| 0x01 |Status (3)| 0x00 
+|Topology change marker (4)| 0x00 | |
+
+|===============
+
+
+[[sid-68355114]]
+
+
+=== Hot Rod Protocol - Version 1.1
+
+[[sid-68355114_HotRodProtocol-Version1.1-Introduction]]
+
+
+==== Introduction
+
+This article provides detailed information about the first version of the custom TCP client/server Hot Rod protocol.
+
+
+[TIP]
+.Infinispan versions
+==== 
+This version of the protocol is implemented since Infinispan 5.1.0.FINAL
+
+
+==== 
+
+
+
+[IMPORTANT]
+==== 
+All key and values are sent and stored as byte arrays. Hot Rod makes no assumptions about their types. Some clarifications about the other types:
+
+
+*  vInt : Refers to unsigned variable length integer values as specified in link:$$http://lucene.apache.org/java/2_4_0/fileformats.html#VInt$$[here] . They're between 1 and 5 bytes long. 
+
+
+*  vLong : Refers to unsigned variable length long values similar to vInt but applied to longer values. They're between 1 and 9 bytes long. 
+
+
+*  String : Strings are always represented using UTF-8 encoding. 
+
+
+==== 
+
+
+[[sid-68355114_HotRodProtocol-Version1.1-RequestHeader]]
+
+
+==== Request Header
+
+The header for a request is composed of:
+
+
+|===============
+| Magic [ 1b ] | Message Id [ vLong ] | Version [ 1b ] | Opcode [ 1b ] | Cache Name Length [ vInt ] | Cache Name [ string ] | Flags [ vInt ] | Client Intelligence [ 1b ] | Topology Id [ vInt ] | Transaction Type [ 1b ] | Transaction Id [ byte-array ] 
+
+|===============
+
+
+
+*  _Magic_ : Possible values are: 
+
+
+*  0xA0 - Infinispan Cache Request Marker 
+
+
+*  0xA1 - Infinispan Cache Response Marker 
+
+
+*  _Message Id_ : Id of the message that will be copied back in the response. This allows for hot rod clients to implement the protocol in an asynchronous way. 
+
+
+*  _Version_ : Infinispan hot rod server version. 
+
+
+[IMPORTANT]
+.Updated for 1.1
+==== 
+ The value of this field in version 1.1 is 11 
+
+
+==== 
+
+
+
+*  _Opcode_ : Possible values are only the ones on the request column: 
+
+[options="header"]
+|===============
+|Request operation codes|Response operation codes
+| 0x01 - put request | 0x02 - put response 
+| 0x03 - get request | 0x04 - get response 
+| 0x05 - putIfAbsent request | 0x06 - putIfAbsent response 
+| 0x07 - replace request | 0x08 - replace response 
+| 0x09 - replaceIfUnmodified request | 0x0A - replaceIfUnmodified response 
+| 0x0B - remove request | 0x0C - remove response 
+| 0x0D - removeIfUnmodified request | 0x0E - removeIfUnmodified response 
+| 0x0F - containsKey request | 0x10 - containsKey response 
+| 0x11 - getWithVersion request | 0x12 - getWithVersion response 
+| 0x13 - clear request | 0x14 - clear response 
+| 0x15 - stats request | 0x16 - stats response 
+| 0x17 - ping request | 0x18 - ping response 
+| 0x19 - bulkGet request | 0x1A - bulkGet response 
+|-| 0x50 - error response 
+
+|===============
+
+
+
+*  _Cache Name Length_ : Length of cache name. If the passed length is 0 (followed by no cache name), the operation will interact with the default cache. 
+
+
+*  _Cache Name_ : Name of cache on which to operate. This name must match the name of predefined cache in the Infinispan configuration file. 
+
+
+*  _Flags_ : A variable length number representing flags passed to the system. Each flags is represented by a bit. Note that since this field is sent as variable length, the most significant bit in a byte is used to determine whether more bytes need to be read, hence this bit does not represent any flag. Using this model allows for flags to be combined in a short space. Here are the current values for each flag: 
+
+
+|===============
+| 0x0001 |ForceReturnPreviousValue
+
+|===============
+
+
+
+*  _Client Intelligence_ : This byte hints the server on the client capabilities: 
+
+
+*  0x01 - basic client, interested in neither cluster nor hash information 
+
+
+*  0x02 - topology-aware client, interested in cluster information 
+
+
+*  0x03 - hash-distribution-aware client, that is interested in both cluster and hash information 
+
+
+*  _Topology Id_ : This field represents the last known view in the client. Basic clients will only send 0 in this field. When topology-aware or hash-distribution-aware clients will send 0 until they have received a reply from the server with the current view id. Afterwards, they should send that view id until they receive a new view id in a response 
+
+
+*  _Transaction Type_ : This is a 1 byte field, containing one of the following well-known supported transaction types (For this version of the protocol, the only supported transaction type is 0): 
+
+
+*  0 - Non-transactional call, or client does not support transactions. The subsequent TX_ID field will be omitted. 
+
+
+*  1 - X/Open XA transaction ID (XID). This is a well-known, fixed-size format. 
+
+
+*  _Transaction Id_ : The byte array uniquely identifying the transaction associated to this call. It's length is determined by the transaction type. If transaction type is 0, no transaction id will be present. 
+
+[[sid-68355114_HotRodProtocol-Version1.1-ResponseHeader]]
+
+
+==== Response Header
+
+
+|===============
+| Magic [ 1b ] | Message Id [ vLong ] | Op code [ 1b ] | Status [ 1b ] | Topology Change Marker [ 1b ] 
+
+|===============
+
+
+
+*  _Opcode_ : Op code representing a response to a particular operation, or error condition. 
+
+
+*  _Status_ : Status of the response, possible values: 
+
+
+|===============
+| 0x00 - No error | 0x01 - Not put/removed/replaced | 0x02 - Key does not exist 
+| 0x81 - Invalid magic or message id | 0x82 - Unknown command | 0x83 - Unknown version 
+| 0x84 - Request parsing error | 0x85 - Server Error | 0x86 - Command timed out 
+
+|===============
+
+
+ Exceptional error status responses, those that start with 0x8 ..., are followed by the length of the error message (as a vInt ) and error message itself as String. 
+
+
+*  _Topology Change Marker_ : This is a marker byte that indicates whether the response is prepended with topology change information. When no topology change follows, the content of this byte is 0. If a topology change follows, its contents are 1. 
+
+[[sid-68355114_HotRodProtocol-Version1.1-TopologyChangeHeaders]]
+
+
+===== Topology Change Headers
+
+The following section discusses how the response headers look for topology-aware or hash-distribution-aware clients when there's been a cluster or view formation change. Note that it's the server that makes the decision on whether it sends back the new topology based on the current topology id and the one the client sent. If they're different, it will send back the new topology.
+
+[[sid-68355114_HotRodProtocol-Version1.1-TopologyAwareClientTopologyChangeHeader]]
+
+
+===== =Topology-Aware Client Topology Change Header
+
+This is what topology-aware clients receive as response header when a topology change is sent back:
+
+[options="header"]
+|===============
+|Response header with topology change marker| Topology Id [ vInt ] | Num servers in topology [ vInt ] 
+| m1: Host/IP length [ vInt ] | m1: Host/IP address [ string ] | m1: Port [ 2b - Unsigned Short ] 
+| m2: Host/IP length [ vInt ] | m2: Host/IP address [ string ] | m2: Port [ 2b - Unsigned Short ] 
+|...etc||
+
+|===============
+
+
+
+*  _Num servers in topology_ : Number of Infinispan Hot Rod servers running within the cluster. This could be a subset of the entire cluster if only a fraction of those nodes are running Hot Rod servers. 
+
+
+*  _Host/IP address length_ : Length of hostname or IP address of individual cluster member that Hot Rod client can use to access it. Using variable length here allows for covering for hostnames, IPv4 and IPv6 addresses. 
+
+
+*  _Host/IP address_ : String containing hostname or IP address of individual cluster member that Hot Rod client can use to access it. 
+
+
+*  _Port_ : Port that Hot Rod clients can use to communicat with this cluster member. 
+
+[[sid-68355114_HotRodProtocol-Version1.1-HashDistributionAwareClientTopologyChangeHeader]]
+
+
+===== =Distribution-Aware Client Topology Change Header
+
+
+[IMPORTANT]
+.Updated for 1.1
+==== 
+This section has been modified to be more efficient when talking to distributed caches with virtual nodes enabled.
+
+
+==== 
+
+
+This is what hash-distribution-aware clients receive as response header when a topology change is sent back:
+
+[options="header"]
+|===============
+|Response header with topology change marker| Topology Id [ vInt ] | Num Key Owners [ 2b - Unsigned Short ] | Hash Function Version [ 1b ] | Hash space size [ vInt ] |Num servers in topology [vInt]| Num Virtual Nodes Owners [ vInt ] 
+| m1: Host/IP length [ vInt ] | m1: Host/IP address [ string ] | m1: Port [ 2b - unsigned short ] | m1: Hashcode [ 4b ] |||
+| m2: Host/IP length [ vInt ] | m2: Host/IP address [ string ] | m2: Port [ 2b - unsigned short ] | m1: Hashcode [ 4b ] |||
+|...etc||||||
+
+|===============
+
+
+
+*  _Number key owners_ : Globally configured number of copies for each Infinispan distributed key. If the cache is not configured with distribution, this field will return 0 . 
+
+
+*  _Hash function version_ : Hash function version, pointing to a specific hash function in use. See <<sid-68355116,Hot Rod hash functions>> for details. If cache is not configured with distribution, this field will contain 0 . 
+
+
+*  _Hash space size_ : Modulus used by Infinispan for for all module arithmetic related to hash code generation. Clients will likely require this information in order to apply the correct hash calculation to the keys. If cache is not configured with distribution, this field will contain 0 . 
+
+
+*  _Num servers in topology_ : Represents the number of servers in the Hot Rod cluster which represents the number of host:port pairings to be read in the header. 
+
+
+*  _Number virtual nodes_ : Field added in version 1.1 of the protocol that represents the number of configured virtual nodes. If no virtual nodes are configured or the cache is not configured with distribution, this field will contain 0 . 
+
+[[sid-68355114_HotRodProtocol-Version1.1-Servernodehashcodecalculation]]
+
+
+===== ==Server node hash code calculation
+
+Adding support for virtual nodes has made version 1.0 of the Hot Rod protocol impractical due to bandwidth it would have taken to return hash codes for all virtual nodes in the clusters (this number could easily be in the millions). So, as of version 1.1 of the Hot Rod protocol, clients are given the base hash id or hash code of each server, and then they have to calculate the real hash position of each server both with and without virtual nodes configured. Here are the rules clients should follow when trying to calculate a node's hash code:
+
+
+.  With _virtual nodes disabled_ : Once clients have received the base hash code of the server, they need to normalize it in order to find the exact position of the hash wheel. The process of normalization involves passing the base hash code to the hash function, and then do a small calculation to avoid negative values. The resulting number is the node's position in the hash wheel: 
+
+
+----
+public static int getNormalizedHash(int nodeBaseHashCode, Hash hashFct) {
+   return hashFct.hash(nodeBaseHashCode) & Integer.MAX_VALUE; // make sure no negative numbers are involved.
+}
+----
+
+
+.  With _virtual nodes enabled_ : In this case, each node represents N different virtual nodes, and to calculate each virtual node's hash code, we need to take the the range of numbers between 0 and N-1 and apply the following logic: 
+
+
+* For virtual node with 0 as id, use the technique used to retrieve a node's hash code, as shown in the previous section.
+
+
+* For virtual nodes from 1 to N-1 ids, execute the following logic:
+
+
+----
+public static int virtualNodeHashCode(int nodeBaseHashCode, int id, Hash hashFct) {
+   int virtualNodeBaseHashCode = id;
+   virtualNodeBaseHashCode = 31 * virtualNodeBaseHashCode + nodeBaseHashCode;
+   return getNormalizedHash(virtualNodeBaseHashCode, hashFct);
+}
+----
+
+[[sid-68355114_HotRodProtocol-Version1.1-Operations]]
+
+
+==== Operations
+
+[[sid-68355114_HotRodProtocol-Version1.1-Get%2FRemove%2FContainsKey%2FGetWithVersion]]
+
+
+===== Get/Remove/ContainsKey/GetWithVersion
+
+
+* Common request format:
+
+
+|===============
+|Header| Key Length [ vInt ] | Key [ byte-array ] 
+
+|===============
+
+
+
+*  _Key Length_ : Length of key. Note that the size of a vint can be up to 5 bytes which in theory can produce bigger numbers than Integer.MAX_VALUE . However, Java cannot create a single array that's bigger than Integer.MAX_VALUE, hence the protocol is limiting vint array lengths to Integer.MAX_VALUE. 
+
+
+*  _Key_ : Byte array containing the key whose value is being requested. 
+
+
+* Response status:
+
+
+*  0x00 - success, if key present/retrieved/removed 
+
+
+*  0x02 - if key does not exist 
+
+
+* Get response:
+
+
+|===============
+|Header| Value Length [ vInt ] | Value [ byte-array ] 
+
+|===============
+
+
+
+*  _Value Length_ : Length of value 
+
+
+*  _Value_ : The requested value. If key does not exist, status returned in 0x02. See encoding section for more info. 
+
+
+*  Remove response: If ForceReturnPreviousValue has been passed, remove response will contain previous value (including value length) for that key. If the key does not exist or previous was null, value length would be 0. Otherwise, if no ForceReturnPreviousValue was sent, the response would be empty. 
+
+
+*  ContainsKey response: Empty 
+
+
+* GetWithVersion response:
+
+
+|===============
+|Header| Entry Version [ 8b ] | Value Length [ vInt ] | Value [ byte-array ] 
+
+|===============
+
+
+
+*  _Entry Version_ : Unique value of an existing entry's modification. The protocol does not mandate that entry_version values are sequential. They just need to be unique per update at the key level. 
+
+[[sid-68355114_HotRodProtocol-Version1.1-BulkGet]]
+
+
+===== BulkGet
+
+
+* Request format:
+
+
+|===============
+|Header| Entry Count [ vInt ] 
+
+|===============
+
+
+
+*  _Entry Count_ : Maximum number of Infinispan entries to be returned by the server (entry == key + associated value). Needed to support CacheLoader.load(int). If 0 then all entries are returned (needed for CacheLoader.loadAll()). 
+
+
+* Response:
+
+
+|===============
+|Header| More [ 1b ] |Key Size 1|Key 1|Value Size 1|Value 1| More [ 1b ] |Key Size 2|Key 2|Value Size 2|Value 2| More [ 1b ] ... 
+
+|===============
+
+
+
+*  _More_ : One byte representing whether more entries need to be read from the stream. So, when it's set to 1, it means that an entry followes, whereas when it's set to 0, it's the end of stream and no more entries are left to read. For more information on BulkGet look link:$$http://community.jboss.org/docs/DOC-15592$$[here] 
+
+[[sid-68355114_HotRodProtocol-Version1.1-Put%2FPutIfAbsent%2FReplace]]
+
+
+===== Put/PutIfAbsent/Replace
+
+
+* Common request format:
+
+
+|===============
+|Header| Key Length [ vInt ] | Key [ byte-array ] | Lifespan [ vInt ] | Max Idle [ vInt ] | Value Length [ vInt ] | Value [ byte-array ] 
+
+|===============
+
+
+
+*  _Lifespan_ : Number of seconds that a entry during which the entry is allowed to life. If number of seconds is bigger than 30 days, this number of seconds is treated as UNIX time and so, represents the number of seconds since 1/1/1970. If set to 0, lifespan is unlimited. 
+
+
+*  _Max Idle_ : Number of seconds that a entry can be idle before it's evicted from the cache. If 0, no max idle time. 
+
+
+* Put response status:
+
+
+*  0x00 if stored 
+
+
+* Replace response status:
+
+
+*  0x00 if stored 
+
+
+*  0x01 if store did not happen because key does not exist 
+
+
+* PutIfAbsent response status:
+
+
+*  0x00 if stored 
+
+
+*  0x01 if store did not happen because key was present 
+
+
+*  Put/PutIfAbsent/Replace response: If ForceReturnPreviousValue has been passed, these responses will contain previous value (and corresponding value length) for that key. If the key does not exist or previous was null, value length would be 0. Otherwise, if no ForceReturnPreviousValue was sent, the response would be empty. 
+
+[[sid-68355114_HotRodProtocol-Version1.1-ReplaceIfUnmodified]]
+
+
+===== ReplaceIfUnmodified
+
+
+* Request format:
+
+
+|===============
+|Header| Key Length [ vInt ] | Key [ byte-array ] | Lifespan [ vInt ] | Max Idle [ vInt ] | Entry Version [ 8b ] | Value Length [ vInt ] | Value [ byte-array ] 
+
+|===============
+
+
+
+*  _Entry Version_ : Use the value returned by GetWithVersion operation. 
+
+
+* Response status
+
+
+*  0x00 status if replaced/removed 
+
+
+*  0x01 status if replace/remove did not happen because key had been modified 
+
+
+*  0x02 status if key does not exist 
+
+
+*  Response: If ForceReturnPreviousValue has been passed, this responses will contain previous value (and corresponding value length) for that key. If the key does not exist or previous was null, value length would be 0. Otherwise, if no ForceReturnPreviousValue was sent, the response would be empty. 
+
+[[sid-68355114_HotRodProtocol-Version1.1-RemoveIfUnmodified]]
+
+
+===== RemoveIfUnmodified
+
+
+* Request format:
+
+
+|===============
+|Header| Key Length [ vInt ] | Key [ byte-array ] | Entry Version [ 8b ] 
+
+|===============
+
+
+
+* Response status
+
+
+*  0x00 status if replaced/removed 
+
+
+*  0x01 status if replace/remove did not happen because key had been modified 
+
+
+*  0x02 status if key does not exist 
+
+
+*  Response: If ForceReturnPreviousValue has been passed, this responses will contain previous value (and corresponding value length) for that key. If the key does not exist or previous was null, value length would be 0. Otherwise, if no ForceReturnPreviousValue was sent, the response would be empty. 
+
+[[sid-68355114_HotRodProtocol-Version1.1-Clear]]
+
+
+===== Clear
+
+
+* Request format:
+
+
+|===============
+|Header
+
+|===============
+
+
+
+* Response status:
+
+
+*  0x00 status if infinispan was cleared 
+
+[[sid-68355114_HotRodProtocol-Version1.1-Stats]]
+
+
+===== Stats
+
+Returns a summary of all available statistics. For each statistic returned, a name and a value is returned both in String UTF-8 format. The supported stats are the following:
+
+[options="header"]
+|===============
+|Name|Explanation
+| timeSinceStart |Number of seconds since Hot Rod started.
+| currentNumberOfEntries |Number of entries currently in the Hot Rod server.
+| totalNumberOfEntries |Number of entries stored in Hot Rod server.
+| stores |Number of put operations.
+| retrievals |Number of get operations.
+| hits |Number of get hits.
+| misses |Number of get misses.
+| removeHits |Number of removal hits.
+| removeMisses |Number of removal misses.
+
+|===============
+
+
+
+* Response
+
+
+|===============
+|Header| Number of stats [ vInt ] | Name1 length [ vInt ] | Name1 [ string ] | Value1 length [ vInt ] | Value1 [ String ] |Name2 length|Name2|Value2 length|Value2|...
+
+|===============
+
+
+
+*  _Number of stats_ : Number of individual stats returned 
+
+
+*  _Name length_ : Length of named statistic 
+
+
+*  _Name_ : String containing statistic name 
+
+
+*  _Value length_ : Length of value field 
+
+
+*  _Value_ : String containing statistic value. 
+
+[[sid-68355114_HotRodProtocol-Version1.1-Ping]]
+
+
+===== Ping
+
+Application level request to see if the server is available.
+
+
+* Response status:
+
+
+*  0x00 - if no errors 
+
+[[sid-68355114_HotRodProtocol-Version1.1-ErrorHandling]]
+
+
+==== Error Handling
+
+
+|===============
+|Response header| Error Message Length vInt | Error Message string 
+
+|===============
+
+
+Response header contains error op code response and corresponding error status number as well as the following two:
+
+
+*  _Error Message Length_ : Length of error message 
+
+
+*  _Error message_ : Error message. In the case of 0x84 , this error field contains the latest version supported by the hot rod server. Length is defined by total body length. 
+
+[[sid-68355114_HotRodProtocol-Version1.1-MultiGetOperations]]
+
+
+==== Multi-Get Operations
+
+A multi-get operation is a form of get operation that instead of requesting a single key, requests a set of keys. The Hot Rod protocol does not include such operation but remote Hot Rod clients could easily implement this type of operations by either parallelizing/pipelining individual get requests. Another possibility would be for remote clients to use async or non-blocking get requests. For example, if a client wants N keys, it could send send N async get requests and then wait for all the replies. Finally, multi-get is not to be confused with bulk-get operations. In bulk-gets, either all or a number of keys are retrieved, but the client does not know which keys to retrieve, whereas in multi-get, the client defines which keys to retrieve.
+
+[[sid-68355114_HotRodProtocol-Version1.1-ExamplePutrequest]]
+
+
+==== Example - Put request
+
+
+* Coded request
+
+[options="header"]
+|===============
+|Byte|0|1|2|3|4|5|6|7
+|8| 0xA0 | 0x09 | 0x41 | 0x01 | 0x07 | 0x4D ('M') | 0x79 ('y') | 0x43 ('C') 
+|16| 0x61 ('a') | 0x63 ('c') | 0x68 ('h') | 0x65 ('e') | 0x00 | 0x03 | 0x00 | 0x00 
+|24| 0x00 | 0x05 | 0x48 ('H') | 0x65 ('e') | 0x6C ('l') | 0x6C ('l') | 0x6F ('o') | 0x00 
+|32| 0x00 | 0x05 | 0x57 ('W') | 0x6F ('o') | 0x72 ('r') | 0x6C ('l') | 0x64 ('d') | 
+
+|===============
+
+
+
+* Field explanation
+
+[options="header"]
+|===============
+|Field Name|Value|Field Name|Value
+|Magic (0)| 0xA0 |Message Id (1)| 0x09 
+|Version (2)| 0x41 |Opcode (3)| 0x01 
+|Cache name length (4)| 0x07 |Cache name(5-11)| 'MyCache' 
+|Flag (12)| 0x00 |Client Intelligence (13)| 0x03 
+|Topology Id (14)| 0x00 |Transaction Type (15)| 0x00 
+|Transaction Id (16)| 0x00 |Key field length (17)| 0x05 
+|Key (18 - 22)| 'Hello' |Lifespan (23)| 0x00 
+|Max idle (24)| 0x00 |Value field length (25)| 0x05 
+|Value (26-30)| 'World' ||
+
+|===============
+
+
+
+* Coded response
+
+[options="header"]
+|===============
+|Byte|0|1|2|3|4|5|6|7
+|8| 0xA1 | 0x09 | 0x01 | 0x00 | 0x00 | | | 
+
+|===============
+
+
+
+* Field Explanation
+
+[options="header"]
+|===============
+|Field Name|Value|Field Name|Value
+|Magic (0)| 0xA1 |Message Id (1)| 0x09 
+|Opcode (2)| 0x01 |Status (3)| 0x00 
+|Topology change marker (4)| 0x00 | |
+
+|===============
+
+
+[[sid-68355115]]
+
+
+=== Hot Rod Protocol - Version 1.2
+
+[[sid-68355115_HotRodProtocol-Version1.2-Introduction]]
+
+
+==== Introduction
+
+This article provides detailed information about the first version of the custom TCP client/server Hot Rod protocol.
+
+
+[TIP]
+.Infinispan versions
+==== 
+This version of the protocol is implemented since Infinispan 5.2.0.Final. Since Infinispan 5.3.0, HotRod supports encryption via SSL. However, since this only affects the transport, the version number of the protocol has not been incremented.
+
+
+==== 
+
+
+
+[IMPORTANT]
+==== 
+All key and values are sent and stored as byte arrays. Hot Rod makes no assumptions about their types. Some clarifications about the other types:
+
+
+*  vInt : Refers to unsigned variable length integer values as specified in link:$$http://lucene.apache.org/java/2_4_0/fileformats.html#VInt$$[here] . They're between 1 and 5 bytes long. 
+
+
+*  vLong : Refers to unsigned variable length long values similar to vInt but applied to longer values. They're between 1 and 9 bytes long. 
+
+
+*  String : Strings are always represented using UTF-8 encoding. 
+
+
+==== 
+
+
+[[sid-68355115_HotRodProtocol-Version1.2-RequestHeader]]
+
+
+==== Request Header
+
+The header for a request is composed of:
+
+
+|===============
+| Magic [ 1b ] | Message Id [ vLong ] | Version [ 1b ] | Opcode [ 1b ] | Cache Name Length [ vInt ] | Cache Name [ string ] | Flags [ vInt ] | Client Intelligence [ 1b ] | Topology Id [ vInt ] | Transaction Type [ 1b ] | Transaction Id [ byte-array ] 
+
+|===============
+
+
+
+*  _Magic_ : Possible values are: 
+
+
+*  0xA0 - Infinispan Cache Request Marker 
+
+
+*  0xA1 - Infinispan Cache Response Marker 
+
+
+*  _Message Id_ : Id of the message that will be copied back in the response. This allows for hot rod clients to implement the protocol in an asynchronous way. 
+
+
+*  _Version_ : Infinispan hot rod server version. 
+
+
+[IMPORTANT]
+.Updated for 1.2
+==== 
+ The value of this field in version 1.2 is 12 
+
+
+==== 
+
+
+
+*  _Opcode_ : Possible values are only the ones on the request column: 
+
+[options="header"]
+|===============
+|Request operation codes|Response operation codes
+| 0x01 - put request | 0x02 - put response 
+| 0x03 - get request | 0x04 - get response 
+| 0x05 - putIfAbsent request | 0x06 - putIfAbsent response 
+| 0x07 - replace request | 0x08 - replace response 
+| 0x09 - replaceIfUnmodified request | 0x0A - replaceIfUnmodified response 
+| 0x0B - remove request | 0x0C - remove response 
+| 0x0D - removeIfUnmodified request | 0x0E - removeIfUnmodified response 
+| 0x0F - containsKey request | 0x10 - containsKey response 
+| 0x11 - getWithVersion request | 0x12 - getWithVersion response 
+| 0x13 - clear request | 0x14 - clear response 
+| 0x15 - stats request | 0x16 - stats response 
+| 0x17 - ping request | 0x18 - ping response 
+| 0x19 - bulkGet request | 0x1A - bulkGet response 
+| 0x1B - getWithMetadata request | 0x1C - getWithMetadata response 
+| 0x1D - bulkKeysGet request | 0x1E - bulkKeysGet response 
+|-| 0x50 - error response 
+
+|===============
+
+
+
+*  _Cache Name Length_ : Length of cache name. If the passed length is 0 (followed by no cache name), the operation will interact with the default cache. 
+
+
+*  _Cache Name_ : Name of cache on which to operate. This name must match the name of predefined cache in the Infinispan configuration file. 
+
+
+*  _Flags_ : A variable length number representing flags passed to the system. Each flags is represented by a bit. Note that since this field is sent as variable length, the most significant bit in a byte is used to determine whether more bytes need to be read, hence this bit does not represent any flag. Using this model allows for flags to be combined in a short space. Here are the current values for each flag: 
+
+
+|===============
+| 0x0001 |ForceReturnPreviousValue
+| 0x0002 |DefaultLifespan
+| 0x0004 | DefaultMaxIdle 
+
+|===============
+
+
+
+*  _Client Intelligence_ : This byte hints the server on the client capabilities: 
+
+
+*  0x01 - basic client, interested in neither cluster nor hash information 
+
+
+*  0x02 - topology-aware client, interested in cluster information 
+
+
+*  0x03 - hash-distribution-aware client, that is interested in both cluster and hash information 
+
+
+*  _Topology Id_ : This field represents the last known view in the client. Basic clients will only send 0 in this field. When topology-aware or hash-distribution-aware clients will send 0 until they have received a reply from the server with the current view id. Afterwards, they should send that view id until they receive a new view id in a response 
+
+
+*  _Transaction Type_ : This is a 1 byte field, containing one of the following well-known supported transaction types (For this version of the protocol, the only supported transaction type is 0): 
+
+
+*  0 - Non-transactional call, or client does not support transactions. The subsequent TX_ID field will be omitted. 
+
+
+*  1 - X/Open XA transaction ID (XID). This is a well-known, fixed-size format. 
+
+
+*  _Transaction Id_ : The byte array uniquely identifying the transaction associated to this call. It's length is determined by the transaction type. If transaction type is 0, no transaction id will be present. 
+
+[[sid-68355115_HotRodProtocol-Version1.2-ResponseHeader]]
+
+
+==== Response Header
+
+
+|===============
+| Magic [ 1b ] | Message Id [ vLong ] | Op code [ 1b ] | Status [ 1b ] | Topology Change Marker [ 1b ] 
+
+|===============
+
+
+
+*  _Opcode_ : Op code representing a response to a particular operation, or error condition. 
+
+
+*  _Status_ : Status of the response, possible values: 
+
+
+|===============
+| 0x00 - No error | 0x01 - Not put/removed/replaced | 0x02 - Key does not exist 
+| 0x81 - Invalid magic or message id | 0x82 - Unknown command | 0x83 - Unknown version 
+| 0x84 - Request parsing error | 0x85 - Server Error | 0x86 - Command timed out 
+
+|===============
+
+
+ Exceptional error status responses, those that start with 0x8 ..., are followed by the length of the error message (as a vInt ) and error message itself as String. 
+
+
+*  _Topology Change Marker_ : This is a marker byte that indicates whether the response is prepended with topology change information. When no topology change follows, the content of this byte is 0. If a topology change follows, its contents are 1. 
+
+[[sid-68355115_HotRodProtocol-Version1.2-TopologyChangeHeaders]]
+
+
+===== Topology Change Headers
+
+The following section discusses how the response headers look for topology-aware or hash-distribution-aware clients when there's been a cluster or view formation change. Note that it's the server that makes the decision on whether it sends back the new topology based on the current topology id and the one the client sent. If they're different, it will send back the new topology.
+
+[[sid-68355115_HotRodProtocol-Version1.2-TopologyAwareClientTopologyChangeHeader]]
+
+
+===== =Topology-Aware Client Topology Change Header
+
+This is what topology-aware clients receive as response header when a topology change is sent back:
+
+[options="header"]
+|===============
+|Response header with topology change marker| Topology Id [ vInt ] | Num servers in topology [ vInt ] 
+| m1: Host/IP length [ vInt ] | m1: Host/IP address [ string ] | m1: Port [ 2b - Unsigned Short ] 
+| m2: Host/IP length [ vInt ] | m2: Host/IP address [ string ] | m2: Port [ 2b - Unsigned Short ] 
+|...etc||
+
+|===============
+
+
+
+*  _Num servers in topology_ : Number of Infinispan Hot Rod servers running within the cluster. This could be a subset of the entire cluster if only a fraction of those nodes are running Hot Rod servers. 
+
+
+*  _Host/IP address length_ : Length of hostname or IP address of individual cluster member that Hot Rod client can use to access it. Using variable length here allows for covering for hostnames, IPv4 and IPv6 addresses. 
+
+
+*  _Host/IP address_ : String containing hostname or IP address of individual cluster member that Hot Rod client can use to access it. 
+
+
+*  _Port_ : Port that Hot Rod clients can use to communicat with this cluster member. 
+
+[[sid-68355115_HotRodProtocol-Version1.2-HashDistributionAwareClientTopologyChangeHeader]]
+
+
+===== =Distribution-Aware Client Topology Change Header
+
+This is what hash-distribution-aware clients receive as response header when a topology change is sent back:
+
+[options="header"]
+|===============
+|Response header with topology change marker| Topology Id [ vInt ] | Num Key Owners [ 2b - Unsigned Short ] | Hash Function Version [ 1b ] | Hash space size [ vInt ] |Num servers in topology [vInt]| Num Virtual Nodes Owners [ vInt ] 
+| m1: Host/IP length [ vInt ] | m1: Host/IP address [ string ] | m1: Port [ 2b - unsigned short ] | m1: Hashcode [ 4b ] |||
+| m2: Host/IP length [ vInt ] | m2: Host/IP address [ string ] | m2: Port [ 2b - unsigned short ] | m1: Hashcode [ 4b ] |||
+|...etc||||||
+
+|===============
+
+
+
+*  _Number key owners_ : Globally configured number of copies for each Infinispan distributed key. If the cache is not configured with distribution, this field will return 0 . 
+
+
+*  _Hash function version_ : Hash function version, pointing to a specific hash function in use. See <<sid-68355116,Hot Rod hash functions>> for details. If cache is not configured with distribution, this field will contain 0 . 
+
+
+*  _Hash space size_ : Modulus used by Infinispan for for all module arithmetic related to hash code generation. Clients will likely require this information in order to apply the correct hash calculation to the keys. If cache is not configured with distribution, this field will contain 0 . 
+
+
+*  _Num servers in topology_ : Represents the number of servers in the Hot Rod cluster which represents the number of host:port pairings to be read in the header. 
+
+
+*  _Number virtual nodes_ : Field added in version 1.1 of the protocol that represents the number of configured virtual nodes. If no virtual nodes are configured or the cache is not configured with distribution, this field will contain 0 . 
+
+[[sid-68355115_HotRodProtocol-Version1.2-Servernodehashcodecalculation]]
+
+
+===== ==Server node hash code calculation
+
+Adding support for virtual nodes has made version 1.0 of the Hot Rod protocol impractical due to bandwidth it would have taken to return hash codes for all virtual nodes in the clusters (this number could easily be in the millions). So, as of version 1.1 of the Hot Rod protocol, clients are given the base hash id or hash code of each server, and then they have to calculate the real hash position of each server both with and without virtual nodes configured. Here are the rules clients should follow when trying to calculate a node's hash code:
+
+
+.  With _virtual nodes disabled_ : Once clients have received the base hash code of the server, they need to normalize it in order to find the exact position of the hash wheel. The process of normalization involves passing the base hash code to the hash function, and then do a small calculation to avoid negative values. The resulting number is the node's position in the hash wheel: 
+
+
+----
+public static int getNormalizedHash(int nodeBaseHashCode, Hash hashFct) {
+   return hashFct.hash(nodeBaseHashCode) & Integer.MAX_VALUE; // make sure no negative numbers are involved.
+}
+----
+
+
+.  With _virtual nodes enabled_ : In this case, each node represents N different virtual nodes, and to calculate each virtual node's hash code, we need to take the the range of numbers between 0 and N-1 and apply the following logic: 
+
+
+* For virtual node with 0 as id, use the technique used to retrieve a node's hash code, as shown in the previous section.
+
+
+* For virtual nodes from 1 to N-1 ids, execute the following logic:
+
+
+----
+public static int virtualNodeHashCode(int nodeBaseHashCode, int id, Hash hashFct) {
+   int virtualNodeBaseHashCode = id;
+   virtualNodeBaseHashCode = 31 * virtualNodeBaseHashCode + nodeBaseHashCode;
+   return getNormalizedHash(virtualNodeBaseHashCode, hashFct);
+}
+----
+
+[[sid-68355115_HotRodProtocol-Version1.2-Operations]]
+
+
+==== Operations
+
+[[sid-68355115_HotRodProtocol-Version1.2-Get%2FRemove%2FContainsKey%2FGetWithVersion%2FGetWithM...]]
+
+
+===== Get/Remove/ContainsKey/GetWithVersion/GetWithMetadata
+
+
+* Common request format:
+
+
+|===============
+|Header| Key Length [ vInt ] | Key [ byte-array ] 
+
+|===============
+
+
+
+*  _Key Length_ : Length of key. Note that the size of a vint can be up to 5 bytes which in theory can produce bigger numbers than Integer.MAX_VALUE . However, Java cannot create a single array that's bigger than Integer.MAX_VALUE, hence the protocol is limiting vint array lengths to Integer.MAX_VALUE. 
+
+
+*  _Key_ : Byte array containing the key whose value is being requested. 
+
+
+* Response status:
+
+
+*  0x00 - success, if key present/retrieved/removed 
+
+
+*  0x02 - if key does not exist 
+
+
+* Get response:
+
+
+|===============
+|Header| Value Length [ vInt ] | Value [ byte-array ] 
+
+|===============
+
+
+
+*  _Value Length_ : Length of value 
+
+
+*  _Value_ : The requested value. If key does not exist, status returned in 0x02. See encoding section for more info. 
+
+
+*  Remove response: If ForceReturnPreviousValue has been passed, remove response will contain previous value (including value length) for that key. If the key does not exist or previous was null, value length would be 0. Otherwise, if no ForceReturnPreviousValue was sent, the response would be empty. 
+
+
+*  ContainsKey response: Empty 
+
+
+* GetWithVersion response:
+
+
+|===============
+|Header| Entry Version [ 8b ] | Value Length [ vInt ] | Value [ byte-array ] 
+
+|===============
+
+
+
+*  _Entry Version_ : Unique value of an existing entry's modification. The protocol does not mandate that entry_version values are sequential. They just need to be unique per update at the key level. 
+
+
+* GetWithMetadata response:
+
+
+|===============
+|Header| Flag (byte) | Created [Long] (optional) | Lifespan [vInt] (optional) | LastUsed [Long] (optional) | MaxIdle [vInt] (optional) | Entry Version [ 8b ] | Value Length [ vInt ] | Value [ byte-array ] 
+
+|===============
+
+
+
+*  _Flag_ : a flag indicating whether the response contains expiration information. The value of the flag is obtained as a bitwise OR operation between INFINITE_LIFESPAN (0x01) and INFINITE_MAXIDLE (0x02) 
+
+
+*  _Created_ : a Long representing the timestamp when the entry was created on the server. This value is returned only if the flag's INFINITE_LIFESPAN bit is not set 
+
+
+*  _Lifespan_ : a vInt representing the lifespan of the entry in seconds. This value is returned only if the flag's INFINITE_LIFESPAN bit is not set 
+
+
+*  _LastUsed_ : a Long representing the timestamp when the entry was last accessed on the server. This value is returned only if the flag's INFINITE_MAXIDLE bit is not set 
+
+
+*  _MaxIdle :_ a vInt representing the maxIdle of the entry in seconds. This value is returned only if the flag's INFINITE_MAXIDLE bit is not set 
+
+
+*  _Entry Version_ : Unique value of an existing entry's  modification. The protocol does not mandate that entry_version values  are sequential. They just need to be unique per update at the key level. 
+
+[[sid-68355115_HotRodProtocol-Version1.2-BulkGet]]
+
+
+===== BulkGet
+
+
+* Request format:
+
+
+|===============
+|Header| Entry Count [ vInt ] 
+
+|===============
+
+
+
+*  _Entry Count_ : Maximum number of Infinispan entries to be returned by the server (entry == key + associated value). Needed to support CacheLoader.load(int). If 0 then all entries are returned (needed for CacheLoader.loadAll()). 
+
+
+* Response:
+
+
+|===============
+|Header| More [ 1b ] |Key Size 1|Key 1|Value Size 1|Value 1| More [ 1b ] |Key Size 2|Key 2|Value Size 2|Value 2| More [ 1b ] ... 
+
+|===============
+
+
+
+*  _More_ : One byte representing whether more entries need to be read from the stream. So, when it's set to 1, it means that an entry followes, whereas when it's set to 0, it's the end of stream and no more entries are left to read. For more information on BulkGet look link:$$http://community.jboss.org/docs/DOC-15592$$[here] 
+
+[[sid-68355115_HotRodProtocol-Version1.2-BulkKeysGet]]
+
+
+===== BulkKeysGet
+
+
+* Request format:
+
+
+|===============
+|Header| Scope [ vInt ] 
+
+|===============
+
+
+
+*  _Scope_ : 0 - Default Scope - This scope is used by RemoteCache.keySet() method.  If the remote cache is a distributed cache, the server launch a map/reduce operation to retrieve all keys from all of the nodes.   (Remember, a topology-aware Hot Rod Client could be load balancing the request to any one node in the cluster).  Otherwise, it'll get keys from the cache instance local to the server receiving the request (that is because the keys should be the same across all nodes in a replicated cache). 1 - Global Scope - This scope behaves the same to Default Scope. 2 - Local Scope - In case when remote cache is a distributed cache, the server will not launch a map/reduce operation to retrieve keys from all nodes.  Instead, it'll only get keys local from the cache instance local to the server receiving the request. 
+
+
+* Response:
+
+
+|===============
+|Header| More [ 1b ] |Key Size 1| Key 1 More [ 1b ] |Key Size 2|Key 2| More [ 1b ] ... 
+
+|===============
+
+
+
+*  _More_ : One byte representing whether more keys need to be read from the stream. So, when it's set to 1, it means that a key followes, whereas when it's set to 0, it's the end of stream and no more entries are left to read. 
+
+[[sid-68355115_HotRodProtocol-Version1.2-Put%2FPutIfAbsent%2FReplace]]
+
+
+===== Put/PutIfAbsent/Replace
+
+
+* Common request format:
+
+
+|===============
+|Header| Key Length [ vInt ] | Key [ byte-array ] | Lifespan [ vInt ] | Max Idle [ vInt ] | Value Length [ vInt ] | Value [ byte-array ] 
+
+|===============
+
+
+
+*  _Lifespan_ : Number of seconds that a entry during which the entry is allowed to life. If number of seconds is bigger than 30 days, this number of seconds is treated as UNIX time and so, represents the number of seconds since 1/1/1970. If set to 0, lifespan is unlimited. 
+
+
+*  _Max Idle_ : Number of seconds that a entry can be idle before it's evicted from the cache. If 0, no max idle time. 
+
+
+* Put response status:
+
+
+*  0x00 if stored 
+
+
+* Replace response status:
+
+
+*  0x00 if stored 
+
+
+*  0x01 if store did not happen because key does not exist 
+
+
+* PutIfAbsent response status:
+
+
+*  0x00 if stored 
+
+
+*  0x01 if store did not happen because key was present 
+
+
+*  Put/PutIfAbsent/Replace response: If ForceReturnPreviousValue has been passed, these responses will contain previous value (and corresponding value length) for that key. If the key does not exist or previous was null, value length would be 0. Otherwise, if no ForceReturnPreviousValue was sent, the response would be empty. 
+
+[[sid-68355115_HotRodProtocol-Version1.2-ReplaceIfUnmodified]]
+
+
+===== ReplaceIfUnmodified
+
+
+* Request format:
+
+
+|===============
+|Header| Key Length [ vInt ] | Key [ byte-array ] | Lifespan [ vInt ] | Max Idle [ vInt ] | Entry Version [ 8b ] | Value Length [ vInt ] | Value [ byte-array ] 
+
+|===============
+
+
+
+*  _Entry Version_ : Use the value returned by GetWithVersion operation. 
+
+
+* Response status
+
+
+*  0x00 status if replaced/removed 
+
+
+*  0x01 status if replace/remove did not happen because key had been modified 
+
+
+*  0x02 status if key does not exist 
+
+
+*  Response: If ForceReturnPreviousValue has been passed, this responses will contain previous value (and corresponding value length) for that key. If the key does not exist or previous was null, value length would be 0. Otherwise, if no ForceReturnPreviousValue was sent, the response would be empty. 
+
+[[sid-68355115_HotRodProtocol-Version1.2-RemoveIfUnmodified]]
+
+
+===== RemoveIfUnmodified
+
+
+* Request format:
+
+
+|===============
+|Header| Key Length [ vInt ] | Key [ byte-array ] | Entry Version [ 8b ] 
+
+|===============
+
+
+
+* Response status
+
+
+*  0x00 status if replaced/removed 
+
+
+*  0x01 status if replace/remove did not happen because key had been modified 
+
+
+*  0x02 status if key does not exist 
+
+
+*  Response: If ForceReturnPreviousValue has been passed, this responses will contain previous value (and corresponding value length) for that key. If the key does not exist or previous was null, value length would be 0. Otherwise, if no ForceReturnPreviousValue was sent, the response would be empty. 
+
+[[sid-68355115_HotRodProtocol-Version1.2-Clear]]
+
+
+===== Clear
+
+
+* Request format:
+
+
+|===============
+|Header
+
+|===============
+
+
+
+* Response status:
+
+
+*  0x00 status if infinispan was cleared 
+
+[[sid-68355115_HotRodProtocol-Version1.2-Stats]]
+
+
+===== Stats
+
+Returns a summary of all available statistics. For each statistic returned, a name and a value is returned both in String UTF-8 format. The supported stats are the following:
+
+[options="header"]
+|===============
+|Name|Explanation
+| timeSinceStart |Number of seconds since Hot Rod started.
+| currentNumberOfEntries |Number of entries currently in the Hot Rod server.
+| totalNumberOfEntries |Number of entries stored in Hot Rod server.
+| stores |Number of put operations.
+| retrievals |Number of get operations.
+| hits |Number of get hits.
+| misses |Number of get misses.
+| removeHits |Number of removal hits.
+| removeMisses |Number of removal misses.
+
+|===============
+
+
+
+* Response
+
+
+|===============
+|Header| Number of stats [ vInt ] | Name1 length [ vInt ] | Name1 [ string ] | Value1 length [ vInt ] | Value1 [ String ] |Name2 length|Name2|Value2 length|Value2|...
+
+|===============
+
+
+
+*  _Number of stats_ : Number of individual stats returned 
+
+
+*  _Name length_ : Length of named statistic 
+
+
+*  _Name_ : String containing statistic name 
+
+
+*  _Value length_ : Length of value field 
+
+
+*  _Value_ : String containing statistic value. 
+
+[[sid-68355115_HotRodProtocol-Version1.2-Ping]]
+
+
+===== Ping
+
+Application level request to see if the server is available.
+
+
+* Response status:
+
+
+*  0x00 - if no errors 
+
+[[sid-68355115_HotRodProtocol-Version1.2-ErrorHandling]]
+
+
+==== Error Handling
+
+
+|===============
+|Response header| Error Message Length vInt | Error Message string 
+
+|===============
+
+
+Response header contains error op code response and corresponding error status number as well as the following two:
+
+
+*  _Error Message Length_ : Length of error message 
+
+
+*  _Error message_ : Error message. In the case of 0x84 , this error field contains the latest version supported by the hot rod server. Length is defined by total body length. 
+
+[[sid-68355115_HotRodProtocol-Version1.2-MultiGetOperations]]
+
+
+==== Multi-Get Operations
+
+A multi-get operation is a form of get operation that instead of requesting a single key, requests a set of keys. The Hot Rod protocol does not include such operation but remote Hot Rod clients could easily implement this type of operations by either parallelizing/pipelining individual get requests. Another possibility would be for remote clients to use async or non-blocking get requests. For example, if a client wants N keys, it could send send N async get requests and then wait for all the replies. Finally, multi-get is not to be confused with bulk-get operations. In bulk-gets, either all or a number of keys are retrieved, but the client does not know which keys to retrieve, whereas in multi-get, the client defines which keys to retrieve.
+
+[[sid-68355115_HotRodProtocol-Version1.2-ExamplePutrequest]]
+
+
+==== Example - Put request
+
+
+* Coded request
+
+[options="header"]
+|===============
+|Byte|0|1|2|3|4|5|6|7
+|8| 0xA0 | 0x09 | 0x41 | 0x01 | 0x07 | 0x4D ('M') | 0x79 ('y') | 0x43 ('C') 
+|16| 0x61 ('a') | 0x63 ('c') | 0x68 ('h') | 0x65 ('e') | 0x00 | 0x03 | 0x00 | 0x00 
+|24| 0x00 | 0x05 | 0x48 ('H') | 0x65 ('e') | 0x6C ('l') | 0x6C ('l') | 0x6F ('o') | 0x00 
+|32| 0x00 | 0x05 | 0x57 ('W') | 0x6F ('o') | 0x72 ('r') | 0x6C ('l') | 0x64 ('d') | 
+
+|===============
+
+
+
+* Field explanation
+
+[options="header"]
+|===============
+|Field Name|Value|Field Name|Value
+|Magic (0)| 0xA0 |Message Id (1)| 0x09 
+|Version (2)| 0x41 |Opcode (3)| 0x01 
+|Cache name length (4)| 0x07 |Cache name(5-11)| 'MyCache' 
+|Flag (12)| 0x00 |Client Intelligence (13)| 0x03 
+|Topology Id (14)| 0x00 |Transaction Type (15)| 0x00 
+|Transaction Id (16)| 0x00 |Key field length (17)| 0x05 
+|Key (18 - 22)| 'Hello' |Lifespan (23)| 0x00 
+|Max idle (24)| 0x00 |Value field length (25)| 0x05 
+|Value (26-30)| 'World' ||
+
+|===============
+
+
+
+* Coded response
+
+[options="header"]
+|===============
+|Byte|0|1|2|3|4|5|6|7
+|8| 0xA1 | 0x09 | 0x01 | 0x00 | 0x00 | | | 
+
+|===============
+
+
+
+* Field Explanation
+
+[options="header"]
+|===============
+|Field Name|Value|Field Name|Value
+|Magic (0)| 0xA1 |Message Id (1)| 0x09 
+|Opcode (2)| 0x01 |Status (3)| 0x00 
+|Topology change marker (4)| 0x00 | |
+
+|===============
+
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-65-Cross_site_replication.adoc b/documentation/src/main/asciidoc/user_guide/chapter-65-Cross_site_replication.adoc
new file mode 100644
index 0000000..fc3478c
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-65-Cross_site_replication.adoc
@@ -0,0 +1,321 @@
+[[sid-68355118]]
+
+==  Cross site replication
+
+ Cross site (x-site) replication allows backing up the data from one cluster to other clusters, potentially situated in different geographical location. The cross-site replication is built on top of JGroups' link:$$http://www.jgroups.org/manual-3.x/html/user-advanced.html#Relay2Advanced$$[RELAY2 protocol] . link:$$https://community.jboss.org/wiki/DesignForCrossSiteReplication$$[This document] describes the technical design of cross site replication in more detail. 
+
+[[sid-68355118_Crosssitereplication-Sampledeployment]]
+
+
+=== Sample deployment
+
+ The diagram below depicts a possible setup of replicated sites, followed by a description of individual elements present in the deployment. Options are then explained at large in future paragraphs. Comments on the diagram above: 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+
+* there are 3 sites: LON, NYC and SFO.
+
+
+* in each site there is a running Infinispan cluster with a (potentially) different number of physical nodes: 3 nodes in LON, 4 nodes in NYC and 3 nodes in SFO
+
+
+* the "users" cache is active in LON, NYC and SFO. Updates on the "users" cache in any of these sites gets replicated to the other sites as well
+
+
+* it is possible to use different replication mechanisms between sites. E.g. One can configure SFO to backup data synchronously to NYC and asynchronously to LON
+
+
+* the "users" cache can have a different configuration from one site to the other. E.g. it might be configured as distributed with numOwners=2 in the LON site, REPL in the NYC site and distributed with numOwners=1 in the SFO site
+
+
+*  JGroups is used for both inter-site and intra-site communication. link:$$http://www.jgroups.org/manual-3.x/html/user-advanced.html#Relay2Advanced$$[RELAY2] is used for inter-site communication 
+
+
+*  "orders" is a site local to LON, i.e. updates to the data in "orders" don't get replicated to the remote sites The following sections discuss specific aspects of cross site replication into more detail. The foundation of the cross-site replication functionality is RELAY2 so it highly recommended to read JGroups' link:$$http://www.jgroups.org/manual-3.x/html/user-advanced.html#Relay2Advanced$$[RELAY2] documentation before moving on into cross-site. Configuration 
+
+The cross-site replication configuration spreads over the following files:
+
+
+.  the backup policy for each individual cache is defined in infinispan's .xml configuration file ( link:$$https://docs.jboss.org/author/download/attachments/68355118/infinispan.xml?version=1&amp;modificationDate=1362652288000$$[infinispan.xml] in attachment) 
+
+
+.  cluster's jgroups xml configuration file: link:$$http://www.jgroups.org/manual-3.x/html/user-advanced.html#Relay2Advanced$$[RELAY2] protocol needs to be added to the JGroups protocol stack ( link:$$https://docs.jboss.org/author/download/attachments/68355118/jgroups.xml?version=1&amp;modificationDate=1348082252000$$[jgroups.xml] ) 
+
+
+.  RELAY2 configuration file: RELAY2 has an own configuration file ( link:$$https://docs.jboss.org/author/download/attachments/68355118/relay2.xml?version=1&amp;modificationDate=1348082291000$$[relay2.xml] ) 
+
+
+.  the jgroups channel that is used by RELAY2 has its own configuration file ( link:$$https://docs.jboss.org/author/download/attachments/68355118/jgroups-relay2.xml?version=1&amp;modificationDate=1348082201000$$[jgroups-relay2.xml] ) Infinispan XML configuration file 
+
+The local site is defined in the the global configuration section. The local is the site where the node using this configuration file resides (in the example above local site is "LON").
+
+
+----
+
+<global>
+  ...
+  <site local="LON"/>
+  ...
+</global>
+
+----
+
+The same setup can be achieved programatically:
+
+
+----
+
+GlobalConfigurationBuilder lonGc = GlobalConfigurationBuilder.defaultClusteredBuilder();
+lonGc.site().localSite("LON");
+
+----
+
+ The names of the site (case sensitive) should match the name of a site as defined within JGroups' RELAY2 protocol configuration file. Besides the global configuration, each cache specifies its backup policy in the "site" element: 
+
+
+----
+
+<namedCache name="users">
+   <sites>
+     <backups>
+       <backup site="NYC" backupFailurePolicy="WARN" strategy="SYNC" timeout="12000"/>
+       <backup site="SFO" backupFailurePolicy="IGNORE" strategy="ASYNC"/>
+       <backup site="LON" strategy="SYNC" enabled="false"/>
+     </backups>
+  </sites>
+</namedCache>
+
+----
+
+ The "users" cache backups its data to the "NYC" and "SFO" sites. Even though the "LON" appears as a backup site, it has the "enabled" attribute set to _false_ so it will be ignored . For each site backup, the following configuration attributes can be specified: 
+
+
+* strategy - the strategy used for backing up data, either "SYNC" or "ASYNC". Defaults to "ASYNC"
+
+
+* backupFailurePolicy - Decides what the system would do in case of failure during backup. Possible values are:
+
+
+* IGNORE - allow the local operation/transaction to succeed
+
+
+* WARN - same as IGNORE but also logs an warning message. Default.
+
+
+* FAIL - only in effect if "strategy" is "SYNC" - fails local cluster operation/transaction by throwing an exception to the user
+
+
+* CUSTOM - user provided, see "failurePolicyClass" below
+
+
+* failurePolicyClass - If the 'backupFailurePolicy' is set to 'CUSTOM' then this attribute is required and should contain the fully qualified name of a class implementing org.infinispan.xsite.CustomFailurePolicy
+
+
+* timeout - The timeout(milliseconds) to be used when backing up data remotely. Defaults to 10000 (10 seconds)
+
+The same setup can be achieved programatically:
+
+
+----
+
+ConfigurationBuilder lon = new ConfigurationBuilder();
+lon.sites().addBackup()
+      .site("NYC")
+      .backupFailurePolicy(BackupFailurePolicy.WARN)
+      .strategy(BackupConfiguration.BackupStrategy.SYNC)
+      .replicationTimeout(12000)
+      .sites().addInUseBackupSite("NYC")
+    .sites().addBackup()
+      .site("SFO")
+      .backupFailurePolicy(BackupFailurePolicy.IGNORE)
+      .strategy(BackupConfiguration.BackupStrategy.ASYNC)
+      .sites().addInUseBackupSite("SFO")
+
+----
+
+The "users" cache above doesn't know on which cache on the remote sites its data is being replicated. By default the remote site writes the backup data to a cache having the same name as the originator, i.e. "users". This behaviour can be overridden with an "backupFor" element. For example the following configuration in SFO makes the "usersLONBackup" cache act as the backup cache for the "users" cache defined above in the LON site:
+
+
+----
+
+<infinispan>
+  <namedCache name="usersLONBackup">
+    <sites>
+      <backupFor remoteCache="users" remoteSite="LON"/>
+    </sites>
+  </namedCache>
+</infinispan>
+
+----
+
+The same setup can be achieved programatically:
+
+
+----
+
+ConfigurationBuilder cb = new ConfigurationBuilder();
+cb.sites().backupFor().remoteCache("users").remoteSite("LON");
+
+----
+
+[[sid-68355118_Crosssitereplication-Localcluster%27sjgroups.xmlconfiguration]]
+
+
+==== Local cluster's jgroups .xml configuration
+
+This is the configuration file for the local (intra-site) infinispan cluster. It is referred from the infinispan configuration file, see "configurationFile" below:
+
+
+----
+
+<infinispan>
+..
+  <global>
+    <transport clusterName="infinispan-cluster">
+      <properties>
+        <property name="configurationFile" value="jgroups.xml"/>
+      </properties>
+    </transport>
+  </global>
+..
+</infinispan>
+
+----
+
+ In order to allow inter-site calls, the RELAY2 protocol needs to be added to the protocol stack defined in the jgroups configuration (see attached link:$$https://docs.jboss.org/author/download/attachments/68355118/jgroups.xml?version=1&amp;modificationDate=1348082252000$$[jgroups.xml] for an example). 
+
+[[sid-68355118_Crosssitereplication-RELAY2configurationfile]]
+
+
+==== RELAY2 configuration file
+
+ The RELAY2 configuration file is linked from the jgroups.xml (see attached link:$$https://docs.jboss.org/author/download/attachments/68355118/relay2.xml?version=1&amp;modificationDate=1348082291000$$[relay2.xml] ). It defines the sites seen by this cluster and also the jgroups configuration file that is used by RELAY2 in order to communicate with the remote sites. 
+
+[[sid-68355118_Crosssitereplication-Datareplication]]
+
+
+=== Data replication
+
+For both transactional and non-transactional caches, the backup calls are performed in parallel with local cluster calls, e.g. if we write data to node N1 in LON then replication to the local nodes N2 and N3 and remote backup sites SFO and NYC happen in parallel.
+
+[[sid-68355118_Crosssitereplication-Nontransactionalcaches]]
+
+
+==== Non transactional caches
+
+In the case of non-transactional caches the replication happens during each operation. Given that data is sent in parallel to backups and local caches, it is possible for the operations to succeed locally and fail remotely, or the other way, causing inconsistencies
+
+[[sid-68355118_Crosssitereplication-Transactionalcaches]]
+
+
+==== Transactional caches
+
+ For synchronous transactional caches, Infinispan internally uses a two phase commit protocol: lock acquisition during the 1st phase (prepare) and apply changes during the 2nd phase (commit). For asynchronous caches the two phases are merged, the "apply changes" message being sent asynchronously to the owners of data. This 2PC protocol maps to 2PC received from the JTA transaction manager. For transactional caches, both optimistic and pessimistic, the backup to remote sites happens during the prepare and commit phase only. 
+
+[[sid-68355118_Crosssitereplication-Synchronouslocalclusterwithasyncbackup]]
+
+
+===== Synchronous local cluster with async backup
+
+In this scenario the backup call happens during local commit phase(2nd phase). That means that if the local prepare fails, no remote data is being sent to the remote backup.
+
+[[sid-68355118_Crosssitereplication-Synchronouslocalclusterwithsyncbackup]]
+
+
+===== Synchronous local cluster with sync backup
+
+In this case there are two backup calls:
+
+
+* during prepare a message is sent across containing all the modifications that happened within this transaction
+
+
+* if the remote backup cache is transactional then a transaction is started remotely and all these modifications are being written within this transaction's scope. The transaction is not committed yet (see below)
+
+
+* if the remote backup cache is not transactional, then the changes are applied remotely
+
+
+* during the commit/rollback, a commit/rollback message is sent across
+
+
+* if the remote backups cache is transactional then the transaction started at the previous phase is committed/rolled back
+
+
+* if the remote backup is not transactional then this call is ignored
+
+Both the local and the backup call(if the "backupFailurePolicy" is set to "FAIL") can veto transaction's prepare outcome
+
+[[sid-68355118_Crosssitereplication-Asynchronouslocalcluster]]
+
+
+===== Asynchronous local cluster
+
+
+* In the case of asynchronous local clusters, the backup data is sent during the commit phase. If the backup call fails and the "backupFailurePolicy" is set to "FAIL" then the user is notified through an exception.
+
+[[sid-68355118_Crosssitereplication-Takingasiteoffline]]
+
+
+=== Taking a site offline
+
+If backing up to a site fails for a certain number of times during an time interval, then it is possible to automatically mark that site as offline. When a site is marked as offline the local site won't try to backup data to it anymore. In order to be taken online a system administrator intervention being required.
+
+[[sid-68355118_Crosssitereplication-Configuration]]
+
+
+==== Configuration
+
+The taking offline of a site can be configured as follows:
+
+
+----
+
+<namedCache name="bestEffortBackup">
+   ...
+    <sites>
+        <backups>
+           <backup site="NYC" strategy="SYNC" backupFailurePolicy="FAIL">
+               <takeOffline afterFailures="500" minTimeToWait="10000"/>
+           </backup>
+        </backups>
+    </sites>
+    ...
+</namedCache>
+
+----
+
+ The _takeOfline_ element under the _backup_ configures the taking offline of a site: * _afterFailure_ - the number of failed backup operations after which this site should be taken offline. Defaults to 0 (never). A negative value would mean that the site will be taken offline after _minTimeToWait_ * _minTimeToWait_ - the number of milliseconds in which a site is not marked offline even if it is unreachable for 'afterFailures' number of times. If smaller or equal to 0, then only _afterFailures_ is considered. 
+
+The equivalent programmatic configuration is:
+
+
+----
+
+lon.sites().addBackup()
+      .site("NYC")
+      .backupFailurePolicy(BackupFailurePolicy.FAIL)
+      .strategy(BackupConfiguration.BackupStrategy.SYNC)
+      .takeOffline()
+         .afterFailures(500)
+         .minTimeToWait(10000);
+
+----
+
+[[sid-68355118_Crosssitereplication-Takingasitebackonline]]
+
+
+==== Taking a site back online
+
+ In order to bring a site back online after being taken offline, one can use the JMX console and invoke the "bringSiteOnline(siteName)" operation on the _XSiteAdmin_ managed bean. At the moment this method would need to be invoked on all the nodes within the site(further releases will overcome this limitation). 
+
+[[sid-68355118_Crosssitereplication-Reference]]
+
+
+=== Reference
+
+ link:$$https://community.jboss.org/wiki/DesignForCrossSiteReplication$$[This document] (Sept 2012) describes the technical design of cross site replication in more detail. 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-66-Map_Reduce_framework.adoc b/documentation/src/main/asciidoc/user_guide/chapter-66-Map_Reduce_framework.adoc
new file mode 100644
index 0000000..a5b66ec
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-66-Map_Reduce_framework.adoc
@@ -0,0 +1,283 @@
+[[sid-68355120]]
+
+==  Map Reduce framework
+
+[[sid-68355120_MapReduceframework-Introduction]]
+
+
+=== Introduction
+
+ _MapReduce is a programming model allowing transparent distributed processing of very large data sets over data grids. The name MapReduce comes from an idea of using two distinct computational phases of map and reduce. In the map phase,_ _master node that initiates a task takes the task input, divides it and sends tasks for map phase execution on the grid. Each node in turns executes a map function on its input returning intermediate results back to master node._ _Master node_ _task collects all intermediate results from map phase combines them by intermediate result keys and sends intermediate keys/values for reduction on the grid. Finally master tasks node receives all results from reduction phases and returns the final result to invoker of the MapReduce task._ 
+
+[[sid-68355120_MapReduceframework-MapReduceAPI]]
+
+
+=== MapReduce API
+
+ Infinispan's own MapReduce model is an adaptation of Google's original link:$$http://research.google.com/archive/mapreduce.html$$[MapReduce] . There are four main components in each map reduce task: Mapper, Reducer, Collator and MapReduceTask. 
+
+Implementation of a Mapper class is a component of MapReduceTask invoked once for each input entry K,V. Every Mapper instance is migrated to an Infinispan node, given a cache entry K,V input pair which it transforms into an intermediate key/value pair emitted into Infinispan provided Collector instance. Intermediate results are further reduced using a Reducer.
+
+
+----
+
+public interface Mapper<KIn, VIn, KOut, VOut> extends Serializable {
+
+   /**
+    * Invoked once for each input cache entry KIn,VOut pair.
+    */
+   void map(KIn key, VIn value, Collector<KOut, VOut> collector);
+}
+
+----
+
+The Reducer, as its name implies, reduces a list of intermediate results from map phase of MapReduceTask. Infinispan distributed execution environment creates one instance of Reducer per execution node.
+
+
+----
+public interface Reducer<KOut, VOut> extends Serializable {
+
+   /**
+    * Combines/reduces all intermediate values for a particular intermediate key to a single value.
+    * <p>
+    *
+    */
+   VOut reduce(KOut reducedKey, Iterator<VOut> iter);
+
+}
+----
+
+Collator coordinates results from Reducers executed on Infinispan cluster and assembles a final result returned to an invoker of MapReduceTask. Collator is applied to final Map&lt;KOut,VOut&gt; result of MapReduceTask.
+
+
+----
+public interface Reducer<KOut, VOut> extends Serializable {
+
+   /**
+    * Combines/reduces all intermediate values for a particular intermediate key to a single value.
+    * <p>
+    *
+    */
+   VOut reduce(KOut reducedKey, Iterator<VOut> iter);
+
+}
+----
+
+ Finally, link:$$https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/distexec/mapreduce/MapReduceTask.java$$[MapReduceTask] is a distributed task unifying Mapper, Reducer and Collator into a cohesive large scale computation to be transparently parallelized across Infinispan cluster nodes. Users of MapReduceTask need to provide a cache whose data is used as input for this task. Infinispan execution environment will instantiate and migrate instances of provided mappers and reducers seamlessly across Infinispan nodes. Unless otherwise specified using onKeys method input keys filter all available key value pairs of a specified cache will be used as input data for this task. 
+
+[[sid-68355120_MapReduceframework-MapReducetasktimeout]]
+
+
+==== Map Reduce task timeout
+
+
+[NOTE]
+==== 
+The timeout per Map/Reduce task is only available for Infinispan 5.3.0.CR2 and higher.
+
+
+==== 
+
+
+ It is possible to set a timeout value for each Map/Reduce tasks. However, if no timeout is specified, it uses the replication timeout as a default timeout (the same behavior as the previous Infinispan versions). You can set the timeout in your task by doing the following: 
+
+
+----
+MapReduceTask task = new MapReduceTask(cache);
+task.timeout(1, TimeUnit.MINUTES);
+----
+
+Also, it is possible to know which is the current timeout value for the task:
+
+
+----
+System.out.println("Map/Reduce task timeout is " + task.timeout(TimeUnit.MILLISECONDS) + " millseconds"); 
+----
+
+ For more information about this, please check the java doc in link:$$http://docs.jboss.org/infinispan/5.3/apidocs/org/infinispan/distexec/mapreduce/MapReduceTask.html$$[Map Reduce Task API Documentation] 
+
+[[sid-68355120_MapReduceframework-MapperandCDI]]
+
+
+=== Mapper and CDI
+
+Although Mapper gets invoked with an appropriate input key/value pairs on an executing node, Infinispan also provides CDI injection of an input Cache in case users might need some additional data from input cache in order to complete map transformation. Upon arrival of user's Mapper to an Infinispan executing node, Infinispan CDI mechanism will provide appropriate cache reference and inject it to executing Mapper. All one has to do is to declare a Cache field in Mapper and annotate it with @org.infinispan.cdi.Input annotation along with the mandatory @Inject annotation.
+
+
+----
+public class WordCountCacheInjectedMapper implements Mapper<String, String, String, Integer> {
+
+      @Inject
+      @Input
+      private Cache<String, String> cache;
+
+      @Override
+      public void map(String key, String value, Collector<String, Integer> collector) {
+
+         //use injected cache if needed
+         StringTokenizer tokens = new StringTokenizer(value);
+         while (tokens.hasMoreElements()) {
+            String s = (String) tokens.nextElement();
+            collector.emit(s, 1);
+         }
+      }
+}
+----
+
+[[sid-68355120_MapReduceframework-MapReduceTaskdistributedexecution]]
+
+
+=== MapReduceTask distributed execution
+
+ _As our MapReduce implementation grew out of the proof of concept phase (and especially after our users had already production tested it), we needed to remove the most prominent impediment to an industrial grade MapReduce solution that we strive for: distributing reduce phase execution._ 
+
+ _Reduce phase prior to the Infinispan 5.2 release was done on a single Infinispan master task node. Therefore, the size of map reduce problems we could support (data size wise) was effectively shrunk to a working memory of a single Infinispan node. Starting with the Infinispan 5.2 release, we have removed this limitation, and reduce phase execution is distributed across the cluster as well. Of course, users still have an option to use MapReduceTask the old way, and we even recommend that particular approach for smaller sized input tasks. We have achieved distribution of reduce phase by relying on Infinispan's consistent hashing and DeltaAware cache insertion. Here is how we distributed reduce phase execution:_ 
+
+ _Map phase_ 
+
+ _MapReduceTask, as it currently does, will hash task input keys and group them by execution node N they are hashed to*. After key node mapping, MapReduceTask sends map function and input_ _keys to each node N. Map function is invoked using given keys and locally loaded corresponding values._ 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ _Results are collected with an Infinispan supplied Collector, and combine phase is initiated. A Combiner, if specified, takes KOut keys and immediately invokes reduce phase on keys. The result of mapping phase executed on each node is KOut/VOut map. There will be one resulting map per execution node N per launched MapReduceTask._ 
+
+ _Intermediate KOut/VOut migration phase_ 
+
+ _In order to proceed with reduce phase, all intermediate keys and values need to be grouped by intermediate KOut keys. More specifically, as map phases around the cluster can produce identical intermediate keys, all those identical intermediate keys and their values need to be grouped before reduce is executed on any particular intermediate key._ 
+
+ _Therefore at the end of combine phase, instead of returning map with intermediate keys and values to the master task node, we instead hash each intermediate key KOut and migrate it with its VOut values to Infinispan node where keys KOut are hashed to. We achieve this using a temporary DIST cache and underlying consistent hashing mechanism. Using DeltaAware cache_ _insertion_ _we effectively collect all VOut values under each KOut for all executed map functions across the cluster_ 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ _At this point, map and combine phase have finished its execution; list of KOut keys is returned to a master node and its initiating MapReduceTask. We do not return VOut values as we do not need them at master task node. MapReduceTask is ready to start with reduce phase._ 
+
+ _Reduce phase_ 
+
+ _Reduce phase is easy to accomplish now as Infinispan's consistent hashing already finished all the hard lifting for us. To complete reduce phase, MapReduceTask groups KOut keys by execution node N they are hashed to. For each node N and its grouped input KOut keys, MapReduceTask sends a reduce command to a node N where KOut keys are hashed. Once reduce command arrives on target execution node, it looks up temporary cache belonging to MapReduce task - and for each KOut key, grabs a list of VOut values, wraps it with an Iterator and invokes reduce on it._ 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ _A result of each reduce is a map where each key is KOut and value is VOut. Each Infinispan execution node N returns one map with KOut/VOut result values. As all initiated reduce commands return to a calling node, MapReduceTask simply combines all resulting maps into map M and returns M as a result of MapReduceTask._ 
+
+ _Distributed reduce phase is turned on by using a MapReduceTask_ link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/distexec/mapreduce/MapReduceTask.html#MapReduceTask(org.infinispan.Cache, boolean)$$[constructor] _specifying cache to use as input data for the task and boolean parameter distributeReducePhase set to true. Map/Reduce API_ link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/distexec/mapreduce/package-summary.html$$[javadoc] _and demos are included in distribution._ 
+
+[[sid-68355120_MapReduceframework-Examples]]
+
+
+=== Examples
+
+Word count is a classic, if not overused, example of map/reduce paradigm. Assume we have a mapping of key--&gt;sentence stored on Infinispan nodes. Key is a String, each sentence is also a String, and we have to count occurrence of all words in all sentences available. The implementation of such a distributed task could be defined as follows:
+
+
+----
+public class WordCountExample {
+
+   /**
+    * In this example replace c1 and c2 with
+    * real Cache references
+    *
+    * @param args
+    */
+   public static void main(String[] args) {
+      Cache c1 = null;
+      Cache c2 = null;
+
+      c1.put("1", "Hello world here I am");
+      c2.put("2", "Infinispan rules the world");
+      c1.put("3", "JUDCon is in Boston");
+      c2.put("4", "JBoss World is in Boston as well");
+      c1.put("12","JBoss Application Server");
+      c2.put("15", "Hello world");
+      c1.put("14", "Infinispan community");
+      c2.put("15", "Hello world");
+
+      c1.put("111", "Infinispan open source");
+      c2.put("112", "Boston is close to Toronto");
+      c1.put("113", "Toronto is a capital of Ontario");
+      c2.put("114", "JUDCon is cool");
+      c1.put("211", "JBoss World is awesome");
+      c2.put("212", "JBoss rules");
+      c1.put("213", "JBoss division of RedHat ");
+      c2.put("214", "RedHat community");
+
+      MapReduceTask<String, String, String, Integer> t =
+         new MapReduceTask<String, String, String, Integer>(c1);
+      t.mappedWith(new WordCountMapper())
+         .reducedWith(new WordCountReducer());
+      Map<String, Integer> wordCountMap = t.execute();
+   }
+
+   static class WordCountMapper implements Mapper<String,String,String,Integer> {
+      /** The serialVersionUID */
+      private static final long serialVersionUID = -5943370243108735560L;
+
+      @Override
+      public void map(String key, String value, Collector<String, Integer> c) {
+         StringTokenizer tokens = new StringTokenizer(value);
+         while (tokens.hasMoreElements()) {
+            String s = (String) tokens.nextElement();
+            c.emit(s, 1);
+         }
+      }
+   }
+
+   static class WordCountReducer implements Reducer<String, Integer> {
+      /** The serialVersionUID */
+      private static final long serialVersionUID = 1901016598354633256L;
+
+      @Override
+      public Integer reduce(String key, Iterator<Integer> iter) {
+         int sum = 0;
+         while (iter.hasNext()) {
+            Integer i = (Integer) iter.next();
+            sum += i;
+         }
+         return sum;
+      }
+   }
+}
+
+----
+
+As we have seen it is relatively easy to specify map reduce task counting number of occurrences for each word in all sentences. Best of all result is returned to task invoker in the form of Map&lt;KOut,VOut&gt; rather than being written to a stream.
+
+What if we need to find the most frequent word in our word count example? All we have to do is to define a Collator that will transform the result of MapReduceTask Map&lt;KOut,VOut&gt; into a String which in turn is returned to a task invoker. We can think of Collator as transformation function applied to a final result of MapReduceTask.
+
+
+----
+MapReduceTask<String, String, String, Integer> t = new MapReduceTask<String, String, String, Integer>(cache);
+t.mappedWith(new WordCountMapper()).reducedWith(new WordCountReducer());
+String mostFrequentWord = t.execute(
+      new Collator<String,Integer,String>() {
+
+         @Override
+         public String collate(Map<String, Integer> reducedResults) {
+            String mostFrequent = "";
+            int maxCount = 0;
+            for (Entry<String, Integer> e : reducedResults.entrySet()) {
+               Integer count = e.getValue();
+               if(count > maxCount) {
+                  maxCount = count;
+                  mostFrequent = e.getKey();
+               }
+            }
+         return mostFrequent;
+         }
+
+      });
+System.out.println("The most frequent word is " + mostFrequentWord);
+
+----
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-67-Rolling_upgrades.adoc b/documentation/src/main/asciidoc/user_guide/chapter-67-Rolling_upgrades.adoc
new file mode 100644
index 0000000..2b17dfc
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-67-Rolling_upgrades.adoc
@@ -0,0 +1,61 @@
+[[sid-68355121]]
+
+==  Rolling upgrades
+
+ This process is used for  installations making use of Infinispan as a remote grid, via Hot Rod.   This assumes an upgrade of the Infinispan grid, and _not_ the client application. 
+
+In  the following description we will refer to the Source and Target  clusters, where the Source cluster is the old cluster which is currently  in use and the Target cluster is the new cluster to which the data will  be migrated to.
+
+[[sid-68355121_Rollingupgrades-Steps]]
+
+
+=== Steps
+
+
+.  Start a new cluster ( _Target Cluster_ ) with the new version of Infinispan, using either different network settings or JGroups cluster name so that the old cluster ( _Source Cluster_ ) and the new one don't overlap. 
+
+
+.  For each cache to be migrated, the _Target Cluster_ is configured with a RemoteCacheStore with the following settings: 
+
+
+.  _servers_ should point to the _Source Cluster_ 
+
+
+.  _remoteCacheName_ must coincide with the name of the cache on the _Source Cluster_ 
+
+
+.  _hotRodWrapping_ must be enabled ( _true_ ) 
+
+
+.  Configure clients to point to the _Target Cluster_ instead of the _Source Cluster_ , and one by one, restart each client node.  Gradually, all requests will be handled by the _Target Cluster_ rather than the _Source Cluster_ . The _Target Cluster_ will lazily load data from the _Source Cluster_ on demand via the RemoteCacheStore. 
+
+
+.  Once all connections have switched to using the _Target Cluster_ the keyset on the _Source Cluster_ must be dumped. This can be achieved either via a JMX operation or via the CLI: 
+
+
+.  JMX: invoke the _recordKnownGlobalKeyset_ operation on the _RollingUpgradeManager_ MBean on the _Source Cluster_ for all of the caches that need to be migrated 
+
+
+.  CLI: invoke the _upgrade --dumpkeys_ command on the _Source Cluster_ for all of the caches that need to be migrated (additionally the _--all_ switch can be used to dump all caches in the cluster) 
+
+
+.  At this point the _Target Cluster_ needs to fetch all remaining data from the _Source Cluster_ : 
+
+
+.  JMX: invoke the _synchronizeData_ operation specifying the "hotrod" parameter on the _RollingUpgradeManager_ MBean on the _Target Cluster_ for all of the caches that need to be migrated 
+
+
+.  CLI: invoke the _upgrade --synchronize=hotrod_ command on the _Target Cluster_ for all of the caches that need to be migrated (additionally the _--all_ switch can be used to synchronize all caches in the cluster) 
+
+
+.  Once the above operation is complete, the _RemoteCacheStore_ on the _Target Cluster_ must be disabled as follows: 
+
+
+.  JMX: invoke the _disconnectSource_ operation specifying the "hotrod" parameter on the _RollingUpgradeManager_ MBean on the _Target Cluster_ for all of the caches that have been migrated 
+
+
+.  CLI: invoke the _upgrade --disconnectsource=hotrod_ command on the _Target Cluster_ for all of the caches that have been migrated (additionally the _--all_ switch can be used to disconnect all caches in the cluster) 
+
+
+.  The _Source Cluster_ can be decomissioned now. 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-68-Command_Line_Interface_CLI_.adoc b/documentation/src/main/asciidoc/user_guide/chapter-68-Command_Line_Interface_CLI_.adoc
new file mode 100644
index 0000000..cea1d51
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-68-Command_Line_Interface_CLI_.adoc
@@ -0,0 +1,482 @@
+[[sid-68355122]]
+
+==  Command-Line Interface (CLI)
+
+Infinispan offers a simple Command-Line Interface (CLI) with which it is possible to interact with the data within the caches and with most of the internal components (e.g. transactions, cross-site backups, rolling upgrades).
+
+ The CLI is built out of two elements: a server-side module and the  client command tool. The server-side module (infinispan-cli-server-$VERSION.jar) provides  the actual interpreter for the commands and needs to be included alongside your application. If you are using the _startServer.[sh.bat]_ script it is included by default. 
+
+Currently the server (and the  client) use the JMX protocol to communicate, but in a future release we  plan to support other communication protocols (in particular our own  HotRod).
+
+ The CLI offers both an interactive and a batch mode. To invoke the client, just run the provided _bin/ispn-cli.[sh|bat]_ script. The following is a list of command-line switches which affect how the CLI can be started: 
+
+
+----
+-c, --connect=URL       connects to a running instance of Infinispan.
+                        JMX over RMI jmx://[username[:password]]@host:port[/container[/cache]]
+                        JMX over JBoss remoting remoting://[username[:password]]@host:port[/container[/cache]]
+-f, --file=FILE         reads input from the specified file instead of using                          
+                        interactive mode. If FILE is '-', then commands will be read
+                        from stdin
+-h, --help              shows this help page 
+-v, --version           shows version information
+----
+
+ * JMX over RMI is the traditional way in which JMX clients connect to MBeanServers. Please refer to the link:$$http://docs.oracle.com/javase/6/docs/technotes/guides/management/agent.html$$[JDK Monitoring and Management] documentation for details on how to configure the process to be monitored 
+
+
+* JMX over JBoss Remoting is the protocol of choice when your Infinispan application is running within JBoss AS7 or EAP6.
+
+The connection to the application can also be initiated from within the CLI using the connect command.
+
+
+----
+[disconnected//]> connect jmx://localhost:12000
+[jmx://localhost:12000/MyCacheManager/>
+----
+
+ The CLI prompt will show the active connection information, including the currently selected CacheManager. Initially no cache is selected so, before performing any cache operations, one must be selected. For this the _cache_ command is used. The CLI supports tab-completion for all commands and options and for most parameters where it makes sense to do so. Therefore typing _cache_ and pressing TAB will show a list of active caches: 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/> cache
+___defaultcache  namedCache
+[jmx://localhost:12000/MyCacheManager/]> cache ___defaultcache
+[jmx://localhost:12000/MyCacheManager/___defaultcache]>
+----
+
+Pressing TAB at an empty prompt will show the list of all available commands:
+
+
+----
+alias       cache       container   encoding    get         locate      remove      site        upgrade     
+abort       clear       create      end         help        put         replace     start       version     
+begin       commit      disconnect  evict       info        quit        rollback    stats     
+----
+
+ The CLI is based on link:$$https://github.com/aeshell/aesh$$[Æsh] and therefore offers many keyboard shortcuts to navigate and search the history of commands, to manipulate the cursor at the prompt, including both Emacs and VI modes of operation. 
+
+[[sid-68355122_Command-LineInterface%28CLI%29-Commands]]
+
+
+=== Commands
+
+[[sid-68355122_Command-LineInterface%28CLI%29-]]
+
+
+==== 
+
+
+----
+
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-abort]]
+
+
+==== abort
+
+ The _abort_ command is used to abort a running batch initiated by the _start_ command 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> start
+[jmx://localhost:12000/MyCacheManager/namedCache]> put a a
+[jmx://localhost:12000/MyCacheManager/namedCache]> abort
+[jmx://localhost:12000/MyCacheManager/namedCache]> get a
+null
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-begin]]
+
+
+==== begin
+
+ The _begin_ command starts a transaction. In order for this command to work, the cache(s) on which the subsequent operations are invoked must have transactions enabled. 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> begin
+[jmx://localhost:12000/MyCacheManager/namedCache]> put a a
+[jmx://localhost:12000/MyCacheManager/namedCache]> put b b
+[jmx://localhost:12000/MyCacheManager/namedCache]> commit
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-cache]]
+
+
+==== cache
+
+ The _cache_ command selects the cache to use as default for all subsequent operations. If it is invoked without parameters it shows the currently selected cache. 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> cache ___defaultcache
+[jmx://localhost:12000/MyCacheManager/___defaultcache]> cache
+___defaultcache
+[jmx://localhost:12000/MyCacheManager/___defaultcache]>
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-clear]]
+
+
+==== clear
+
+ The _clear_ command clears a cache from all content. 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> put a a
+[jmx://localhost:12000/MyCacheManager/namedCache]> clear
+[jmx://localhost:12000/MyCacheManager/namedCache]> get a
+null
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-commit]]
+
+
+==== commit
+
+ The _commit_ command commits an ongoing transaction 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> begin
+[jmx://localhost:12000/MyCacheManager/namedCache]> put a a
+[jmx://localhost:12000/MyCacheManager/namedCache]> put b b
+[jmx://localhost:12000/MyCacheManager/namedCache]> commit
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-container]]
+
+
+==== container
+
+ The _container_ command selects the default container (cache manager). Invoked without parameters it lists all available containers 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> container
+MyCacheManager OtherCacheManager
+[jmx://localhost:12000/MyCacheManager/namedCache]> container OtherCacheManager
+[jmx://localhost:12000/OtherCacheManager/]>
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-create]]
+
+
+==== create
+
+ The _create_ command creates a new cache based on the configuration of an existing cache definition 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> create newCache like namedCache
+[jmx://localhost:12000/MyCacheManager/namedCache]> cache newCache
+[jmx://localhost:12000/MyCacheManager/newCache]>
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-disconnect]]
+
+
+==== disconnect
+
+ The _disconnect_ command disconnects the currently active connection allowing the CLI to connect to another instance. 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> disconnect
+[disconnected//]
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-encoding]]
+
+
+==== encoding
+
+ The _encoding_ command is used to set a default codec to use when reading/writing entries from/to a cache. When invoked without arguments it shows the currently selected codec. This command is useful since currently remote protocols such as HotRod and Memcached wrap keys and values in specialized structures. 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> encoding
+none
+[jmx://localhost:12000/MyCacheManager/namedCache]> encoding --list
+memcached
+hotrod
+none
+rest
+[jmx://localhost:12000/MyCacheManager/namedCache]> encoding hotrod
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-end]]
+
+
+==== end
+
+ The _end_ command is used to successfully end a running batch initiated by the _start_ command 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> start
+[jmx://localhost:12000/MyCacheManager/namedCache]> put a a
+[jmx://localhost:12000/MyCacheManager/namedCache]> end
+[jmx://localhost:12000/MyCacheManager/namedCache]> get a
+a
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-evict]]
+
+
+==== evict
+
+ The _evict_ command is used to evict from the cache the entry associated with a specific key. 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> put a a
+[jmx://localhost:12000/MyCacheManager/namedCache]> evict a
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-get]]
+
+
+==== get
+
+ The _get_ command is used to show the value associated to a specified key. For primitive types and Strings, the _get_ command will simply print the default representation. For other objects, a JSON representation of the object will be printed. 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> put a a
+[jmx://localhost:12000/MyCacheManager/namedCache]> get a
+a
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-info]]
+
+
+==== info
+
+ The _info_ command is used to show the configuration of the currently selected cache or container. 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> info
+GlobalConfiguration{asyncListenerExecutor=ExecutorFactoryConfiguration{factory=org.infinispan.executors.DefaultExecutorFactory@98add58}, asyncTransportExecutor=ExecutorFactoryConfiguration{factory=org.infinispan.executors.DefaultExecutorFactory@7bc9c14c}, evictionScheduledExecutor=ScheduledExecutorFactoryConfiguration{factory=org.infinispan.executors.DefaultScheduledExecutorFactory@7ab1a411}, replicationQueueScheduledExecutor=ScheduledExecutorFactoryConfiguration{factory=org.infinispan.executors.DefaultScheduledExecutorFactory@248a9705}, globalJmxStatistics=GlobalJmxStatisticsConfiguration{allowDuplicateDomains=true, enabled=true, jmxDomain='jboss.infinispan', mBeanServerLookup=org.jboss.as.clustering.infinispan.MBeanServerProvider@6c0dc01, cacheManagerName='local', properties={}}, transport=TransportConfiguration{clusterName='ISPN', machineId='null', rackId='null', siteId='null', strictPeerToPeer=false, distributedSyncTimeout=240000, transport=null, nodeName='null', properties={}}, serialization=SerializationConfiguration{advancedExternalizers={1100=org.infinispan.server.core.CacheValue$Externalizer@5fabc91d, 1101=org.infinispan.server.memcached.MemcachedValue$Externalizer@720bffd, 1104=org.infinispan.server.hotrod.ServerAddress$Externalizer@771c7eb2}, marshaller=org.infinispan.marshall.VersionAwareMarshaller@6fc21535, version=52, classResolver=org.jboss.marshalling.ModularClassResolver@2efe83e5}, shutdown=ShutdownConfiguration{hookBehavior=DONT_REGISTER}, modules={}, site=SiteConfiguration{localSite='null'}}
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-locate]]
+
+
+==== locate
+
+ The _locate_ command shows the physical location of a specified entry in a distributed cluster. 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> locate a
+[host/node1,host/node2]
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-put]]
+
+
+==== put
+
+ The _put_ command inserts an entry in the cache. If the cache previously contained a mapping for the key, the old value is replaced by the specified value. The user can control the type of data that the CLI will use to store the key and value. See the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=61505925_Command-LineInterface%28CLI%29-DataTypes$$[Data Types] paragraph. 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> put a a
+[jmx://localhost:12000/MyCacheManager/namedCache]> put b 100
+[jmx://localhost:12000/MyCacheManager/namedCache]> put c 4139l
+[jmx://localhost:12000/MyCacheManager/namedCache]> put d true
+[jmx://localhost:12000/MyCacheManager/namedCache]> put e { "package.MyClass": {"i": 5, "x": null, "b": true } }
+----
+
+The put command can optionally specify a lifespan and a maximum idle time.
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> put a a expires 10s
+[jmx://localhost:12000/MyCacheManager/namedCache]> put a a expires 10m maxidle 1m
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-replace]]
+
+
+==== replace
+
+ The _replace_ command replaces an existing entry in the cache. If an old value is specified, then the replacement happens only if the value in the cache coincides. 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> put a a
+[jmx://localhost:12000/MyCacheManager/namedCache]> replace a b
+[jmx://localhost:12000/MyCacheManager/namedCache]> get a
+b
+[jmx://localhost:12000/MyCacheManager/namedCache]> replace a b c
+[jmx://localhost:12000/MyCacheManager/namedCache]> get a
+c
+[jmx://localhost:12000/MyCacheManager/namedCache]> replace a b d
+[jmx://localhost:12000/MyCacheManager/namedCache]> get a
+c
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-rollback]]
+
+
+==== rollback
+
+ The _rollback_ command rolls back an ongoing transaction 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> begin
+[jmx://localhost:12000/MyCacheManager/namedCache]> put a a
+[jmx://localhost:12000/MyCacheManager/namedCache]> put b b
+[jmx://localhost:12000/MyCacheManager/namedCache]> rollback
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-site]]
+
+
+==== site
+
+ The _site_ command performs operations related to the administration of cross-site replication. It can be used to obtain information related to the status of a site and to change the status (online/offline) 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> site --status NYC
+online
+[jmx://localhost:12000/MyCacheManager/namedCache]> site --offline NYC
+ok
+[jmx://localhost:12000/MyCacheManager/namedCache]> site --status NYC
+offline
+[jmx://localhost:12000/MyCacheManager/namedCache]> site --online NYC
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-start]]
+
+
+==== start
+
+ The _start_ command initiates a batch of operations. 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> start
+[jmx://localhost:12000/MyCacheManager/namedCache]> put a a
+[jmx://localhost:12000/MyCacheManager/namedCache]> put b b
+[jmx://localhost:12000/MyCacheManager/namedCache]> end
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-stats]]
+
+
+==== stats
+
+ The _stats_ command displays statistics about a cache 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> stats
+Statistics: {
+  averageWriteTime: 143
+  evictions: 10
+  misses: 5
+  hitRatio: 1.0
+  readWriteRatio: 10.0
+  removeMisses: 0
+  timeSinceReset: 2123
+  statisticsEnabled: true
+  stores: 100
+  elapsedTime: 93
+  averageReadTime: 14
+  removeHits: 0
+  numberOfEntries: 100
+  hits: 1000
+}
+LockManager: {
+  concurrencyLevel: 1000
+  numberOfLocksAvailable: 0
+  numberOfLocksHeld: 0
+}
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-upgrade]]
+
+
+==== upgrade
+
+ The _ugrade_ command performs operations used during the rolling upgrade procedure. For a detailed description of this procedure please see link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=60227604$$[Rolling upgrades] 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> upgrade --synchronize=hotrod --all
+[jmx://localhost:12000/MyCacheManager/namedCache]> upgrade --disconnectsource=hotrod --all
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-version]]
+
+
+==== version
+
+ The _version_ command displays version information about both the CLI client and the server 
+
+
+----
+[jmx://localhost:12000/MyCacheManager/namedCache]> version
+Client Version 5.2.1.Final
+Server Version 5.2.1.Final
+----
+
+[[sid-68355122_Command-LineInterface%28CLI%29-DataTypes]]
+
+
+=== Data Types
+
+[[sid-68355122_Command-LineInterface%28CLI%29-DataTypesx]]
+
+
+The CLI understands the following types:
+
+
+*  string strings can either be quoted between single (') or double (") quotes, or left unquoted. In this case it must not contain spaces, punctuation and cannot begin with a number  e.g. 'a string', key001 
+
+
+*  int an integer is identified by a sequence of decimal digits, e.g. 256 
+
+
+*  long a long is identified by a sequence of decimal digits suffixed by 'l', e.g. 1000l 
+
+
+* double
+
+
+* a double precision number is identified by a floating point number(with optional exponent part) and an optional 'd' suffix, e.g.3.14
+
+
+* float
+
+
+* a single precision number is identified by a floating point number(with optional exponent part) and an 'f' suffix, e.g. 10.3f
+
+
+*  boolean a boolean is represented either by the keywords true and false 
+
+
+*  UUID a UUID is represented by its canonical form XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX 
+
+
+*  JSON serialized Java classes can be represented using JSON notation, e.g. {"package.MyClass":{"i":5,"x":null,"b":true}}. Please note that the specified class must be available to the CacheManager's class loader. 
+
+[[sid-68355122_Command-LineInterface%28CLI%29-TimeValues]]
+
+
+=== Time Values
+
+[[sid-68355122_Command-LineInterface%28CLI%29-TimeValuesx]]
+
+
+A time value is an integer number followed by time unit suffix: days (d), hours (h), minutes (m), seconds (s), milliseconds (ms).
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-69-Total_Order_based_commit_protocol.adoc b/documentation/src/main/asciidoc/user_guide/chapter-69-Total_Order_based_commit_protocol.adoc
new file mode 100644
index 0000000..754266d
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-69-Total_Order_based_commit_protocol.adoc
@@ -0,0 +1,311 @@
+[[sid-68355123]]
+
+==  Total Order based commit protocol
+
+[[sid-68355123_TotalOrderbasedcommitprotocol-Introduction]]
+
+
+=== Introduction
+
+ _The Total Order based protocol is a multi-master scheme (in this context, multi-master scheme means that all nodes can update all the data) as the (optimistic/pessimist) locking model implemented in Infinispan. This commit protocol relies on the concept of totally ordered delivery of messages which, informally, implies that each node which delivers a set of messages, delivers them in the same order._ 
+
+This protocol comes with this advantages.
+
+
+. transactions can be committed in one phase, as they are delivered in the same order by the nodes that receive them.
+
+
+. it mitigates distributed deadlocks.
+
+The weaknesses of this approach are the fact that its implementation relies on a single thread per node which delivers the transaction and its modification, and the slightly higher number of messages exchanged by JGroups.
+
+ Thus, this protocol delivers best performance in scenarios of _high contention_ , in which it can benefit from the single-phase commit and the deliver thread is not the bottleneck. 
+
+ Currently, the Total Order based protocol is available only in _transactional_ caches for _replicated_ and _distributed_ modes. 
+
+[[sid-68355123_TotalOrderbasedcommitprotocol-Overview]]
+
+
+=== Overview
+
+ The Total Order based commit protocol only affects how transactions are committed and it depends of the isolation level configured, more precisely the _write skew check_ . Note that it only provides the _same isolation levels_ as the locking model, i.e. _read-committed_ and _repeatable-read_ . If the write skew check is not enabled, then all the transaction are committed in one phase (independently if Infinispan is enlisted as _Synchronization_ or _XaResource_ ). In this case, the isolation level is not violated because it is ensured during the transaction execution. Also the transactions always commit successfully because they do not need to perform any validation in prepare phase. 
+
+ On other hand, when write skew check is enabled, the protocol adapts using one phase commit when it is safe. However, if Infinispan is enlisted as _Synchronization_ , it always commit in two phases, because the _Transaction Manager_ does not provide any information if Infinispan is the only resource enlisted or not. In _XaResource_ enlistment, we can use one phase if the _Transaction Manager_ request a commit in one phase (i.e. one-phase optimization, usually used when the transaction has a single _XaResource_ registered, see link:$$http://docs.jboss.org/jbossas/javadoc/4.0.5/j2ee/javax/transaction/xa/XAResource.html#commit(javax.transaction.xa.Xid, boolean)$$[XaResource.commit()] ) and the Infinispan cache is configured in replicated mode or in distributed mode (the last one, when the _writeSkew==false_ ). This optimization is not safe in distributed mode when _writeSkew==true_ because each node performs the validation in different keys subset. 
+
+[[sid-68355123_TotalOrderbasedcommitprotocol-Commitinonephase]]
+
+
+==== Commit in one phase
+
+ When the transaction ends, Infinispan sends the transaction (and its modification) in total order. This ensures all the transactions are deliver in the same order in all the involved Infinispan nodes. As a result, when a transaction is delivered, it performs a deterministic validation over the same state, leading to the same outcome (transaction commit or rollback). Also, if the transactional mode is configured with _syncCommitPhase==false_ , the node that sent the transaction still needs to wait for the self-deliver of the transaction because it needs to know the transaction outcome. In other hand, it does not need to wait for the replies from other nodes because they will reply with the same outcome. Although, if _syncCommitPhase==true_ , it needs to wait for the replies in order to respect the semantic of the flag. 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ The figure above demonstrates a high level example with 3 nodes. _Node1_ and _Node3_ are running one transaction each and lets assume that both transaction writes on the same key. To make it more interesting, lets assume that both nodes tries to commit at the same time, represented by the first colored circle in the figure. The _blue_ circle represents the transaction _tx1_ and the _green_ the transaction _tx2_ . Both nodes do a remote invocation in total order ( _to-send_ ) with the transaction's modifications. At this moment, all the nodes will agree in the same deliver order, for example, _tx1_ followed by _tx2_ . Then, each node delivers _tx1_ , perform the validation and commits the modifications. The same steps are performed for _tx2_ but, in this case, the validation will fail and the transaction is rollback in all the involved nodes. 
+
+[[sid-68355123_TotalOrderbasedcommitprotocol-Commitintwophases]]
+
+
+==== Commit in two phases
+
+ The first phase is the same as described above except that the nodes will not apply the modifications after the validation, including the modifications sent in total order and the same scheme to wait for the replies. As soon as it has the confirmation that all keys are successfully validated, it give a positive response to the _Transaction Manager_ (remember that the _Transaction Manager_ is responsive to invoke the _prepare()_ of the transaction). On other hand, if it receives a negative reply, it returns a negative response to the _Transaction Manager_ . Finally, the transaction is committed or aborted in the second phase depending of the _Transaction Manager_ . 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ The figure above shows the scenario described in the first figure but now committing the transactions using two phases. When _tx1_ is deliver, it performs the validation and it replies to the _Transaction Manager_ . Next, lets assume that _tx2_ is deliver before the _Transaction Manager_ request the second phase for _tx1_ . In this case, _tx2_ will be enqueued and it will be validated only when _tx1_ is completed. Eventually, the _Transaction Manager_ for _tx1_ will request the second phase (the commit) and all the nodes are free to perform the validation of _tx2_ . 
+
+[[sid-68355123_TotalOrderbasedcommitprotocol-TransactionRecovery]]
+
+
+==== Transaction Recovery
+
+ link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737124$$[Transaction Recovery] is currently not available for Total Order based commit protocol 
+
+[[sid-68355123_TotalOrderbasedcommitprotocol-Totalorderexecutorservice]]
+
+
+==== Total order executor service
+
+ As previous said, only one thread is delivering the transactions, which makes this thread a possible bottleneck of the system. Although, only conflicting transactions (i.e. which the write set intercepts) needs to be validated in order. For example, if a node delivers _tx1(write(A))_ , _tx2(write(A))_ and _tx3(write(B))_ , _tx2_ must wait until the _tx1_ is completed, but _tx3_ can be validated concurrently with _tx1_ and _tx2_ . After analyzing the transaction dependencies, is possible to enqueue the transactions that conflicts to non-completed transactions and move to a executor service the transaction that can be concurrently validated. 
+
+
+[WARNING]
+.Warning
+==== 
+ The total order executor service needs an _ExecutorService_ (see the Configuration section). Please make sure that the _ExecutorService_ _does not reject tasks_ otherwise your data becomes _inconsistent_ . 
+
+
+==== 
+
+
+[[sid-68355123_TotalOrderbasedcommitprotocol-StateTransfer]]
+
+
+==== State Transfer
+
+For simplicity reasons, the total order based commit protocol uses a blocking version of the current state transfer. The main differences are:
+
+
+. enqueue the transaction deliver while the state transfer is in progress;
+
+
+.  the state transfer control messages ( _CacheTopologyControlCommand_ ) are sent in total order. 
+
+This way, it provides a synchronization between the state transfer and the transactions deliver that is the same all the nodes. Although, the transactions caught in the middle of state transfer (i.e. sent before the state transfer start and deliver after it) needs to be re-sent to find a new total order involving the new joiners.
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ The figure above describes a node joining. In the scenario, the _tx2_ is sent in _topologyId=1_ but when it is received, it is in _topologyId=2_ . So, the transaction is re-sent involving the new nodes. 
+
+[[sid-68355123_TotalOrderbasedcommitprotocol-Configuration]]
+
+
+=== Configuration
+
+To use Total Order based commit protocol in your Infinispan cache, you need to configure a couple of thing:
+
+
+* add the total order protocols in JGroups configuration file:
+
+
+----
+
+<SEQUENCER />
+<tom.TOA />
+
+----
+
+ Check the JGroups manual for more detail in here: link:$$http://jgroups.org/manual-3.x/html/index.html$$[JGroups Manual] 
+
+
+* configure the Infinispan cache as a transactional cache and set the transaction protocol to total order:
+
+
+----
+
+<namedCache >
+  <transaction
+    transactionMode="TRANSACTIONAL"
+    transactionProtocol="TOTAL_ORDER" />
+</namedCache>
+
+----
+
+You can build the same configuration programmatically in the following way:
+
+
+----
+
+ConfigurationBuilder cb = new ConfigurationBuilder();
+cb.transaction().transactionMode(TransactionMode.TRANSACTIONAL).transactionProtocol(TransactionProtocol.TOTAL_ORDER);
+
+----
+
+ Optionally, you can configure the total order executor to use your own executor services. By default, it creates an executor service with _coreThreads=1_ and _maxThreads=32_ . It can be configured in the following way: 
+
+
+----
+
+<global>
+  <totalOrderExecutor factory="org.infinispan.executor.DefaultExecutorFactory>
+    <property name="coreThreads" value="1" />
+    <property name="maxThreads" value="32" />
+  </totalOrderExecutor>
+</global>
+
+----
+
+or programmaticaly:
+
+
+----
+
+GlobalConfigurationBuilder gcb = new GlobalConfigurationBuilder();
+gcb.totalOrderExectutor().factory(new DefaultExecutorFactory()).addProperty("coreThread", "1").addProperty("maxThreads", "32");
+
+----
+
+ Beside the _coreThreads_ and the _maxThreads_ , the _DefaultExecutorFactory_ also accepts as properties as the _queueSize_ , _keepAliveTime_ (in milliseconds), _threadPriority_ , _threadNamePrefix_ and _threadNameSuffix_ . Note that, this parameters are used by the _ExecutorService_ . The total order executor uses an unbouded queue. Also, when you provide an _ExecutorService_ , make sure that _it will no reject tasks_ , otherwise your data can became _inconsistent_ . 
+
+[[sid-68355123_TotalOrderbasedcommitprotocol-TotalOrderprotocolsinJGroups.]]
+
+
+=== Total Order protocols in JGroups.
+
+[[sid-68355123_TotalOrderbasedcommitprotocol-SEQUENCER]]
+
+
+==== SEQUENCER
+
+ The _SEQUENCER_ protocol ensures total order involving all the members in the cluster. It is a sequencer-based implementation in which the sender forwards the messages to a sequencer (the current cluster coordinator), and the sequencer sends it back to the cluster on behalf of the original sender. Because it is always the same sender (whose messages are delivered in FIFO order), a global (or total) order is established. 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ The figure above shows the the communication steps to total order broadcast two messages _M1_ and _M2_ from different senders. Below, the figure shows the communication steps needed to commit a single transaction, when two phase are used. The dotted line represents the communications steps performed by the _SEQUENCER_ . As it is possible to see, ensure total order is not a cheap operation and it has a cost of an extra communication step comparing with the lock based implementation. 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ More information about the _SEQUENCER_ in JGroups manual: link:$$http://jgroups.org/manual-3.x/html/protlist.html#SEQUENCER$$[SEQUENCER - JGroups Manual page] 
+
+[[sid-68355123_TotalOrderbasedcommitprotocol-TOATotalOrderAnycast]]
+
+
+==== TOA - Total Order Anycast
+
+ The _TOA_ protocol is implemented based on the Skeen Algorithm. Each node has an ordered (by the message logical clock) queue with the messages and a local logical clock and it works in a centralized way. The sender sends _N_ unicast messages with the data to all destination nodes. When the message is received, each replica increments it logical clock and it sends back the value to the sender. Meanwhile, the message is put on the queue with the value of logical clock and marked as _temporary_ . The sender collects all values and calculates the maximum value of them. Finally it sends other _N_ unicast message with the final value of the message. This number indicates the final order number of deliver for the message. Each replica updates it logical clock, if the value is lower than the final value received, and updates the message in the queue, re-ordered if necessary. Then the message is marked as _final_ . The messages are delivered when it is on the top of the queue and is _final_ . The figure below explains in a graphical way how it is done. 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ The next figure show one transaction to be committed in detail, including all the communication steps. The dotted line represents the messages exchanged by _TOA_ and the solid lines a single unicast message. This figure shows that the total order protocol has 2 more communications steps than the lock based implementation. 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ More information about the Total Order Anycast in JGroups manual: link:$$http://jgroups.org/manual-3.x/html/protlist.html#TOA$$[TOA - JGroups Manual page] 
+
+[[sid-68355123_TotalOrderbasedcommitprotocol-Benchmarkresults]]
+
+
+=== Benchmark results
+
+ In order to compare the performance of total order with the locking model, link:$$https://github.com/radargun/radargun/wiki$$[RadarGun] was used to perform a benchmark evaluation in two different scenarios: a _no contention_ scenario and a _contention_ scenario. 
+
+The Infinispan configuration used is:
+
+
+----
+
+<?xml version="1.0" encoding="UTF-8"?>
+<infinispan xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:infinispan:config:5.3">
+    <global>
+        <transport clusterName="x">
+            <properties>
+                <property name="configurationFile" value="jgroups/jgroups.xml"/>
+            </properties>
+        </transport>
+    </global>
+    <default>
+        <transaction
+                transactionManagerLookupClass="org.infinispan.transaction.lookup.GenericTransactionManagerLookup"
+                transactionMode="TRANSACTIONAL"
+                transactionProtocol="TOTAL_ORDER"> <!-- transactionProtocol="DEFAULT" for the locking model -->
+            <recovery enabled="false"/>
+        </transaction>
+
+        <locking concurrencyLevel="1000" useLockStriping="false" isolationLevel="REPEATABLE_READ" writeSkewCheck="true"/> <!-- writeSkewCheck="false" for the no write skew experiments -->
+        <clustering mode="r"> <!-- mode="d" for distributed mode -->
+            <sync replTimeout="10000"/>
+            <stateTransfer fetchInMemoryState="false"/>
+            <hash numOwners="2" /> <!-- for distributed mode only -->
+        </clustering>
+    </default>
+    <namedCache name="testCache"/>
+</infinispan>
+
+----
+
+and the benchmark configuration is:
+
+
+----
+
+...
+    <benchmark initSize="2" maxSize="${10:slaves}" increment="2">
+        <DestroyWrapper runOnAllSlaves="true"/>
+        <StartCluster staggerSlaveStartup="true" delayAfterFirstSlaveStarts="5000" delayBetweenStartingSlaves="500"/>
+        <ClusterValidation partialReplication="false"/>
+        <StressTestWarmup duration="1m" opsCountStatusLog="5000" numThreads="8" transactionSize="10"
+                          useTransactions="true" writePercentage="50" numEntries="1000" sharedKeys="false"/>
+        <StressTest duration="5m" opsCountStatusLog="5000" numThreads="8" transactionSize="10"
+                    useTransactions="true" writePercentage="50" numEntries="1000" sharedKeys="false"/>
+        <CsvReportGeneration targetDir="no_contention"/>
+        <ClearCluster/>
+        <StressTestWarmup duration="1m" opsCountStatusLog="5000" numThreads="8" transactionSize="10"
+                          useTransactions="true" writePercentage="50" numEntries="1000" sharedKeys="true"/>
+        <StressTest duration="5m" opsCountStatusLog="5000" numThreads="8" transactionSize="10"
+                    useTransactions="true" writePercentage="50" numEntries="1000" sharedKeys="true"/>
+        <CsvReportGeneration targetDir="contention"/>
+    </benchmark>
+...
+
+----
+
+The difference between the contention and no contention is the pool of key. In the first case the pool of keys are shared among all the threads (and nodes) and in the last case each threads has it own private pool of keys.
+
+ The first group of plots shows the performance in the _contented_ scenario: 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
+ and the next group of plots the _no contended_ scenario: 
+
+ 
+.TODO InformalFigure image title empty
+image::[]
+
+ 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-7-Configuring_cache_programmatically.adoc b/documentation/src/main/asciidoc/user_guide/chapter-7-Configuring_cache_programmatically.adoc
new file mode 100644
index 0000000..dfc875d
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-7-Configuring_cache_programmatically.adoc
@@ -0,0 +1,203 @@
+[[sid-68355030]]
+
+==  Configuring cache programmatically
+
+[[sid-68355030_Configuringcacheprogrammatically-ProgrammaticConfiguration]]
+
+
+=== Programmatic Configuration
+
+ Programmatic Infinispan configuration is centered around CacheManager and ConfigurationBuilder API. Although every single aspect of Infinispan configuration could be set programmatically, the most usual approach is to create a starting point in a form of XML configuration file and then in runtime, if needed, programmatically tune a specific configuration to suit the use case best. 
+
+
+----
+
+EmbeddedCacheManager manager = new DefaultCacheManager("my-config-file.xml");
+Cache defaultCache = manager.getCache();
+
+----
+
+Let assume that a new synchronously replicated cache is to be configured programmatically. First, a fresh instance of Configuration object is created using ConfigurationBuilder helper object, and the cache mode is set to synchronous replication. Finally, the configuration is defined/registered with a manager.
+
+
+
+
+----
+Configuration c = new ConfigurationBuilder().clustering().cacheMode(CacheMode.REPL_SYNC).build();
+     
+String newCacheName = "repl";
+manager.defineConfiguration(newCacheName, c);
+Cache<String, String> cache = manager.getCache(newCacheName);
+
+----
+
+ The default cache configuration (or any other cache configuration) can be used as a starting point for creation of a new cache. For example, lets say that infinispan-config-file.xml specifies a replicated cache as a default and that a distributed cache is desired with a specific L1 lifespan while at the same time retaining all other aspects of a default cache. Therefore, the starting point would be to read an instance of a default Configuration object and use ConfigurationBuilder to construct and modify cache mode and L1 lifespan on a new Configuration object. As a final step the configuration is defined/registered with a manager. 
+
+
+----
+EmbeddedCacheManager manager = new DefaultCacheManager("infinispan-config-file.xml");
+Configuration dcc = cacheManager.getDefaultCacheConfiguration();
+Configuration c = new ConfigurationBuilder().read(dcc).clustering().cacheMode(CacheMode.DIST_SYNC).l1().lifespan(60000L).build();
+ 
+String newCacheName = "distributedWithL1";
+manager.defineConfiguration(newCacheName, c);
+Cache<String, String> cache = manager.getCache(newCacheName);
+
+----
+
+As long as the based configuration is the default named cache, the previous code works perfectly fine. However, other times the base configuration might be another named cache. So, how can new configurations be defined based on other defined caches? Take the previous example and imagine that instead of taking the default cache as base, a named cache called "replicatedCache" is used as base. The code would look something like this:
+
+
+----
+EmbeddedCacheManager manager = new DefaultCacheManager("infinispan-config-file.xml");
+Configuration rc = cacheManager.getCacheConfiguration("replicatedCache");
+Configuration c = new ConfigurationBuilder().read(rc).clustering().cacheMode(CacheMode.DIST_SYNC).l1().lifespan(60000L).build();
+ 
+String newCacheName = "distributedWithL1";
+manager.defineConfiguration(newCacheName, c);
+Cache<String, String> cache = manager.getCache(newCacheName);
+
+----
+
+ Refer to link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/manager/CacheManager.html$$[CacheManager] , link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/configuration/cache/ConfigurationBuilder.html$$[ConfigurationBuilder] , link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/configuration/cache/Configuration.html$$[Configuration] , and link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/configuration/global/GlobalConfiguration.html$$[GlobalConfiguration] javadocs for more details. 
+
+[[sid-68355030_Configuringcacheprogrammatically-ConfigurationBuilderProgrammaticConfigurationAPI]]
+
+
+=== ConfigurationBuilder Programmatic Configuration API
+
+However, users do not have to first read an XML based configuration and then modify it in runtime; they can start from scratch using only programmatic API. This is where powerful ConfigurationBuilder API comes to shine. The aim of this API is to make it easier to chain coding of configuration options in order to speed up the coding itself and make the configuration more readable. This new configuration can be used for both the global and the cache level configuration. GlobalConfiguration objects are constructed using GlobalConfigurationBuilder while Configuration objects are built using ConfigurationBuilder. Let's look at some examples on configuring both global and cache level options with this new API:
+
+ One of the most commonly configured global option is the transport layer, where you indicate how an Infinispan node will discover the others: 
+
+
+----
+GlobalConfiguration globalConfig = new GlobalConfigurationBuilder().transport()
+        .clusterName("qa-cluster")
+        .addProperty("configurationFile", "jgroups-tcp.xml")
+        .machineId("qa-machine").rackId("qa-rack")
+      .build();
+
+----
+
+ Sometimes you might also want to get link:$$http://docs.jboss.org/infinispan/5.0/apidocs/jmxComponents.html$$[global JMX statistics] and information about the transport, or the cache manager in general. To enable global JMX statistics simply do: 
+
+
+----
+GlobalConfiguration globalConfig = new GlobalConfigurationBuilder()
+  .globalJmxStatistics()
+  .build();
+
+----
+
+ Further options at the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737050$$[global JMX statistics level] allows you for example to configure the cache manager name which comes handy when you have multiple cache managers running on the same system, or how to locate the JMX MBean Server: 
+
+
+----
+GlobalConfiguration globalConfig = new GlobalConfigurationBuilder()
+  .globalJmxStatistics()
+    .cacheManagerName("SalesCacheManager")
+    .mBeanServerLookupClass(JBossMBeanServerLookup.class)
+  .build();
+
+----
+
+ Some of the Infinispan features are powered by a group of the thread pool executors which can also be tweaked at this global level. For example: 
+
+
+----
+GlobalConfiguration globalConfig = new GlobalConfigurationBuilder()
+  .replicationQueueScheduledExecutor()
+    .factory(DefaultScheduledExecutorFactory.class)
+    .addProperty("threadNamePrefix", "RQThread")
+  .build();
+
+----
+
+ You can not only configure global, cache manager level, options, but you can also configure cache level options such as the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737115$$[cluster mode] : 
+
+
+----
+Configuration config = new ConfigurationBuilder()
+  .clustering()
+    .cacheMode(CacheMode.DIST_SYNC)
+    .sync()
+    .l1().lifespan(25000L)
+    .hash().numOwners(3)
+  .build();
+
+----
+
+ Or you can configure link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737139$$[eviction/expiration settings] to: 
+
+
+----
+Configuration config = new ConfigurationBuilder()
+           .eviction()
+             .maxEntries(20000).strategy(EvictionStrategy.LIRS).expiration()
+             .wakeUpInterval(5000L)
+             .maxIdle(120000L)
+           .build();
+
+----
+
+ An application might also want to interact with an Infinispan cache within the boundaries of JTA and to do that you need to configure the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737108$$[transaction layer] and optionally tweak the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737096$$[locking settings] . When interacting with transactional caches, you might want to link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737124$$[enable recovery] to deal with transactions that finished with an heuristic outcome and if you do that, you will often want to enable JMX management and statistics gathering too: 
+
+
+----
+Configuration config = new ConfigurationBuilder()
+  .locking()
+    .concurrencyLevel(10000).isolationLevel(IsolationLevel.REPEATABLE_READ)
+    .lockAcquisitionTimeout(12000L).useLockStriping(false).writeSkewCheck(true)
+  .transaction()
+    .recovery()
+    .transactionManagerLookup(new GenericTransactionManagerLookup())
+  .jmxStatistics()
+  .build();
+
+----
+
+ Configuring Infinispan with <<sid-68355053,one or several chained persistent stores>> is simple too: 
+
+
+----
+Configuration config = new ConfigurationBuilder()
+      .loaders()
+        .shared(false).passivation(false).preload(false)
+        .addFileCacheStore().location("/tmp").streamBufferSize(1800).async().enable().threadPoolSize(20).build();
+----
+
+[[sid-68355030_Configuringcacheprogrammatically-Advancedprogrammaticconfiguration]]
+
+
+==== Advanced programmatic configuration
+
+ The fluent configuration can also be used to configure more advanced or exotic options, such as link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737151$$[advanced externalizers] : 
+
+
+----
+GlobalConfiguration globalConfig = new GlobalConfigurationBuilder()
+  .serialization()
+    .addAdvancedExternalizer(PersonExternalizer.class)
+    .addAdvancedExternalizer(999, AddressExternalizer.class)
+  .build();
+
+----
+
+ Or, add link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737149$$[custom interceptors] : 
+
+
+----
+Configuration config = new ConfigurationBuilder()
+  .customInterceptors().interceptors()
+    .add(new FirstInterceptor()).first()
+    .add(new LastInterceptor()).last()
+    .add(new FixPositionInterceptor()).atIndex(8)
+    .add(new AfterInterceptor()).after(LockingInterceptor.class)
+    .add(new BeforeInterceptor()).before(CallInterceptor.class)
+  .build();
+
+----
+
+ For information on the individual configuration options, please check the link:$$http://docs.jboss.org/infinispan/5.0/apidocs/config.html$$[configuration guide] . 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-70-Using_Infinispan_as_a_JCache_provider.adoc b/documentation/src/main/asciidoc/user_guide/chapter-70-Using_Infinispan_as_a_JCache_provider.adoc
new file mode 100644
index 0000000..399dd82
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-70-Using_Infinispan_as_a_JCache_provider.adoc
@@ -0,0 +1,247 @@
+[[sid-68355124]]
+
+==  Using Infinispan as a JCache provider
+
+ Starting with version 5.3, Infinispan provides an implementation of JCache API ( link:$$http://www.jcp.org/en/jsr/detail?id=107$$[JSR-107] ). JCache specifies a standard Java API for caching temporary Java objects in memory. Caching java objects can help get around bottlenecks arising from using data that is expensive to retrieve (i.e. DB or web service), or data that is hard to calculate. Caching these type of objects in memory can help speed up application performance by retrieving the data directly from memory instead of doing an expensive roundtrip or recalculation. This document specifies how to use JCache with Infinispan's implementation of the specification, and explains key aspects of the API. 
+
+
+[IMPORTANT]
+==== 
+At the time of writing, Infinispan 5.3.0.Alpha1 implements version 0.6 of the JCache specification.
+
+
+==== 
+
+
+[[sid-68355124_UsingInfinispanasaJCacheprovider-Dependencies]]
+
+
+=== Dependencies
+
+In order to start using Infinispan JCache implementation, a single dependency needs to be added to the Maven pom.xml file:
+
+
+----
+<dependency>
+   <groupId>org.infinispan</groupId>
+   <artifactId>infinispan-jcache</artifactId>
+   <version>...</version> <!-- i.e. 5.3.0.Alpha1 -->
+   <scope>test</scope>
+</dependency>
+----
+
+[[sid-68355124_UsingInfinispanasaJCacheprovider-Createalocalcache]]
+
+
+=== Create a local cache
+
+Creating a local cache, using default configuration options as defined by the JCache API specification, is as simple as doing the following:
+
+
+----
+import javax.cache.Cache;
+import javax.cache.CacheManager;
+import javax.cache.Caching;
+import javax.cache.SimpleConfiguration;
+
+// Retrieve the system wide cache manager
+CacheManager cacheManager = Caching.getCacheManager();
+// Define a named cache with default JCache configuration
+Cache<String, String> cache = cacheManager.configureCache("namedCache", new SimpleConfiguration<String, String>());
+----
+
+
+[WARNING]
+==== 
+ By default, the JCache API specifies that data should be stored as storeByValue , so that object state mutations outside of operations to the cache, won't have an impact in the objects stored in the cache. Infinispan has so far implemented this using serialization/marshalling to make copies to store in the cache, and that way adhere to the spec. Hence, if using default JCache configuration with Infinispan, data stored must be marshallable. Instructions on how to make data stored in Infinispan marshallable can be found link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737151$$[here] . 
+
+
+==== 
+
+
+Alternatively, JCache can be configured to store data by reference (just like Infinispan or JDK Collections work). To do that, simply call:
+
+
+----
+Cache<String, String> cache = cacheManager.configureCache("namedCache", new SimpleConfiguration<String, String>().setStoreByValue(false));
+----
+
+[[sid-68355124_UsingInfinispanasaJCacheprovider-Storeandretrievedata]]
+
+
+=== Store and retrieve data
+
+ Even though JCache API does not extend neither java.util.Map not java.util.concurrent.ConcurrentMap , it providers a key/value API to store and retrieve data: 
+
+
+----
+import javax.cache.Cache;
+import javax.cache.CacheManager;
+import javax.cache.Caching;
+import javax.cache.SimpleConfiguration;
+
+CacheManager cacheManager = Caching.getCacheManager();
+Cache<String, String> cache = cacheManager.configureCache("namedCache", new SimpleConfiguration<String, String>());
+cache.put("hello", "world"); // Notice that javax.cache.Cache.put(K) returns void!
+String value = cache.get("hello"); // Returns "world"
+----
+
+ Contrary to standard java.util.Map , javax.cache.Cache comes with two basic put methods called put and getAndPut . The former returns void whereas the latter returns the previous value associated with the key. So, the equivalent of java.util.Map.put(K) in JCache is javax.cache.Cache.getAndPut(K) . 
+
+
+[TIP]
+==== 
+ Even though JCache API only convers standalone caching, it can be plugged with a persistence store, and has been designed with clustering or distribution in mind. The reason why javax.cache.Cache offers two put methods is because standard java.util.Map put call forces implementors to calculate the previous value. When a persistent store is in use, or the cache is distributed, returning the previous value could be an expensive operation, and often users call standard java.util.Map.put(K) without using the return value. Hence, JCache users need to think about whether the return value is relevant to them, in which case they need to call javax.cache.Cache.getAndPut(K) , otherwise they can call javax.cache.Cache.put(K) which avoids returning the potentially expensive operation of returning the previous value. 
+
+
+==== 
+
+
+[[sid-68355124_UsingInfinispanasaJCacheprovider-Comparing%7B%7Bjava.util.concurrent.ConcurrentMap%7D%7Dand%7B%7Bjavax.cache.Cache%7D%7DAPIs]]
+
+
+=== Comparing java.util.concurrent.ConcurrentMap and javax.cache.Cache APIs
+
+ Here's a brief comparison of the data manipulation APIs provided by java.util.concurrent.ConcurrentMap and javax.cache.Cache APIs. 
+
+[options="header"]
+|===============
+|Operation| java.util.concurrent.ConcurrentMap&lt;K, V&gt; | javax.cache.Cache&lt;K, V&gt; 
+|store and no return| | void put(K key) 
+|store and return previous value| V put(K key) | V getAndPut(K key) 
+|store if not present| V putIfAbsent(K key, V value) | boolean putIfAbsent(K key, V value) 
+|retrieve| V get(Object key) | V get(K key) 
+|delete if present| V remove(Object key) | boolean remove(K key) 
+|delete and return previous value| V remove(Object key) | V getAndRemove(K key) 
+|delete conditional| boolean remove(Object key, Object value) | boolean remove(K key, V oldValue) 
+|replace if present| V replace(K key, V value) | boolean replace(K key, V value) 
+|replace and return previous value| V replace(K key, V value) | V getAndReplace(K key, V value) 
+|replace conditional| boolean replace(K key, V oldValue, V newValue) | boolean replace(K key, V oldValue, V newValue) 
+
+|===============
+
+
+ Comparing the two APIs, it's obvious to see that where possible JCache avoids returning the previous value to avoid operations doing expensive network or IO operations. This is an overriding principle in the design of JCache API. In fact, there's a set of operations that are present in java.util.concurrent.ConcurrentMap , but are not present in the javax.cache.Cache because they could be expensive to compute in a distributed cache. The only exception is iterating over the contents of the cache: 
+
+[options="header"]
+|===============
+|Operation| java.util.concurrent.ConcurrentMap&lt;K, V&gt; | javax.cache.Cache&lt;K, V&gt; 
+|calculate size of cache| int size() | 
+|return all keys in the cache| Set&lt;K&gt; keySet() | 
+|return all values in the cache| Collection&lt;V&gt; values() | 
+|return all entries in the cache| Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() | 
+|iterate over the cache| use iterator() method on keySet, values or entrySet | Iterator&lt;Cache.Entry&lt;K, V&gt;&gt; iterator() 
+
+|===============
+
+
+[[sid-68355124_UsingInfinispanasaJCacheprovider-ClusteringJCacheinstances]]
+
+
+=== Clustering JCache instances
+
+Infinispan JCache implementation goes beyond the specification in order to provide the possibility to cluster caches using the standard API. Given a Infinispan configuration file configured to replicate caches like this:
+
+
+----
+<?xml version="1.0" encoding="UTF-8"?>
+<infinispan xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+            xmlns="urn:infinispan:config:5.3"
+            xsi:schemaLocation="urn:infinispan:config:5.3 http://www.infinispan.org/schemas/infinispan-config-5.3.xsd">
+   <global>
+      <transport
+         transportClass="org.infinispan.remoting.transport.jgroups.JGroupsTransport"
+         clusterName="jcache-cluster">
+      </transport>
+   </global>
+
+   <default />
+
+   <namedCache name="namedCache">
+      <clustering mode="replication" />
+   </namedCache>
+
+</infinispan>
+----
+
+You can create a cluster of caches using this code:
+
+
+----
+import javax.cache.Cache;
+import javax.cache.CacheManager;
+import javax.cache.Caching;
+
+// For multiple cache managers to be constructed with the standard JCache API and live in the same JVM, either their names, or their classloaders, must be different. 
+// This example shows how to force their classloaders to be different. An alternative method would have been to duplicate the XML file and give it a different name, 
+// but this results in unnecessary file duplication.
+ClassLoader tccl = Thread.currentThread().getContextClassLoader();
+CacheManager cacheManager1 = Caching.getCacheManager(new TestClassLoader(tccl), "infinispan-jcache-cluster.xml");
+CacheManager cacheManager2 = Caching.getCacheManager(new TestClassLoader(tccl), "infinispan-jcache-cluster.xml");
+
+Cache<String, String> cache1 = cacheManager1.getCache("namedCache");
+Cache<String, String> cache2 = cacheManager2.getCache("namedCache");
+
+cache1.put("hello", "world");
+String value = cache2.get("hello"); // Returns "world" if clustering is working
+
+// --
+
+public static class TestClassLoader extends ClassLoader {
+  public TestClassLoader(ClassLoader parent) {
+     super(parent);
+  }
+}
+----
+
+
+[IMPORTANT]
+==== 
+ If using custom objects, make sure they are serializable/marshallable as per the instructions link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737151$$[here] . 
+
+
+==== 
+
+
+[[sid-68355124_UsingInfinispanasaJCacheprovider-Expirecacheddata]]
+
+
+=== Expire cached data
+
+ TODO 
+
+[[sid-68355124_UsingInfinispanasaJCacheprovider-Annotations]]
+
+
+=== Annotations
+
+ TODO 
+
+[[sid-68355124_UsingInfinispanasaJCacheprovider-Transactions]]
+
+
+=== Transactions
+
+ TODO 
+
+[[sid-68355124_UsingInfinispanasaJCacheprovider-Atomiccompoundoperationsoncacheentrywithouttransactions]]
+
+
+=== Atomic compound operations on cache entry without transactions
+
+ TODO - invokeEntryProcessor 
+
+[[sid-68355124_UsingInfinispanasaJCacheprovider-Usingcachelisteners]]
+
+
+=== Using cache listeners
+
+ TODO 
+
+[[sid-68355124_UsingInfinispanasaJCacheprovider-Quickstarts]]
+
+
+=== Quickstarts
+
+ TODO 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-71-Infinispan_Server.adoc b/documentation/src/main/asciidoc/user_guide/chapter-71-Infinispan_Server.adoc
new file mode 100644
index 0000000..9088e16
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-71-Infinispan_Server.adoc
@@ -0,0 +1,485 @@
+[[sid-68355126]]
+
+==  Infinispan Server
+
+[[sid-68355126_InfinispanServer-Introduction]]
+
+
+=== Introduction
+
+Infinispan Server is a standalone server which exposes any number of caches to clients over a variety of protocols, including HotRod, Memcached and REST. The server itself is built on top of the robust foundation provided by JBoss AS 7.2, therefore delegating services such as configuration, datasources, transactions, logging and security to the respective subsystems. Because Infinispan Server is closely tied to the latest releases of Infinispan and JGroups, the subsystems which control these components are slightly different, in that they introduce new features and change some existing ones (e.g. cross-site replication, etc). For this reason, the configuration of these subsystems should use the Infinispan Server-specific schema. See the Configuration section for more information.
+
+[[sid-68355126_InfinispanServer-Protocols]]
+
+
+=== Protocols
+
+[[sid-68355126_InfinispanServer-HotRod]]
+
+
+==== Hot Rod
+
+ Hot Rod is Infinispan's own topology-aware high-performance remote protocol. See link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=5931020$$[Hot Rod] 
+
+[[sid-68355126_InfinispanServer-Memcached]]
+
+
+==== Memcached
+
+ Memcached is a very popular caching server with its own protocol. See link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=5439735$$[Memcached] 
+
+[[sid-68355126_InfinispanServer-Rest]]
+
+
+==== Rest
+
+ Rest uses HTTP methods to perform operations on a cache. See link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737132$$[Accessing data in Infinispan via RESTful interface] 
+
+[[sid-68355126_InfinispanServer-WebSocket]]
+
+
+==== WebSocket
+
+ The WebSocket protocol is a technology used to provide persistent bidirectional communication between (but not limited to) a web browser and a server. See link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737036$$[WebSocket Server] 
+
+[[sid-68355126_InfinispanServer-GettingStarted]]
+
+
+=== Getting Started
+
+ To get started using the server, download the Infinispan Server distribution, unpack it to a local directory and launch it using the bin/standalone.sh or bin/standalone.bat scripts depending on your platform. This will start a single-node server using the standalone/configuration/standalone.xml configuration file, with four endpoints, one for each of the supported protocols. These endpoints allow access to all of the caches configured in the Infinispan subsystem (apart from the Memcached endpoint which, because of the protocol's design, only allows access to a single cache). The server also comes with a script ( clustered.sh/clustered.bat ) which provides an easy way to start a clustered server by using the standalone/configuration/clustered.xml configuration file. If you start the server in clustered mode on multiple hosts, they should automatically discover each other using UDP multicast and form a cluster. If you want to start multiple nodes on a single host, start each one by specifying a port offset using the jboss.socket.binding.port-offset property together with a unique jboss.node.name as follows: 
+
+ bin/clustered.sh -Djboss.socket.binding.port-offset=100 -Djboss.node.name=nodeA 
+
+ If, for some reason, you cannot use UDP multicast, you can use TCP discovery. Read the <<sid-68355126_InfinispanServer-JGroupssubsystemconfiguration,JGroups subsystem configuration>> section for details on how to configure TCP discovery. 
+
+ The server distribution also provides a set of example configuration files in the docs/examples/configs which illustrate a variety of possible configurations and use-cases. To use them, just copy them to the standalone/configuration directory and start the server using the following syntax: 
+
+ bin/standalone.sh -c configuration_file_name.xml 
+
+ For more information regarding the parameters supported by the startup scripts, refer to the JBoss AS 7.2 documentation on link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=53117092$$[Command line parameters] , bearing in mind that Infinispan Server does not currently support managed servers, also known as domain mode. 
+
+[[sid-68355126_InfinispanServer-CLI]]
+
+
+=== CLI
+
+ The link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=61505925$$[Infinispan CLI] can be used to connect to the server. You need to use the remoting protocol and connect to port 9999. By default the CLI will use the special silent SASL authenticator, which won't require a username/password: 
+
+
+----
+
+bin/ispn-cli.sh
+[disconnected//]> connect localhost
+[remoting://localhost:9999/local/]> cache default
+[remoting://localhost:9999/local/default]> encoding hotrod
+[remoting://localhost:9999/local/default]> put a a
+[remoting://localhost:9999/local/default]> get a
+a
+
+----
+
+[[sid-68355126_InfinispanServer-Configuration]]
+
+
+=== Configuration
+
+Since the server is based on the JBoss AS 7.2 codebase, it must configured be using the AS configuration schema, apart from the JGroups, Infinispan and Endpoint subsytems.
+
+[[sid-68355126_InfinispanServer-JGroupssubsystemconfiguration]]
+
+
+==== JGroups subsystem configuration
+
+The JGroups subsystem configures the network transport and is only required when clustering multiple Infinispan Server nodes together.
+
+The subsystem declaration is enclosed in the following XML element:
+
+
+----
+
+<subsystem xmlns="urn:jboss:domain:jgroups:1.2" default-stack="${jboss.default.jgroups.stack:udp}">
+  ...
+</subsystem>
+
+----
+
+ Within the subsystem, you need to declare the stacks that you wish to use and name them. The default-stack attribute in the subsystem declaration must point to one of the declared stacks. You can switch stacks from the command-line using the jboss.default.jgroups.stack property: 
+
+ bin/clustered.sh -Djboss.default.jgroups.stack=tcp 
+
+ A stack declaration is composed of a transport (UDP or TCP) followed by a list of protocols. For each of these elements you can tune specific properties adding child &lt;property name="prop_name"&gt;prop_value&lt;/property&gt; elements. Since the amount of protocols and their configuration options in JGroups is huge, please refer to the appropriate link:$$http://www.jgroups.org/manual/html/protlist.html$$[JGroups Protocol documentation] . The following are the default stacks: 
+
+
+----
+
+ <stack name="udp">
+    <transport type="UDP" socket-binding="jgroups-udp"/>
+    <protocol type="PING"/>
+    <protocol type="MERGE2"/>
+    <protocol type="FD_SOCK" socket-binding="jgroups-udp-fd"/>
+    <protocol type="FD_ALL"/>
+    <protocol type="pbcast.NAKACK"/>
+    <protocol type="UNICAST2"/>
+    <protocol type="pbcast.STABLE"/>
+    <protocol type="pbcast.GMS"/>
+    <protocol type="UFC"/>
+    <protocol type="MFC"/>
+    <protocol type="FRAG2"/>
+    <protocol type="RSVP"/>
+</stack>
+<stack name="tcp">
+    <transport type="TCP" socket-binding="jgroups-tcp"/>
+    <protocol type="MPING" socket-binding="jgroups-mping"/>
+    <protocol type="MERGE2"/>
+    <protocol type="FD_SOCK" socket-binding="jgroups-tcp-fd"/>
+    <protocol type="FD"/>
+    <protocol type="VERIFY_SUSPECT"/>
+    <protocol type="pbcast.NAKACK">
+        <property name="use_mcast_xmit">false</property>
+    </protocol>
+    <protocol type="UNICAST2"/>
+    <protocol type="pbcast.STABLE"/>
+    <protocol type="pbcast.GMS"/>
+    <protocol type="UFC"/>
+    <protocol type="MFC"/>
+    <protocol type="FRAG2"/>
+    <protocol type="RSVP"/>
+</stack>
+
+----
+
+ The default TCP stack uses the MPING protocol for discovery, which uses UDP multicast. If you need to use a different protocol, look at the link:$$http://www.jgroups.org/manual/html/protlist.html#DiscoveryProtocols$$[JGroups Discovery Protocols] . The following example stack configures the TCPPING discovery protocol with two initial hosts: 
+
+
+----
+
+<stack name="tcp">
+    <transport type="TCP" socket-binding="jgroups-tcp"/>
+    <protocol type="TCPPING">
+        <property name="initial_hosts">HostA[7800],HostB[7800]</property>
+    </protocol>
+    <protocol type="MERGE2"/>
+    <protocol type="FD_SOCK" socket-binding="jgroups-tcp-fd"/>
+    <protocol type="FD"/>
+    <protocol type="VERIFY_SUSPECT"/>
+    <protocol type="pbcast.NAKACK">
+        <property name="use_mcast_xmit">false</property>
+    </protocol>
+    <protocol type="UNICAST2"/>
+    <protocol type="pbcast.STABLE"/>
+    <protocol type="pbcast.GMS"/>
+    <protocol type="UFC"/>
+    <protocol type="MFC"/>
+    <protocol type="FRAG2"/>
+    <protocol type="RSVP"/>
+</stack>
+
+----
+
+[[sid-68355126_InfinispanServer-Infinispansubsystemconfiguration]]
+
+
+==== Infinispan subsystem configuration
+
+The Infinispan subsystem configures the cache containers and caches. Its schema differs from the default Infinispan library declarative because it needs to adhere to the application server standards, but the underlying concepts are the same.
+
+The subsystem declaration is enclosed in the following XML element:
+
+
+----
+
+<subsystem xmlns="urn:infinispan:server:core:5.2" default-cache-container="clustered">
+  ...
+</subsystem>
+
+----
+
+[[sid-68355126_InfinispanServer-Containers]]
+
+
+===== Containers
+
+One major difference between the Infinispan library schema and the server schema is that in the latter multiple containers can be declared. A container is declared as follows:
+
+
+----
+
+<cache-container name="clustered" default-cache="default">
+  ...
+</cache-container>
+
+----
+
+Another difference is the lack of an implicit default cache, but the ability to specify a named cache as the default.
+
+ If you need to declare clustered caches (distributed, replicated, invalidation), you also need to specify the &lt;transport/&gt; element which references an existing JGroups transport. This is not needed if you only intend to have local caches only. 
+
+
+----
+
+<transport executor="infinispan-transport" lock-timeout="60000" stack="udp" cluster="my-cluster-name"/>
+
+----
+
+[[sid-68355126_InfinispanServer-Caches]]
+
+
+===== Caches
+
+Now you can declare your caches. Please be aware that only the caches declared in the configuration will be available to the endpoints and that attempting to access an undefined cache is an illegal operation. Contrast this with the default Infinispan library behaviour where obtaining an undefined cache will implicitly create one using the default settings. The following are example declarations for all four available types of caches:
+
+
+----
+
+<local-cache name="default" start="EAGER">
+  ...
+</local-cache>
+
+<replicated-cache name="replcache" mode="SYNC" remote-timeout="30000" start="EAGER">
+  ...
+</replicated-cache>
+
+<invalidation-cache name="invcache" mode="SYNC" remote-timeout="30000" start="EAGER">
+  ...
+</invalidation-cache>
+<distributed-cache name="distcache" mode="SYNC" segments="20" owners="2" remote-timeout="30000" start="EAGER">
+  ...
+</distributed-cache>
+
+----
+
+[[sid-68355126_InfinispanServer-Expiration]]
+
+
+===== Expiration
+
+ To define a default expiration for entries in a cache, add the &lt;expiration/&gt; element as follows: 
+
+
+----
+
+<expiration lifespan="2000" max-idle="1000"/>
+
+----
+
+The possible attributes for the expiration element are:
+
+
+*  _lifespan_ maximum lifespan of a cache entry, after which the entry is expired cluster-wide, in milliseconds. -1 means the entries never expire. 
+
+
+*  _max-idle_ maximum idle time a cache entry will be maintained in the cache, in milliseconds. If the idle time is exceeded, the entry will be expired cluster-wide. -1 means the entries never expire. 
+
+
+*  _interval_ interval (in milliseconds) between subsequent runs to purge expired entries from memory and any cache stores. If you wish to disable the periodic eviction process altogether, set interval to -1. 
+
+[[sid-68355126_InfinispanServer-Eviction]]
+
+
+===== Eviction
+
+ To define an eviction strategy for a cache, add the &lt;eviction/&gt; element as follows: 
+
+
+----
+
+<eviction strategy="LIRS" max-entries="1000"/>
+
+----
+
+The possible attributes for the eviction element are:
+
+
+*  _strategy_ sets the cache eviction strategy. Available options are 'UNORDERED', 'FIFO', 'LRU', 'LIRS' and 'NONE' (to disable eviction). 
+
+
+*  _max-entries_ maximum number of entries in a cache instance. If selected value is not a power of two the actual value will default to the least power of two larger than selected value. -1 means no limit. 
+
+[[sid-68355126_InfinispanServer-Locking]]
+
+
+===== Locking
+
+ To define the locking configuration for a cache, add the &lt;locking/&gt; element as follows: 
+
+
+----
+
+<locking isolation="REPEATABLE_READ" acquire-timeout="30000" concurrency-level="1000" striping="false"/>
+
+----
+
+The possible attributes for the locking element are:
+
+
+*  _isolation_ sets the cache locking isolation level. Can be NONE, READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE. Defaults to REPEATABLE_READ 
+
+
+*  _striping_ if true, a pool of shared locks is maintained for all entries that need to be locked. Otherwise, a lock is created per entry in the cache. Lock striping helps control memory footprint but may reduce concurrency in the system. 
+
+
+*  _acquire-timeout_ maximum time to attempt a particular lock acquisition. 
+
+
+*  _concurrency-level_ concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan. 
+
+
+*  _concurrent-updates_ for non-transactional caches only: if set to true(default value) the cache keeps data consistent in the case of concurrent updates. For clustered caches this comes at the cost of an additional RPC, so if you don't expect your application to write data concurrently, disabling this flag increases performance. 
+
+[[sid-68355126_InfinispanServer-Transactions]]
+
+
+===== Transactions
+
+While it is possible to configure server caches to be transactional, none of the available protocols offer transaction capabilities.
+
+[[sid-68355126_InfinispanServer-LoadersandStores]]
+
+
+===== Loaders and Stores
+
+TODO
+
+[[sid-68355126_InfinispanServer-Endpointsubsystemconfiguration]]
+
+
+==== Endpoint subsystem configuration
+
+The endpoint subsystem exposes a whole container (or in the case of Memcached, a single cache) over a specific connector protocol. You can define as many connector as you need, provided they bind on different interfaces/ports.
+
+The subsystem declaration is enclosed in the following XML element:
+
+
+----
+
+ <subsystem xmlns="urn:infinispan:server:endpoint:5.3">
+  ...
+ </subsystem>
+
+----
+
+[[sid-68355126_InfinispanServer-HotRodx]]
+
+
+===== HotRod
+
+ The following connector declaration enables a HotRod server using the _hotrod_ socket binding (declared within a &lt;socket-binding-group /&gt; element) and exposing the caches declared in the _local_ container, using defaults for all other settings. 
+
+
+----
+
+<hotrod-connector socket-binding="hotrod" cache-container="local" />
+
+----
+
+The connector will create a supporting topology cache with default settings. If you wish to tune these settings add the &lt;topology-state-transfer /&gt; child element to the connector as follows:
+
+
+----
+
+<hotrod-connector socket-binding="hotrod" cache-container="local">
+   <topology-state-transfer lazy-retrieval="false" lock-timeout="1000" replication-timeout="5000" />
+</hotrod-connector>
+
+----
+
+The HotRod connector can be further tuned with additional settings such as concurrency and buffering. See the protocol connector settings paragraph for additional details
+
+ Furthermore the HotRod connector can be secured using SSL. First you need to declare an SSL server identity within a security realm in the management section of the configuration file. The SSL server identity should specify the path to a keystore and its secret. Refer to the AS7.2 link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=53117128$$[documentation] on this. Next add the &lt;security /&gt; element to the HotRod connector as follows: 
+
+
+----
+
+<hotrod-connector socket-binding="hotrod" cache-container="local">
+    <security ssl="true" security-realm="ApplicationRealm" require-ssl-client-auth="false" />
+</hotrod-connector>
+
+----
+
+[[sid-68355126_InfinispanServer-Memcachedx]]
+
+
+===== Memcached
+
+ The following connector declaration enables a Memcached server using the _memcached_ socket binding (declared within a &lt;socket-binding-group /&gt; element) and exposing the _memcachedCache_ cache declared in the _local_ container, using defaults for all other settings. Because of limitations in the Memcached protocol, only one cache can be exposed by a connector. If you wish to expose more than one cache, declare additional memcached-connectors on different socket-bindings. 
+
+
+----
+
+<memcached-connector socket-binding="memcached" cache-container="local"/>
+
+----
+
+[[sid-68355126_InfinispanServer-WebSocketx]]
+
+
+===== WebSocket
+
+
+----
+
+<websocket-connector socket-binding="websocket" cache-container="local"/>
+
+----
+
+[[sid-68355126_InfinispanServer-REST]]
+
+
+===== REST
+
+ The REST connector differs from the above connectors because it piggybacks on the web subsystem. Therefore configurations such as socket binding, worker threads, timeouts, etc must be performed on the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=53117098$$[web subsystem] . 
+
+
+----
+
+<rest-connector virtual-server="default-host" cache-container="local" security-domain="other" auth-method="BASIC"/>
+
+----
+
+[[sid-68355126_InfinispanServer-]]
+
+
+===== 
+
+[[sid-68355126_InfinispanServer-CommonProtocolConnectorSettings]]
+
+
+===== Common Protocol Connector Settings
+
+The HotRod, Memcached and WebSocket protocol connectors support a number of tuning attributes in their declaration:
+
+
+*  _worker-threads_ Sets the number of worker threads. Defaults to twice the number of available cores. 
+
+
+*  _idle-timeout_ Specifies the maximum time in seconds that connections from client will be kept open without activity. Defaults to -1 (connections will never timeout) 
+
+
+*  _tcp-nodelay_ Affects TCP NODELAY on the TCP stack. Defaults to enabled. 
+
+
+*  _send-buffer-size_ Sets the size of the send buffer. Defaults to 
+
+
+*  _receive-buffer-size_ Sets the size of the receive buffer. Defaults to 
+
+[[sid-68355126_InfinispanServer-ProtocolInteroperability]]
+
+
+===== Protocol Interoperability
+
+By default each protocol stores data in the cache in the most efficient format for that protocol, so that no transformations are required when retrieving entries. If instead you need to access the same data from multiple protocols, you should enable compatibility mode on the caches that you want to share. This is done by adding the &lt;compatibility /&gt; element to a cache definition, as follows:
+
+
+----
+
+<cache-container name="local" default-cache="default">
+    <local-cache name="default" start="EAGER">
+        <transaction mode="NONE"/>
+        <compatibility enabled="true"/>
+    </local-cache>
+</cache-container>
+
+----
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-72-Storing_objects_e_g_arrays_with_custom_Equivalence_functions.adoc b/documentation/src/main/asciidoc/user_guide/chapter-72-Storing_objects_e_g_arrays_with_custom_Equivalence_functions.adoc
new file mode 100644
index 0000000..32eba82
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-72-Storing_objects_e_g_arrays_with_custom_Equivalence_functions.adoc
@@ -0,0 +1,314 @@
+[[sid-68355127]]
+
+==  Storing objects (e.g. arrays) with custom Equivalence functions
+
+[[sid-68355127_Storingobjects%28e.g.arrays%29withcustomEquivalencefunctions-TheProblemofCachingArrays]]
+
+
+=== The Problem of Caching Arrays
+
+ There are times when users want to store data into Infinispan caches whose default equals() and/or hashCode() implementations produce undesirable results. One of those data types are arrays. When users want to store arrays into Infinispan caches, the big majority of users want equals() function to be calculated based on the contents of the arrays as opposed to comparing the object reference, so if we take byte arrays are example, users would like to call up the static java.util.Arrays.equals(byte[], byte[]) method instead of Object.equals() . The same thing happens with hashCode() . The default implementation of Object.hashCode() for arrays suffers from the same issue, because the result is not produced based on the contents of the array, but rather based on the object reference to the array. 
+
+[[sid-68355127_Storingobjects%28e.g.arrays%29withcustomEquivalencefunctions-Oldworkaround%3AWrapperClasses]]
+
+
+=== Old workaround: Wrapper Classes
+
+ Until Infinispan 5.2, the way to get around these issues was by wrapping arrays, or any other object whose equals()/hashCode() implementations are not best suited for being stored in Infinispan caches, around another object which would override Object.equals() and Object.hashCode() to do the correct calculations. This is where classes such as link:$$https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/util/ByteArrayKey.java$$[ByteArrayKey] originate: 
+
+
+----
+
+public final class ByteArrayKey implements Serializable {
+
+   private final byte[] data;
+   private final int hashCode;
+
+   public ByteArrayKey(byte[] data) {
+      this.data = data;
+      this.hashCode = 41 + Arrays.hashCode(data);
+   }
+
+   public byte[] getData() {
+      return data;
+   }
+
+   @Override
+   public boolean equals(Object obj) {
+      if (this == obj) return true;
+      if (obj == null || ByteArrayKey.class != obj.getClass()) return false;
+      ByteArrayKey key = (ByteArrayKey) obj;
+      return Arrays.equals(key.data, this.data);
+   }
+
+   @Override
+   public int hashCode() {
+      return hashCode;
+   }
+
+   @Override
+   public String toString() {
+      return new StringBuilder().append("ByteArrayKey").append("{")
+         .append("data=").append(Util.printArray(data, true))
+         .append("}").toString();
+   }
+
+}
+
+----
+
+The problem with these classes is that they result in extra memory consumption due to the extra objects required to support data types such as arrays and really, these classes just a workaround for the lack of ability to provide a way to pass in a function that specifies how two byte arrays are are compared, or how to calculate the hash code of a given array.
+
+[[sid-68355127_Storingobjects%28e.g.arrays%29withcustomEquivalencefunctions-Newsolution%3APluggingEquivalencefunctions]]
+
+
+=== New solution: Plugging Equivalence functions
+
+ Starting with Infinispan 5.3, Infinispan users can provide these functions for both keys and values implementing the new 
+            link:$$https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/util/Equivalence.java$$[Equivalence&lt;T&gt; interface]
+           : 
+
+
+----
+
+public interface Equivalence<T> extends Serializable {
+
+   /**
+    * Returns a hash code value for the object passed.
+    *
+    * As an example, implementors can provide an alternative implementation
+    * for the hash code calculation for arrays. So, instead of relying on
+    * {@link Object#hashCode()}, call {@link java.util.Arrays.hashCode()}.
+    *
+    * @param obj instance to calculate hash code for
+    * @return a hash code value for the object passed as parameter
+    */
+   int hashCode(Object obj);
+
+   /**
+    * Indicates whether the objects passed are "equal to" each other.
+    *
+    * As an example, implementors can provide an alternative implementation
+    * for the equals for arrays. So, instead of relying on
+    * {@link Object#equals(Object)}}, call {@link java.util.Arrays.equals())}.
+    *
+    * @param obj to be compared with second parameter
+    * @param otherObj to be compared with first parameter
+    * @return <code>true</code> if both objects are the same;
+    *         <code>false</code> otherwise
+    */
+   boolean equals(T obj, Object otherObj);
+
+   /**
+    * Returns a string representation of the given object.
+    *
+    * @param obj whose string representation is to be returned
+    * @return a string representation of the passed object
+    */
+   String toString(Object obj);
+
+   /**
+    * Returns whether the given object is comparable. In other words, if
+    * given an instance of the object, a sensible comparison can be computed
+    * using {@link #compare(Object, Object)} method.
+    *
+    * @param obj instance to check if it's comparable
+    * @return <code>true</code> if the object is comparable;
+    *         <code>false</code> otherwise
+    */
+   boolean isComparable(Object obj); // For future support for objects that are not comparable, i.e. arrays
+
+   /**
+    * Compares the two given objects for order. Returns a negative integer,
+    * zero, or a positive integer as the first object is less than, equal to,
+    * or greater than the second object.
+    *
+    * @param obj first object to be compared
+    * @param otherObj second object to be compared
+    * @return a negative integer, zero, or a positive integer as the
+    *         first object is less than, equal to, or greater than the
+    *         second object
+    */
+   int compare(Object obj, Object otherObj); // For future support for objects that are not comparable, i.e. arrays
+
+}
+
+----
+
+ Implementations of these function can be pretty flexible. On one side, they could focus on a single, particular type, such as ByteArrayEquivalence below which expects nothing else other than byte arrays, such as in the case of Hot Rod based Infinispan remote caches: 
+
+
+----
+
+package com.acme;
+
+public class ByteArrayEquivalence implements Equivalence<byte[]> {
+
+   public static final Equivalence<byte[]> INSTANCE = new ByteArrayEquivalence();
+
+   @Override
+   public int hashCode(Object obj) {
+      return 41 + Arrays.hashCode((byte[]) obj);
+   }
+
+   @Override
+   public boolean equals(byte[] obj, Object otherObj) {
+      if (obj == otherObj) return true;
+      if (obj == null) return false;
+      if (otherObj == null || byte[].class != otherObj.getClass()) return false;
+      byte[] otherByteArray = (byte[]) otherObj;
+      return Arrays.equals(obj, otherByteArray);
+   }
+
+   @Override
+   public String toString(Object obj) {
+      return Arrays.toString((byte[]) obj);
+   }
+
+   @Override
+   public boolean isComparable(Object obj) {
+      return false;
+   }
+
+   @Override
+   public int compare(Object obj, Object otherObj) {
+      return 0; // irrelevant
+   }
+
+}
+
+----
+
+ Or you could have implementations that support multiple different types, in case you store varied information, for example link:$$https://github.com/infinispan/infinispan-server/blob/master/infinispan/src/main/java/org/jboss/as/clustering/infinispan/equivalence/AnyServerEquivalence.java$$[AnyServerEquivalence] which supports both arrays and normal objects: 
+
+
+----
+
+public class AnyServerEquivalence implements Equivalence<Object> {
+
+    private static boolean isByteArray(Object obj) {
+        return byte[].class == obj.getClass();
+    }
+
+    @Override
+    public int hashCode(Object obj) {
+        if (isByteArray(obj)) {
+            return 41 + Arrays.hashCode((byte[]) obj);
+        } else {
+            return obj.hashCode();
+        }
+    }
+
+    @Override
+    public boolean equals(Object obj, Object otherObj) {
+        if (obj == otherObj)
+            return true;
+        if (obj == null || otherObj == null)
+            return false;
+        if (isByteArray(obj) && isByteArray(otherObj))
+            return Arrays.equals((byte[]) obj, (byte[]) otherObj);
+        return obj.equals(otherObj);
+    }
+
+    @Override
+    public String toString(Object obj) {
+        if (isByteArray(obj))
+            return Arrays.toString((byte[]) obj);
+        else
+            return obj.toString();
+    }
+
+    @Override
+    public boolean isComparable(Object obj) {
+        return obj instanceof Comparable;
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public int compare(Object obj, Object otherObj) {
+       return ((Comparable<Object>) obj).compareTo(otherObj);
+    }
+
+}
+
+----
+
+[[sid-68355127_Storingobjects%28e.g.arrays%29withcustomEquivalencefunctions-ConfiguringEquivalencefunctions]]
+
+
+==== Configuring Equivalence functions
+
+[[sid-68355127_Storingobjects%28e.g.arrays%29withcustomEquivalencefunctions-UsingXML]]
+
+
+===== Using XML
+
+ The way to configure Infinispan with these Equivalence implementations is by adding them to the &lt;dataContainer&gt; XML element. For example, if we wanted to have byte array based keys, but the values would be normal objects, we'd define: 
+
+
+----
+
+<dataContainer keyEquivalence="com.acme.ByteArrayEquivalence" />
+
+----
+
+ If you were trying to store both byte arrays as keys and values, you'd configure valueEquivalence attribute in &lt;dataContainer&gt; XML element: 
+
+
+----
+
+<dataContainer keyEquivalence="com.acme.ByteArrayEquivalence" valueEquivalence="com.acme.ByteArrayEquivalence" />
+
+----
+
+ If no key or value equivalence is configured, they default to 
+                link:$$https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/util/AnyEquivalence.java$$[org.infinispan.util.AnyEquivalence]
+               , which behaves like any standard java object, delegating the equals/hashCode() calls to the objects themselves. 
+
+[[sid-68355127_Storingobjects%28e.g.arrays%29withcustomEquivalencefunctions-UsingProgrammaticConfiguration]]
+
+
+===== Using Programmatic Configuration
+
+Key and/or value equivalence could also have been configured programmatically, for example:
+
+
+----
+
+EmbeddedCacheManager cacheManager = ...;
+ConfigurationBuilder builder = new ConfigurationBuilder();
+builder.dataContainer()
+   .keyEquivalence(com.acme.ByteArrayEquivalence.INSTANCE)
+   .valueEquivalence(com.acme.ByteArrayEquivalence.INSTANCE);
+cacheManager.defineConfiguration("myCache", builder.build());
+
+----
+
+[[sid-68355127_Storingobjects%28e.g.arrays%29withcustomEquivalencefunctions-Bytearraystorageexample]]
+
+
+==== Byte array storage example
+
+ Assuming you've configured both keyEquivalence (via XML, or programmatically) to be com.acme.ByteArrayEquivalence , you should now be able to write code like this and get the assertion to succeed. If keyEquivalence has not been configured correctly, this test will fail: 
+
+
+----
+
+Cache<byte[], byte[]> cache = ...
+byte[] key = {1, 2, 3};
+byte[] value = {4, 5, 6};
+cache.put(key, value);
+
+byte[] expectedValue = {4, 5, 6};
+byte[] lookupKey = {1, 2, 3};
+assert Arrays.equals(expectedValue, cache.get(lookupKey));
+
+----
+
+[[sid-68355127_Storingobjects%28e.g.arrays%29withcustomEquivalencefunctions-OthermethodsinEquivalenceinterface]]
+
+
+==== Other methods in Equivalence interface
+
+ Finally, Equivalence defines some extra methods, such as toString(Object obj) , isComparable(Object obj) and compare(Object obj, Object otherObj) , which again can be used to provide different implementations to the ones provided for the JDK. For example, the toString() method can be used to provide a different String representation of the object, which is again useful for arrays since the default JDK implementation does not print the array contents. The comparable functions are not yet used by Infinispan but they've been defined in order to help with potential future support of tree-based storage in inner data structures. 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-73-Interoperability_between_Embedded_and_Remote_Server_Endpoints.adoc b/documentation/src/main/asciidoc/user_guide/chapter-73-Interoperability_between_Embedded_and_Remote_Server_Endpoints.adoc
new file mode 100644
index 0000000..795c7ce
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-73-Interoperability_between_Embedded_and_Remote_Server_Endpoints.adoc
@@ -0,0 +1,73 @@
+[[sid-68355128]]
+
+==  Interoperability between Embedded and Remote Server Endpoints
+
+ Infinispan offers the possibility to store and retrieve data in a link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=5931885$$[local, embedded way] , and also link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737048$$[remotely thanks to the multiple endpoints offered] , but until now if you choose one way to access the data, you were stuck with it. For example, you could not store data using the embedded interface and retrieve it via REST. 
+
+Starting with Infinispan 5.3, it is now possible to configure Infinispan caches to work in a special, compatibility mode for those users interested in accessing Infinispan in multiple ways. Achieving such compatibility requires extra work from Infinispan in order to make sure that contents are converted back and forth between the different formats of each endpoint and this is the reason why compatibility mode is disabled by default.
+
+[[sid-68355128_InteroperabilitybetweenEmbeddedandRemoteServerEndpoints-EnableCompatibilityMode]]
+
+
+=== Enable Compatibility Mode
+
+ For compatibility mode to work as expected, all endpoints need to be configured with the same cache manager, and need to talk to the same cache. If you're using the brand new link:$$http://www.jboss.org/infinispan/downloads$$[Infinispan Server distribution] , this is all done for you. If you're in the mood to experiment with this in a standalone unit test, link:$$https://github.com/infinispan/infinispan/blob/master/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility/CompatibilityCacheFactory.java$$[this class] shows you how you can start multiple endpoints from a single class. 
+
+So, to get started using Infinispan's compatibility mode, it needs to be enabled, either via XML:
+
+
+----
+
+<namedCache...>
+   <compatibility enabled="true"/>
+</namedCache>
+
+----
+
+Or programmatically:
+
+
+----
+
+ConfigurationBuilder builder = ...
+builder.compatibility().enable();
+
+----
+
+The key thing to remember about Infinispan's compatibility mode is that where possible, it tries to store data unmarshalling or deserializing it. It does so because the most common use case is for it to store Java objects and having Java objects stored in deserialized form means that they're very easy to use from an embedded cache. With this in mind, it makes some assumptions. For example, if something it's stored via Hot Rod, it's most likely coming from the reference Hot Rod client, which is written in Java, and which uses a marshaller that keeps binary payloads very compact. So, when the Hot Rod operation reaches the compatibility layer, it will try to unmarshall it, by default using the same default marshaller used by the Java Hot Rod client, hence providing good out-of-the-box support for the majority of cases.
+
+[[sid-68355128_InteroperabilitybetweenEmbeddedandRemoteServerEndpoints-Optional%3AConfiguringCompatibilityMarshaller]]
+
+
+==== Optional: Configuring Compatibility Marshaller
+
+ It could happen though the client might be using a Hot Rod client written for another language other than Java, say link:$$https://github.com/infinispan/ruby-client$$[Ruby] or link:$$https://github.com/infinispan/python-client$$[Python] . In this case, some some kind of custom marshaller needs to be configured that either translates that serialized payload into a Java object to be stored in the cache, or keeps it in serialized form. Both options are valid, but of course it will have an impact on what kind of objects are retrieved from Infinispan if using the embedded cache. The marshaller is expected to implement link:$$http://docs.jboss.org/infinispan/5.3/apidocs/org/infinispan/marshall/Marshaller.html$$[this interface] . Configuring the compatibility marshaller is optional and can be done via XML: 
+
+
+----
+
+<namedCache...>
+   <compatibility enabled="true" marshallerClass="com.acme.CustomMarshaller"/>
+</namedCache>
+
+----
+
+Or programmatically:
+
+
+----
+
+ConfigurationBuilder builder = ...
+builder.compatibility().enable().marshaller(new com.acme.CustomMarshaller());
+
+----
+
+ One concrete example of this marshaller logic can be found in the link:$$https://github.com/infinispan/infinispan/blob/master/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility/EmbeddedRestMemcachedHotRodTest.java#L161$$[SpyMemcachedCompatibleMarshaller] . link:$$https://code.google.com/p/spymemcached/$$[Spy Memcached] uses their own transcoders in order to marshall objects, so the compatibility marshaller created is in charge of marshalling/unmarshalling data stored via Spy Memcached client. If you want to retrieve data stored via Spy Memcached via say Hot Rod, you can link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737142$$[configure the Java Hot Rod client to use this same marshaller] , and this is precisely what the test where the Spy Memcached marshaller is located is demonstrating. 
+
+[[sid-68355128_InteroperabilitybetweenEmbeddedandRemoteServerEndpoints-Codeexamples]]
+
+
+=== Code examples
+
+ The best code examples available showing compatibility in action can be found in the link:$$https://github.com/infinispan/infinispan/tree/master/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility$$[Infinispan Compatibility Mode testsuite] , but more will be developed in the near future. 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-74-Infinispan_for_HTTP_session_clustering_and_caching.adoc b/documentation/src/main/asciidoc/user_guide/chapter-74-Infinispan_for_HTTP_session_clustering_and_caching.adoc
new file mode 100644
index 0000000..a009624
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-74-Infinispan_for_HTTP_session_clustering_and_caching.adoc
@@ -0,0 +1,45 @@
+[[sid-68355129]]
+
+==  Infinispan for HTTP session clustering and caching
+
+One popular use case for data grids is to cache and cluster HTTP sessions in servlet containers.  This provides servlet containers and Java EE application servers with the following features:
+
+
+* Fast access to HTTP sessions, as they're cached in memory
+
+
+* Distribution of HTTP sessions across a cluster.  Allows for failover and high availability between servlet container or app server nodes.
+
+[[sid-68355129_InfinispanforHTTPsessionclusteringandcaching-JBossASandWildFly]]
+
+
+=== JBoss AS and WildFly
+
+ link:$$http://www.jboss.org/jbossas$$[JBoss AS] and link:$$http://www.wildfly.org$$[WildFly] already use Infinispan for HTTP session caching and clustering. 
+
+[[sid-68355129_InfinispanforHTTPsessionclusteringandcaching-Jetty]]
+
+
+=== Jetty
+
+ link:$$http://www.eclipse.org/jetty$$[Jetty] can be set up to use Infinispan for HTTP session management, using link:$$https://code.google.com/p/infinispan-http-session-manager/wiki/Home$$[this adapter] . 
+
+[[sid-68355129_InfinispanforHTTPsessionclusteringandcaching-Otherapplicationserversandservletcontainers]]
+
+
+=== Other application servers and servlet containers
+
+Creating plugins for other servlet containers and app servers should be easy enough, following the pattern used by JBossAS/WildFly/Jetty above.  Please see the open tasks below, contributions accepted!
+
+
+*  link:$$https://issues.jboss.org/browse/ISPN-462$$[ISPN-462 HTTP and EJB session management for WebSphere] 
+
+
+*  link:$$https://issues.jboss.org/browse/ISPN-463$$[ISPN-463 HTTP and EJB session management for WebLogic] 
+
+
+*  link:$$https://issues.jboss.org/browse/ISPN-464$$[ISPN-464 HTTP and EJB session management for Glassfish] 
+
+
+*  link:$$https://issues.jboss.org/browse/ISPN-465$$[ISPN-465 HTTP session management for Tomcat] 
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-75-Infinispan_with_Groovy.adoc b/documentation/src/main/asciidoc/user_guide/chapter-75-Infinispan_with_Groovy.adoc
new file mode 100644
index 0000000..dcb59b7
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-75-Infinispan_with_Groovy.adoc
@@ -0,0 +1,546 @@
+[[sid-68355110]]
+
+==  Infinispan with Groovy
+
+[[sid-68355110_InfinispanwithGroovy-Introduction]]
+
+
+=== Introduction
+
+ The idea by this tutorial is to give an introduction in the use of the link:$$http://infinispan.sourceforge.net/4.0/apidocs/$$[Infinispan API] and its configuration file. As trying to do it in a more interactive fashion, the tutorial makes use of the link:$$http://groovy.codehaus.org/$$[Groovy] dynamic language that will allow to interact with the API by using a console. So your first task should be to create the necessary environment to execute this tutorial, you can find the instructions link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737125$$[here] . 
+
+ The tutorial will start by showing the basic usage of the link:$$http://infinispan.sourceforge.net/4.0/apidocs/$$[Infinispan API] and a use of a simple cache configuration, then it will walk through different configuration scenarios and use cases. By the end of the tutorial you should have a clear understanding of the use the Infinispan API and some of the various configuration options. 
+
+The scenarios and use cases shown are:
+
+
+* Basic cache configuration
+
+
+* Cache with transaction management configuration
+
+
+* Cache with a cache store configuration
+
+
+* Cache with eviction configuration
+
+
+* Cache with eviction and cache store configuration
+
+
+* Cache with REPL_SYNC &amp; transaction management configuration.
+
+ All the sample configurations are in the sample-configurations.xml file attached to this tutorial, check the link:$$http://infinispan.sourceforge.net/4.0/apidocs/$$[environment configuration] to know how to make use of this configuration file. Lets get started: 
+
+ _NOTE:_ This document is part of the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3736106$$[Infinispan Interactive Tutorial] 
+
+[[sid-68355110_InfinispanwithGroovy-Introductionx]]
+
+
+==== Introduction
+
+The Infinispan tutorial makes use of Groovy to get a more interactive experience when starting to learn about how to use the Infinispan API. So you will need to install a few prerequisites before getting started:
+
+
+*  The Groovy Platform, link:$$http://dist.groovy.codehaus.org/distributions/groovy-binary-1.6.3.zip$$[I used Groovy 1.6.3] 
+
+
+* Java and Infinispan
+
+ Download those and extract/install where you feel appropriate, depending on your operating system and personal preferences you will either have installers or compressed distributions. You can read more about read installing Java and Infinispan in link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737054$$[Installing Infinispan for the tutorials] . 
+
+[[sid-68355110_InfinispanwithGroovy-InstallingGroovy]]
+
+
+==== Installing Groovy
+
+You can use the installer or compressed file to install the Groovy Platform, I used the compressed file and decompressed at C:\Program Files\groovy\groovy-1.6.3. Once you have installed the Groovy Platform you should set some environment variables:
+
+
+
+
+----
+GROOVY_HOME=C:\Program Files\groovy\groovy-1.6.3
+----
+
+ and add to the PATH environment variable: 
+
+
+----
+PATH=%PATH%;%GROOVY_HOME%\bin
+----
+
+ test that everything is correct by executing in a Command Shell/Terminal the commands shown: 
+
+
+----
+$> groovy -v
+Groovy Version: 1.6.3 JVM: 1.6.0_14
+----
+
+If you get a similar result as shown, everything went well.
+
+[[sid-68355110_InfinispanwithGroovy-InstallingInfinispan]]
+
+
+==== Installing Infinispan
+
+Now you should add the Infinispan libraries to the Groovy Platform so you will able to access the API from the Groovy console. Add the infinispan-core.jar and its dependencies to the $USER_HOME/.groovy/lib directory, the jar is located in $INFINISPAN_HOME/modules/core and the dependencies at $INIFINISPAN_HOME/modules/core/lib.
+
+ For example, on Windows, you need to copy it to: 
+
+
+----
+C:\Documents and Settings\Alejandro Montenegro\.groovy\lib
+
+----
+
+ or on Linux: 
+
+
+----
+/home/amontenegro/.groovy/lib
+
+----
+
+and $INFINISPAN_HOME is where you decompressed the Infinispan distribution.
+
+To test the installation, download the attached file infinispantest.groovy and in a Command Shell/Terminal execute
+
+
+----
+$> groovy infinispantest
+4.0.0.ALPHA5
+----
+
+[[sid-68355110_InfinispanwithGroovy-Settingtheclasspath]]
+
+
+==== Setting the classpath
+
+The last thing to do is to add to the CLASSPATH environment variable the sample configuration file, this file contains definitions of cache's that will be used in the tutorial. I created the directory $USER_HOME/.groovy/cp and added it to the classpath
+
+ For example, on Windows: 
+
+
+----
+CLASSPATH=%CLASSPATH%;C:\Documents and Settings\Alejandro Montenegro\.groovy\cp
+
+----
+
+ or, on Linux: 
+
+
+----
+CLASSPATH=$CLASSPATH:/home/amontenegro/.groovy/cp
+
+----
+
+finally add the sample-configurations.xml and infinispan-config-4.0.xsd files(attached) to the directory.
+
+[[sid-68355110_InfinispanwithGroovy-Loadingtheconfigurationfile]]
+
+
+=== Loading the configuration file
+
+ The link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/manager/CacheManager.html$$[cache manager] is the responsible to manage all the link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/Cache.html$$[cache's] , so you have to start by indicating where to get the cache definitions to the link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/manager/CacheManager.html$$[cache manager] , remember that the cache definitions are in the sample-configurations.xml file. If no cache definitions are indicated, the link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/manager/CacheManager.html$$[cache manager] will use a default cache. 
+
+ Start by open a groovy console by typing groovy.sh in a command shell or terminal. You should now have something similar to: 
+
+
+[listing]
+....
+Groovy Shell (1.6.3, JVM: 1.6.0_14)
+Type 'help' or '\h' for help.
+-------------------------------------------------------
+groovy:000>
+
+....
+
+ It's time to start typing some commands, first start by importing the necessary libraries 
+
+
+----
+groovy:000> import org.infinispan.*
+=== > [import org.infinispan.*]
+groovy:000> import org.infinispan.manager.*
+=== > [import org.infinispan.*, import org.infinispan.manager.*]
+
+----
+
+And now, create a cache manager indicating the file with the cache definitions.
+
+
+
+
+----
+groovy:000> manager = new DefaultCacheManager("sample-configurations.xml")
+=== > org.infinispan.manager.DefaultCacheManager@19cc1b@Address:null
+----
+
+the cache manager has now the knowledge of all the named caches defined in the configuration file and also has a no named cache that's used by default. You can now access any of the cache's by interacting with the cache manager as shown.
+
+
+----
+groovy:000> defaultCache = manager.getCache()
+=== > Cache 'org.infinispan.manager.DefaultCacheManager.DEFAULT_CACHE_NAME'@7359733
+//TO GET A NAMED CACHE
+groovy:000> cache = manager.getCache("NameOfCache")
+
+----
+
+[[sid-68355110_InfinispanwithGroovy-Basiccacheconfiguration]]
+
+
+=== Basic cache configuration
+
+ The basic configuration, is the simplest configuration that you can have, its make use of default settings for the properties of the cache configuration, the only thing you have to set is the name of the cache. 
+
+
+----
+<namedCache name="Local"/>
+
+----
+
+ That's all you have to add to the configuration file to have a simple named cache, now its time to interact with the cache by using the Infinispan API. Lets start by getting the named cache and put some objects inside it. 
+
+
+----
+//START BY GETTING A REFERENCE TO THE NAMED CACHE
+groovy:000> localCache = manager.getCache("Local")
+=== > Cache 'Local'@19521418
+//THE INITIAL SIZE IS 0
+groovy:000> localCache.size()
+=== > 0
+//NOW PUT AN OBJECT INSIDE THE CACHE
+groovy:000> localCache.put("aKey", "aValue")
+=== > null
+//NOW THE SIZE IS 1
+groovy:000> localCache.size()
+=== > 1
+//CHECK IF IT HAS OUR OBJECT
+groovy:000> localCache.containsKey("aKey")
+=== > true
+//BY OBTAINING AN OBJECT DOESN'T MEAN TO REMOVE
+groovy:000> localCache.get("aKey")
+=== > aValue
+groovy:000> localCache.size()
+=== > 1
+//TO REMOVE ASK IT EXPLICITLY
+groovy:000> localCache.remove("aKey")
+=== > aValue
+groovy:000> localCache.isEmpty()
+=== > true
+
+----
+
+So you have seen the basic of the Infinispan API, adding, getting and removing from the cache, there is more, but don't forget that you are working with a cache that are an extension of java.util.ConcurrentHasMap and the rest of the API is as simple as the one shown above, many of the cool things in Infinispan are totally transparent (that's actually the coolest thing about Infinispan) and depends only on the configuration of your cache.
+
+ If you check the Infinispan JavaDoc you will see that the Cache#put() method has been overridden several times. 
+
+
+----
+//YOU WILL NEED TO IMPORT ANOTHER LIBRARY
+groovy:000> import java.util.concurrent.TimeUnit
+=== > [import org.infinispan.*, import org.infinispan.manager.*, import java.util.concurrent.TimeUnit]
+//NOTHING NEW HERE JUST PUTTING A NEW OBJECT
+groovy:000> localCache.put("bKey", "bValue")
+=== > null
+//WOW! WHATS HAPPEN HERE? PUTTED A NEW OBJECT BUT IT WILL TIMEOUT AFTER A SECOND
+groovy:000> localCache.put("timedKey", "timedValue", 1000, TimeUnit.MILLISECONDS)
+=== > null
+//LETS CHECK THE SIZE
+groovy:000> localCache.size()
+=== > 2
+//NOW TRY TO GET THE OBJECT, OOPS ITS GONE! (IF NOT, IT'S BECAUSE YOU ARE A SUPERTYPER, CALL GUINNESS!))
+groovy:000> localCache.get("timedKey")
+=== > null
+//LETS CHECK THE SIZE AGAIN, AS EXPECTED THE SIZE DECREASED BY 1
+groovy:000> localCache.size()
+=== > 1
+
+----
+
+ The Infinispan API also allows you to manage the life cycle of the cache, you can stop and start a cache but by default you will loose the content of the cache except if you configure a cache store, more about that later in the tutorial. lets check what happens when you restart the cache 
+
+
+----
+groovy:000> localCache.size()
+=== > 1
+//RESTARTING CACHE
+groovy:000> localCache.stop()
+=== > null
+groovy:000> localCache.start()
+=== > null
+//DAMN! LOST THE CONTENT OF THE CACHE
+groovy:000> localCache.size()
+=== > 0
+----
+
+Thats all related to the use of the Infinispan API, now lets check some different behaviors depending on the configuration of the cache.
+
+[[sid-68355110_InfinispanwithGroovy-Cachewithtransactionmanagement]]
+
+
+=== Cache with transaction management
+
+You are able to specify the cache to use a transaction manager, and even explicitly control the transactions. Start by configuring the cache to use a specific TransactionManagerLookup class. Infinispan implements a couple TransactionManagerLookup classes.
+
+
+*  link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/transaction/lookup/DummyTransactionManagerLookup.html$$[org.infinispan.transaction.lookup.DummyTransactionManagerLookup] 
+
+
+*  link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/transaction/lookup/GenericTransactionManagerLookup.html$$[org.infinispan.transaction.lookup.GenericTransactionManagerLookup] 
+
+
+*  link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/transaction/lookup/JBossStandaloneJTAManagerLookup.html$$[org.infinispan.transaction.lookup.JBossStandaloneJTAManagerLookup] 
+
+
+*  link:$$http://infinispan.sourceforge.net/4.0/apidocs/org/infinispan/transaction/lookup/JBossTransactionManagerLookup.html$$[org.infinispan.transaction.lookup.JBossTransactionManagerLookup] 
+
+Each use different methods to lookup the transaction manager, depending on the environment you are running Infinispan you should figure out which one to use. Check the JavaDoc for more details.
+
+ For the tutorial its enough to use: 
+
+
+----
+<namedCache name="LocalTX">
+    <transaction transactionManagerLookupClass="org.infinispan.transaction.lookup.DummyTransactionManagerLookup"/>
+</namedCache>
+
+----
+
+ Lets check how to interact with the Transaction Manager and to have the control over a transaction 
+
+
+----
+groovy:000> import javax.transaction.TransactionManager
+=== > [import org.infinispan.*, import org.infinispan.manager.*, import java.util.concurrent.TimeUnit, import javax.transaction.TransactionManager]
+//GET A REFERENCE TO THE CACHE WITH TRANSACTION MANAGER
+groovy:000> localTxCache = manager.getCache("LocalTX")
+=== > Cache 'LocalTX'@16075230
+groovy:000> cr = localTxCache.getComponentRegistry()
+=== > org.infinispan.factories.ComponentRegistry@87e9bf
+//GET A REFERENCE TO THE TRANSACTION MANAGER
+groovy:000> tm = cr.getComponent(TransactionManager.class)
+=== > org.infinispan.transaction.tm.DummyTransactionManager@b5d05b
+//STARTING A NEW TRANSACTION
+groovy:000> tm.begin()
+=== > null
+//PUTTING SOME OBJECTS INSIDE THE CACHE
+groovy:000> localTxCache.put("key1", "value1")
+=== > null
+//MMM SIZE DOESN'T INCREMENT
+groovy:000> localTxCache.size()
+=== > 1
+//LETS TRY AGAIN
+groovy:000> localTxCache.put("key2", "value2")
+=== > null
+//MMM NOTHING..
+groovy:000> localTxCache.size()
+=== > 2
+//OH! HAS TO DO THE COMMIT
+groovy:000> tm.commit()
+=== > null
+//AND THE SIZE IS AS EXPECTED.. HAPPY!
+groovy:000> localTxCache.size()
+=== > 2
+
+----
+
+As shown in the example, the transaction is controlled explicitly and the changes in the cache wont be reflected until you make the commit.
+
+[[sid-68355110_InfinispanwithGroovy-Cachewithacachestore]]
+
+
+=== Cache with a cache store
+
+Infinispan allows you to configure a persistent store that can be used to persist the content of the cache, so if the cache is restarted the cache will be able to keep the content. It can also be used if you want to limit the size of the cache, then the cache will start putting the objects in the store to keep the size limit, more on that when looking at the eviction configuration.
+
+Infinispan provides several cache store implementations:
+
+
+* FileCacheStore
+
+
+* JdbcBinaryCacheStore
+
+
+* JdbcMixedCacheStore
+
+
+* JdbcStringBasedCacheStore
+
+
+* JdbmCacheStore
+
+
+* S3CacheStore
+
+
+* BdbjeCacheStore
+
+ The tutorial uses the FileCacheStore, that saves the objects in files in a configured directory, in this case the /tmp directory. If the directory is not set it defaults to Infinispan-FileCacheStore in the current working directory. 
+
+
+----
+<namedCache name="CacheStore">
+     <loaders passivation="false" shared="false" preload="true">
+          <loader class="org.infinispan.loaders.file.FileCacheStore" fetchPersistentState="true"
+               ignoreModifications="false" purgeOnStartup="false">
+            <properties>
+                 <property name="location" value="/tmp"/>
+               </properties>
+          </loader>
+     </loaders>
+</namedCache>
+----
+
+Now you have a cache with persistent store, lets try it to see how it works
+
+
+----
+//GETTING THE NEW CACHE
+groovy:000> cacheCS = manager.getCache("CacheStore")
+=== > Cache 'CacheStore'@23240342
+//LETS PUT AN OBJECT INSIDE THE CACHE
+groovy:000> cacheCS.put("storedKey", "storedValue")
+=== > null
+//LETS PUT THE SAME OBJECT IN OUR BASIC CACHE
+groovy:000> localCache.put("storedKey", "storedValue")
+=== > storedValue
+//RESTART BOTH CACHES
+groovy:000> cacheCS.stop()
+=== > null
+groovy:000> localCache.stop()
+=== > null
+groovy:000> cacheCS.start()
+=== > null
+groovy:000> localCache.start()
+=== > null
+//LETS TRY GET THE OBJECT FROM THE RESTARTED BASIC CACHE.. NO LUCK
+groovy:000> localCache.get("storedKey")
+=== > null
+//INTERESTING CACHE SIZE IS NOT CERO
+groovy:000> cacheCS.size()
+=== > 1
+//WOW! JUST RESTARTED THE CACHE AND THE OBKECT KEEPS STAYING THERE!
+groovy:000> cacheCS.get("storedKey")
+=== > storedValue
+
+----
+
+[[sid-68355110_InfinispanwithGroovy-Cachewitheviction]]
+
+
+=== Cache with eviction
+
+The eviction allow to define policy for removing objects from the cache when it reach its limit, as the true is that the caches doesn't has unlimited size because of many reasons.  So the fact is that you normally will set a maximum number of objects in the cache and when that number is reached then the cache has to decide what to do when a new object is added. That's the whole story about eviction, to define the policy of removing object when the cache is full and want to keep putting objects. You have three eviction strategies:
+
+
+* NONE
+
+
+* FIFO
+
+
+* LRU
+
+ Let check the configuration of the cache: 
+
+
+----
+<namedCache name="Eviction">
+   <eviction wakeUpInterval="500" maxEntries="2" strategy="FIFO"/>
+</namedCache>
+----
+
+ The strategy has been set to FIFO, so the oldest objects will be removed first and the maximum number of objects are only 2, so it will be easy to show how it works 
+
+
+----
+//GETTING THE NEW CACHE
+groovy:000> evictionCache = manager.getCache("Eviction")
+=== > Cache 'Eviction'@5132526
+//PUT SOME OBJECTS
+groovy:000> evictionCache.put("key1", "value1")
+=== > null
+groovy:000> evictionCache.put("key2", "value2")
+=== > null
+groovy:000> evictionCache.put("key3", "value3")
+=== > null
+//HEY! JUST LOST AN OBJECT IN MY CACHE.. RIGHT, THE SIZE IS ONLY TWO
+groovy:000> evictionCache.size()
+=== > 2
+//LETS CHECK WHAT OBJECT WAS REMOVED
+groovy:000> evictionCache.get("key3")
+=== > value3
+groovy:000> evictionCache.get("key2")
+=== > value2
+//COOL! THE OLDEST WAS REMOVED
+groovy:000> evictionCache.get("key1")
+=== > null
+
+----
+
+Now you are sure that your cache wont consume all your memory and hang your system, but its an expensive price you have to pay for it, you are loosing objects in your cache. The good news is that you can mix cache store with the eviction policy and avoid loosing objects.
+
+[[sid-68355110_InfinispanwithGroovy-Cachewithevictionandcachestore]]
+
+
+=== Cache with eviction and cache store
+
+Ok, the cache has a limited size but you don't want to loose your objects in the cache. Infinispan is aware of these issues, so it makes it very simple for you combing the cache store with the eviction policy. When the cache is full it will persist an object and remove it from the cache, but if you want to recover an object that has been persisted the the cache transparently will bring it to you from the cache store.
+
+ The configuration is simple, just combine eviction and cache store configuration 
+
+
+----
+<namedCache name="CacheStoreEviction">
+     <loaders passivation="false" shared="false" preload="true">
+          <loader class="org.infinispan.loaders.file.FileCacheStore" fetchPersistentState="true"
+            ignoreModifications="false" purgeOnStartup="false">
+               <properties>
+                    <property name="location" value="/tmp"/>
+               </properties>
+          </loader>
+     </loaders>
+     <eviction wakeUpInterval="500" maxEntries="2" strategy="FIFO"/>
+</namedCache>
+----
+
+Nothing new in the configuration, lets check how it works
+
+
+----
+//GETTING THE CACHE
+groovy:000> cacheStoreEvictionCache = manager.getCache("CacheStoreEviction")
+=== > Cache 'CacheStoreEviction'@6208201
+//PUTTING SOME OBJECTS
+groovy:000> cacheStoreEvictionCache.put("cs1", "value1")
+=== > value1
+groovy:000> cacheStoreEvictionCache.put("cs2", "value2")
+=== > value2
+groovy:000> cacheStoreEvictionCache.put("cs3", "value3")
+=== > value3
+///MMM SIZE IS ONLY TWO, LETS CHECK WHAT HAPPENED
+groovy:000> cacheStoreEvictionCache.size()
+=== > 2
+groovy:000> cacheStoreEvictionCache.get("cs3")
+=== > value3
+groovy:000> cacheStoreEvictionCache.get("cs2")
+=== > value2
+//WOW! EVEN IF THE CACHE SIZE IS 2, I RECOVERED THE THREE OBJECTS.. COOL!!
+groovy:000> cacheStoreEvictionCache.get("cs1")
+=== > value1
+
+----
+
+[[sid-68355110_InfinispanwithGroovy-CachewithREPLSYNC%26transactionmanagement]]
+
+
+==== Cache with REPL_SYNC &amp; transaction management
+
+TODO
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-76-Infinispan_with_Scala.adoc b/documentation/src/main/asciidoc/user_guide/chapter-76-Infinispan_with_Scala.adoc
new file mode 100644
index 0000000..d7dfe05
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-76-Infinispan_with_Scala.adoc
@@ -0,0 +1,335 @@
+[[sid-68355111]]
+
+==  Infinispan with Scala
+
+[[sid-68355111_InfinispanwithScala-Introduction]]
+
+
+=== Introduction
+
+ This article shows how to use Infinispan with link:$$http://www.scala-lang.org/$$[Scala language] . It uses the same commands and configurations used in the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3736106$$[Groovy edition of interactive tutorial] . For more details about the scenarios and steps please visit about page since here will will only focus on Scala compatibility. 
+
+[[sid-68355111_InfinispanwithScala-Environment]]
+
+
+=== Environment
+
+ Preparing the environment is almost similar to one described here, but with a minor difference that unlike Groovy which uses _$$~/.groovy/lib$$_ folder to extend initial classpath, we will use classic _CLASSPATH_ environment variable with Scala. Another issue is that with the recent edition of Infinispan core jar file is in the root folder of $INIFINISPAN_HOME, hence here a sample bash script to prepare CLASSPATH for our demo: 
+
+
+----
+export INFINISPAN_HOME=~/build/infinispan/infinispan-4.2.1.CR1
+for j in $INFINISPAN_HOME/lib/*.jar; do CLASSPATH=$CLASSPATH:$j; done
+export CLASSPATH=$CLASSPATH:$INFINISPAN_HOME/infinispan-core.jar
+export CLASSPATH=$CLASSPATH:[Path to folder containing sample-configurations.xml file]
+----
+
+ Download*sample-configurations.xml*  file from link:$$https://docs.jboss.org/author/download/attachments/3737125/sample-configurations.xml?version=1&amp;modificationDate=1308852872000$$[here] . 
+
+[[sid-68355111_InfinispanwithScala-TestingSetup]]
+
+
+=== Testing Setup
+
+The following code shows how to start an Scala console that will allow commands to be entered interactively. To verify that the Infinispan classes have been imported correctly, an import for all Infinispan classes will be attempted and then a request will be made to print the version of Infinispan:
+
+
+----
+[z@dnb:~/Go/demos/interactive-infinispan-scala]% ./scala
+Welcome to Scala version 2.8.1.final (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_22).
+Type in expressions to have them evaluated.
+Type :help for more information.
+
+scala> import org.infinispan._
+import org.infinispan._
+
+scala> println(Version.version)
+4.2.1.CR1
+
+
+----
+
+[[sid-68355111_InfinispanwithScala-LoadingtheConfigurationfile]]
+
+
+=== Loading the Configuration file
+
+In this next example, a new cache manager will be created using the configuration file downloaded earlier:
+
+
+----
+scala> import org.infinispan.manager._                                   
+import org.infinispan.manager._
+
+scala> val manager = new DefaultCacheManager("sample-configurations.xml")
+manager: org.infinispan.manager.DefaultCacheManager = org.infinispan.manager.DefaultCacheManager@38b58e73@Address:null
+
+----
+
+Retrieving cache instances from cache manager
+
+In this example, the default cache is retrieved expecting keys and values to be of String type:
+
+
+----
+scala> val defaultCache = manager.getCache[String, String]()
+defaultCache: org.infinispan.Cache[String,String] = Cache '___defaultcache'@1326840752
+
+----
+
+In this next example, a named cache is retrieved, again with keys and values expected to be String:
+
+
+----
+scala> val namedCache = manager.getCache[String, String]("NameOfCache")
+namedCache: org.infinispan.Cache[String,String] = Cache 'NameOfCache'@394890130
+----
+
+[[sid-68355111_InfinispanwithScala-Basiccacheoperations]]
+
+
+=== Basic cache operations
+
+In this section, several basic operations will be executed against the cache that show how it can be populated with data, how data can be retrieved and size can be checked, and finally how after removing the data entered, the cache is empty:
+
+
+----
+scala> val localCache = manager.getCache[String, String]("Local")
+localCache: org.infinispan.Cache[String,String] = Cache 'Local'@420875876
+
+scala> localCache.size()
+res0: Int = 0
+
+scala> localCache.put("aKey", "aValue")
+res1: String = null
+// This null was returned by put() indicating that 
+// the key was not associated with any previous value.
+
+scala> localCache.size()
+res2: Int = 1
+
+scala> localCache.containsKey("aKey")
+res3: Boolean = true
+
+scala> localCache.get("aKey")
+res4: String = aValue
+
+scala> localCache.size()
+res5: Int = 1
+
+scala> localCache.remove("aKey")
+res6: String = aValue
+
+scala> localCache.isEmpty()
+res7: Boolean = true
+----
+
+[[sid-68355111_InfinispanwithScala-BasiccacheoperationswithTTL]]
+
+
+=== Basic cache operations with TTL
+
+When a cache entry is stored, a maximum lifespan for the entry can be provided. So, when that time is exceeded, the entry will dissapear from the cache:
+
+
+----
+scala> localCache.put("bKey", "bValue")
+res8: String = null
+
+scala> import java.util.concurrent.TimeUnit
+import java.util.concurrent.TimeUnit
+
+scala> localCache.put("timedKey", "timedValue", 1000, TimeUnit.MILLISECONDS)
+res9: String = null
+
+scala> localCache.size()
+res10: Int = 2
+
+scala> localCache.get("timedKey")
+res11: String = null
+
+scala> localCache.size()
+res12: Int = 1
+----
+
+[[sid-68355111_InfinispanwithScala-Cacherestarts]]
+
+
+=== Cache restarts
+
+When caches are local and not configured with a persistent store, restarting them means that the data is gone. To avoid this issue you can either configure caches to be clustered so that if one cache dissapears, the data is not completely gone, or configure the cache with a persistent cache store. The latter option will be explained later on.
+
+
+----
+scala> localCache.size()
+res13: Int = 1
+
+scala> localCache.stop()
+
+scala> localCache.start()
+
+scala> localCache.size()
+res16: Int = 0
+----
+
+[[sid-68355111_InfinispanwithScala-Transactionalcacheoperations]]
+
+
+=== Transactional cache operations
+
+Infinispan caches can be operated within a transaction, in such way that operations can be grouped in order to be executed atomically. The key thing to understand about transactions is that within the transactions changes are visible, but to other non-transactional operations, or other transactions, these are not visible until the transaction is committed. The following example shows how within a transaction an entry can be stored but outside the transaction, this modification is not yet visible, and that once the transaction is committed, the modification is visible to all:
+
+
+----
+scala> import javax.transaction.TransactionManager
+import javax.transaction.TransactionManager
+
+scala> val localTxCache = manager.getCache[String, String]("LocalTX")
+localTxCache: org.infinispan.Cache[String,String] = Cache 'LocalTX'@955386212
+
+scala> val tm = localTxCache.getAdvancedCache().getTransactionManager()
+tm: javax.transaction.TransactionManager = org.infinispan.transaction.tm.DummyTransactionManager@81ee8c1
+
+scala> tm.begin()
+
+scala> localTxCache.put("key1", "value1")
+res1: String = null
+
+scala> localTxCache.size()
+res2: Int = 1
+
+scala> tm.suspend()
+res3: javax.transaction.Transaction = DummyTransaction{xid=DummyXid{id=1}, status=0}
+
+scala> localTxCache.size()
+res4: Int = 0
+
+scala> localTxCache.get("key1")
+res5: String = null
+
+scala> tm.resume(res3)
+
+scala> localTxCache.size()
+res7: Int = 1
+
+scala> localTxCache.get("key1")
+res8: String = value1
+
+scala> tm.commit()
+
+scala> localTxCache.size()
+res10: Int = 1
+
+scala> localTxCache.get("key1")
+res11: String = value1
+
+----
+
+Note how this example shows a very interesting characteristic of the Scala console. Every operation's return value is stored in a temporary variable which can be referenced at a later stage, even if the user forgets to assign the result of a operation when the code was executed.
+
+[[sid-68355111_InfinispanwithScala-PersistentstoredbackedCacheoperations]]
+
+
+=== Persistent stored backed Cache operations
+
+When a cache is backed by a persistent store, restarting the cache does not lead to data being lost. Upon restart, the cache can retrieve in lazy or prefetched fashion cache entries stored in the backend persistent store:
+
+
+----
+scala> val cacheWithStore = manager.getCache[String, String]("CacheStore")
+cacheWithStore: org.infinispan.Cache[String,String] = Cache 'CacheStore'@2054925789
+
+scala> cacheWithStore.put("storedKey", "storedValue")
+res21: String = null
+
+scala> localCache.put("storedKey", "storedValue")
+res22: String = null
+
+scala> cacheWithStore.stop()
+
+scala> localCache.stop()
+
+scala> cacheWithStore.start()
+
+scala> localCache.start()
+
+scala> localCache.get("storedKey")
+res27: String = null
+
+scala> cacheWithStore.size()
+res28: Int = 1
+
+scala> cacheWithStore.get("storedKey")
+res29: String = storedValue
+
+----
+
+[[sid-68355111_InfinispanwithScala-Operatingagainstasizeboundedcache]]
+
+
+=== Operating against a size bounded cache
+
+Infinispan caches can be configured with a max number of entries, so if this is exceeded certain cache entries are evicted from in-memory cache. Which cache entries get evicted is dependant on the eviction algorithm chosen. In this particular example, FIFO algorithm has been configured, so when a cache entry needs to be evicted, those stored first will go first:
+
+
+----
+scala> val evictionCache = manager.getCache[String, String]("Eviction")
+evictionCache: org.infinispan.Cache[String,String] = Cache 'Eviction'@882725548
+
+scala> evictionCache.put("key1", "value1")
+res30: String = null
+
+scala> evictionCache.put("key2", "value2")
+res31: String = null
+
+scala> evictionCache.put("key3", "value3")
+res32: String = null
+
+scala> evictionCache.size()
+res33: Int = 2
+
+scala> evictionCache.get("key3")
+res34: String = value3
+
+scala> evictionCache.get("key2")
+res35: String = value2
+
+scala> evictionCache.get("key1")
+res36: String = null
+----
+
+[[sid-68355111_InfinispanwithScala-Sizeboundedcacheswithpersistentstore]]
+
+
+=== Size bounded caches with persistent store
+
+When caches configured with eviction are configured with a persistent store as well, when the cache exceeds certain size, apart from removing the corresponding cache entries from memory, these entries are stored in the persistent store. So, if they're requested by cache operations, these are retrieved from the cache store:
+
+
+----
+scala> val cacheStoreEvictionCache = manager.getCache[String, String]("CacheStoreEviction")
+cacheStoreEvictionCache: org.infinispan.Cache[String,String] = Cache 'CacheStoreEviction'@367917752
+
+scala> cacheStoreEvictionCache.put("cs1", "value1")
+res37: String = null
+
+scala> cacheStoreEvictionCache.put("cs2", "value2")
+res38: String = null
+
+scala> cacheStoreEvictionCache.put("cs3", "value3")
+res39: String = null
+
+scala> cacheStoreEvictionCache.size()
+res40: Int = 2
+
+scala> cacheStoreEvictionCache.get("cs3")
+res41: String = value3
+
+scala> cacheStoreEvictionCache.get("cs2")
+res42: String = value2
+
+scala> cacheStoreEvictionCache.get("cs1")
+res43: String = value1
+
+----
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-77-Data_Versioning.adoc b/documentation/src/main/asciidoc/user_guide/chapter-77-Data_Versioning.adoc
new file mode 100644
index 0000000..ba87ac9
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-77-Data_Versioning.adoc
@@ -0,0 +1,81 @@
+[[sid-68355117]]
+
+==  Data Versioning
+
+[[sid-68355117_DataVersioning-Overview]]
+
+
+=== Overview
+
+Infinispan will offer three forms of data versioning, including simple, partition aware and external.  Each case is described in detail below.
+
+[[sid-68355117_DataVersioning-Simpleversioning]]
+
+
+==== Simple versioning
+
+The purpose of simple versioning is to provide a reliable mechanism of write skew checks when using optimistic transactions, REPEATABLE_READ and a clustered cache.  Write skew checks are performed at prepare-time to ensure a concurrent transaction hasn't modified an entry while it was read and potentially updated based on the value read.
+
+When operating in LOCAL mode, write skew checks rely on Java object references to compare differences and this is adequate to provide a reliable write-skew check, however this technique is useless in a cluster and a more reliable form of versioning is necessary to provide reliable write skew checks.
+
+ Simple versioning is an implementation of the proposed EntryVersion interface, backed by a long that is incremented each time the entry is updated. 
+
+[[sid-68355117_DataVersioning-Partitionawareversioning]]
+
+
+==== Partition-aware versioning
+
+ This versioning scheme makes use of link:$$http://en.wikipedia.org/wiki/Vector_clock$$[vector clocks] to provide a network partition resilient form of versioning. 
+
+Unlike simple versioning, which is maintained per entry, a vector clock's node counter is maintained per-node.
+
+[[sid-68355117_DataVersioning-Externalversioning]]
+
+
+==== External versioning
+
+This scheme is used to encapsulate an external source of data versioning within Infinispan, such as when using Infinispan with Hibernate which in turn gets it's data version information directly from a database.
+
+ In this scheme, a mechanism to pass in the version becomes necessary, and overloaded versions of put() and putForExternalRead() will be provided in AdvancedCache to take in an external data version.  This is then stored on the InvocationContext and applied to the entry at commit time. 
+
+Write skew checks cannot and will not be performed in the case of external data versioning.
+
+[[sid-68355117_DataVersioning-Tombstones]]
+
+
+==== Tombstones
+
+ To deal with deletions of entries, tombstones will be maintained as null entries that have been deleted, so that version information of the deleted entry can be maintained and write skews can still be detected.  However this is an expensive thing to do, and as such, is a configuration option, disabled by default. Further, tombstones will follow a strict lifespan and will be cleared from the system after a specific amount of time. 
+
+[[sid-68355117_DataVersioning-Configuration]]
+
+
+=== Configuration
+
+ By default versioning will be _disabled_ .  This will mean write skew checks when using transactions and _$$REPEATABLE_READ$$_ as an isolation level will be unreliable when used in a cluster.  Note that this doesn't affect single-node, LOCAL mode usage. 
+
+[[sid-68355117_DataVersioning-ViaXML]]
+
+
+==== Via XML
+
+
+----
+
+<versioning enabled="false" type="SIMPLE|PARTITION_AWARE|EXTERNAL" useTombstones="false" tombstoneLifespan="60000"/>
+
+----
+
+[[sid-68355117_DataVersioning-ViatheprogrammaticAPI]]
+
+
+==== Via the programmatic API
+
+
+----
+
+fluent().versioning().type(SIMPLE).useTombstones(true).tombstoneLifespan(1, TimeUnit.MINUTES);
+
+
+----
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-78-Infinispan_modules_for_JBoss_AS_7_x.adoc b/documentation/src/main/asciidoc/user_guide/chapter-78-Infinispan_modules_for_JBoss_AS_7_x.adoc
new file mode 100644
index 0000000..c8047ed
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-78-Infinispan_modules_for_JBoss_AS_7_x.adoc
@@ -0,0 +1,59 @@
+[[sid-68355119]]
+
+==  Infinispan modules for JBoss AS 7.x
+
+ Since Infinispan 5.2, the distribution includes a set of modules for JBoss AS 7.x. By installing these modules, it is possible to deploy user applications without packaging the Infinispan JARs within the deployments (WARs, EARs, etc), thus minimizing their size. In order not to conflict with the Infinispan modules which are already present within an AS installation, the modules provided by the Infinispan distribution are located within their own slot identified by the _major.minor_ versions (e.g. slot="5.2"). 
+
+In order to tell the AS deployer that we want to use the Infinispan APIs within our application, we need to add explicit dependencies to the deployment's MANIFEST:
+
+.MANIFEST.MF
+
+==== 
+----
+
+Manifest-Version: 1.0
+Dependencies: org.infinispan:5.2 services
+
+----
+
+==== 
+ If you are using Maven to generate your artifacts, mark the Infinispan dependencies as _provided_ and configure your artifact archiver to generate the appropriate MANIFEST.MF file: 
+
+.pom.xml
+
+==== 
+----
+
+<dependencies>
+  <dependency>
+    <groupId>org.infinispan</groupId>
+    <artifactId>infinispan-core</artifactId>
+    <version>5.2.0.Final</version>
+    <scope>provided</scope>
+  </dependency>
+  <dependency>
+    <groupId>org.infinispan</groupId>
+    <artifactId>infinispan-cachestore-jdbc</artifactId>
+    <version>5.2.0.Final</version>
+    <scope>provided</scope>
+  </dependency>
+</dependencies>
+<build>
+  <plugins>
+     <plugin>
+       <groupId>org.apache.maven.plugins</groupId>
+       <artifactId>maven-war-plugin</artifactId>
+       <configuration>
+         <archive>
+           <manifestEntries>
+             <Dependencies>org.infinispan:5.2 services, org.infinispan.cachestore.jdbc:5.2 services</Dependencies>
+           </manifestEntries>
+         </archive>
+      </configuration>
+    </plugin>
+  </plugins>
+</build>
+
+----
+
+==== 
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-8-Grid_File_System.adoc b/documentation/src/main/asciidoc/user_guide/chapter-8-Grid_File_System.adoc
new file mode 100644
index 0000000..f03b58e
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-8-Grid_File_System.adoc
@@ -0,0 +1,70 @@
+[[sid-68355033]]
+
+==  Grid File System
+
+Infinispan's GridFileSystem is a new, experimental API that exposes an Infinispan-backed data grid as a file system.  This API is available in Infinispan 4.1.0 (from 4.1.0.ALPHA2 onwards).
+
+ Specifically, the API works as an extension to the JDK's link:$$http://java.sun.com/javase/6/docs/api/java/io/File.html$$[File] , link:$$http://java.sun.com/javase/6/docs/api/java/io/InputStream.html$$[InputStream] and link:$$http://java.sun.com/javase/6/docs/api/java/io/OutputStream.html$$[OutputStream] classes: specifically, link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/io/GridFile.html$$[GridFile] , link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/io/GridInputStream.html$$[GridInputStream] and link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/io/GridOutputStream.html$$[GridOutputStream] .  A helper class, link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/io/GridFilesystem.html$$[GridFilesystem] , is also included. 
+
+ Essentially, the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/io/GridFilesystem.html$$[GridFilesystem] is backed by 2 Infinispan caches - one for metadata (typically replicated) and one for the actual data (typically distributed).  The former is replicated so that each node has metadata information locally and would not need to make RPC calls to list files, etc.  The latter is distributed since this is where the bulk of storage space is used up, and a scalable mechanism is needed here.  Files themselves are chunked and each chunk is stored as a cache entry, as a byte array. 
+
+Here is a quick code snippet demonstrating usage:
+
+
+----
+
+Cache<String,byte[]> data = cacheManager.getCache("distributed");
+Cache<String,GridFile.Metadata> metadata = cacheManager.getCache("replicated");
+GridFilesystem fs = new GridFilesystem(data, metadata);
+
+// Create directories
+File file=fs.getFile("/tmp/testfile/stuff");
+fs.mkdirs(); // creates directories /tmp/testfile/stuff
+
+// List all files and directories under "/usr/local"
+file=fs.getFile("/usr/local");
+File[] files=file.listFiles();
+
+// Create a new file
+file=fs.getFile("/tmp/testfile/stuff/README.txt");
+file.createNewFile();
+
+----
+
+Copying stuff to the grid file system:
+
+
+----
+InputStream in=new FileInputStream("/tmp/my-movies/dvd-image.iso");
+OutputStream out=fs.getOutput("/grid-movies/dvd-image.iso");
+byte[] buffer=new byte[20000];
+int len;
+while((len=in.read(buffer, 0, buffer.length)) != -1) out.write(buffer, 0, len);
+in.close();
+out.close();
+
+----
+
+Reading stuff from the grid:
+
+
+----
+InputStream in=in.getInput("/grid-movies/dvd-image.iso");
+OutputStream out=new FileOutputStream("/tmp/my-movies/dvd-image.iso");
+byte[] buffer=new byte[200000];
+int len;
+while((len=in.read(buffer, 0, buffer.length)) != -1) out.write(buffer, 0, len);
+in.close();
+out.close();
+
+----
+
+[[sid-68355033_GridFileSystem-WebDAVdemo]]
+
+
+=== WebDAV demo
+
+ Infinispan 4.1.0 also ships with a demo link:$$http://en.wikipedia.org/wiki/WebDAV$$[WebDAV] application that makes use of the grid file system APIs.  This demo app is packaged as a link:$$http://en.wikipedia.org/wiki/WAR_(Sun_file_format)$$[WAR] file which can be deployed in a servlet container, such as JBoss AS or Tomcat, and exposes the grid as a file system over WebDAV.  This could then be mounted as a remote drive on your operating system. 
+
+Here is a short video clip showcasing this demo:
+
diff --git a/documentation/src/main/asciidoc/user_guide/chapter-9-Infinispan_WebSocket_Server.adoc b/documentation/src/main/asciidoc/user_guide/chapter-9-Infinispan_WebSocket_Server.adoc
new file mode 100644
index 0000000..1b687a1
--- /dev/null
+++ b/documentation/src/main/asciidoc/user_guide/chapter-9-Infinispan_WebSocket_Server.adoc
@@ -0,0 +1,143 @@
+[[sid-68355034]]
+
+==  Infinispan WebSocket Server
+
+ The Infinispan WebSocket Server can be used to expose an Infinispan Cache instance over a link:$$http://dev.w3.org/html5/websockets/$$[WebSocket Interface] via a very simple Javascript "Cache" API.  The WebSocket Interface was introduced as part of the HTML 5 specification.  It defines a full-duplex communication channel to the browser, operating over a single socket (unlike Comet or Ajax) and is exposed to the browser via a Javascript interface. 
+
+[[sid-68355034_InfinispanWebSocketServer-StartingTheServer]]
+
+
+=== Starting The Server
+
+ The Infinispan WebSocket server is included in Infinispan distributions from _4.1.0.BETA1_ onwards, in both the -bin.zip and -all.zip archives.  To start the server, use the bin/startServer.sh (or bin\startServer.bat) command-line scripts, using the -r websocket switch. 
+
+
+----
+$ bin/startServer.sh -r websocket
+----
+
+ For more help on available switches, check out the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737161$$[server command line options article] . 
+
+[[sid-68355034_InfinispanWebSocketServer-JavascriptAPI]]
+
+
+=== Javascript API
+
+ Writing a web page that uses the Infinispan Cache API is trivial.  The page simply needs to include a &lt;script&gt; declaration for the infinispan-ws.js Javascript source file.  This script is served up by WebSocket Server. 
+
+ So, for loading infinispan-ws.js from a WebSocket Server instance running on _www.acme.com:8181_ (default port): 
+
+
+----
+<script type="text/javascript" src="<a href="http://www.acme.com:61999/infinispan-ws.js" target="_blank">http://www.acme.com:8181/infinispan-ws.js</a>" />
+----
+
+[[sid-68355034_InfinispanWebSocketServer-CreatingaClientSideCacheObjectInstance]]
+
+
+==== Creating a Client-Side Cache Object Instance
+
+ The client-side interface to a server-side Infinispan cache is the Cache Javascript object.  It can be constructed as follows: 
+
+
+----
+<script type="text/javascript">
+    var cache = new Cache();
+    
+    // etc...
+</script>
+----
+
+ By default, the Cache instance will interface to the default Infinispan Cache associated with the WebSocket Server from which the infinispan-ws.js Javascript source file was loaded.  So, in the above case, the Cache object instance will connect to the WebSocket Server running on _www.acme.com:8181_ (i.e. _ws://www.acme.com:8181_ ). 
+
+The Infinispan Cache name and WebSocket Server address can be specified in the {{Cache}  object constructor as follows:
+
+
+----
+var cache = new Cache("omCache", "ws://ws.acmews.com:8181");
+// etc...
+----
+
+[[sid-68355034_InfinispanWebSocketServer-CacheOperations]]
+
+
+==== Cache Operations
+
+ A number of cache operations can be performed via the Cache object instance such as _get_ , _put_ , _remove_ , _notify_ and _unnotify_ . 
+
+ The get and notify operations require a callback function to be registered with the Cache object instance.  This callback function receives all add/update/remove notifications on any cache entries for which the notify function was invoked.  It also asynchronously receives the result of a single invocation of the get function i.e. get can be thought of as "notify once, immediately". 
+
+ The callback function is registered with the Cache object instance via the registerCallback function.  The function should have 2 parameters - key and value , relating to the cache key and value. 
+
+
+----
+var cache = new Cache();
+
+// Ask to be notified about some cache entries...
+cache.notify("orderStatus");
+cache.notify("expectedDeliveryTime");
+
+// Register the callback function for receiving notifcations...
+cache.registerCallback(cacheCallback);
+
+// Cache callback function...
+function cacheCallback(key, value) {
+    // Handle notification...
+}
+
+----
+
+ Getting and updating data in the cache is done by simply calling the get , put and remove functions on the Cache object instance.  These operations could be triggered by user interaction with a web form e.g. 
+
+
+----
+<form onsubmit="return false;">
+
+    <!-- Other form components... -->
+
+    <!-- Buttons for making cache updates... -->
+    <input type="button" value="Put" 
+           onclick="cache.put(this.form.key.value, this.form.val.value)" />
+    <input type="button" value="Get" 
+           onclick="cache.get(this.form.key.value)" />
+    <input type="button" value="Remove" 
+           onclick="cache.remove(this.form.key.value)" />
+</form>
+
+----
+
+[[sid-68355034_InfinispanWebSocketServer-Samplecode]]
+
+
+=== Sample code
+
+ Infinispan's source tree contains a sample HTML document that makes use of the WebSocket server.  Browse through the source of this HTML document link:$$http://fisheye.jboss.org/browse/Infinispan/trunk/server/websocket/src/main/distribution/sample-websocket-client.html$$[here] . 
+
+[[sid-68355034_InfinispanWebSocketServer-BrowserSupport]]
+
+
+=== Browser Support
+
+ At the time of writing, Google Chrome was the only browser with native WebSocket support.  However, the link:$$http://jwebsocket.org/$$[jWebSocket] project provides a client side Javascript library that adds WebSocket support to any Flash enabled browser. 
+
+[[sid-68355034_InfinispanWebSocketServer-Screencast]]
+
+
+=== Screencast
+
+ See the following link:$$http://www.screencast.com/t/ZGEzNDJlY$$[demo of the Infinispan WebSocket Server] in action. 
+
+[[sid-68355034_InfinispanWebSocketServer-Status]]
+
+
+=== Status
+
+Prototype/Alpha.
+
+[[sid-68355034_InfinispanWebSocketServer-Source]]
+
+
+=== Source
+
+ link:$$https://github.com/infinispan/infinispan/tree/master/server/websocket$$[Browse Infinispan's Git repository] . 
+
