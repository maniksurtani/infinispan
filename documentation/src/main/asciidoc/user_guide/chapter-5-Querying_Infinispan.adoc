[[sid-18645131]]

==  Querying Infinispan

[[sid-18645131_QueryingInfinispan-Theinfinispanquerymodule]]


=== The infinispan-query module

 This module adds querying capabilities to Infinispan. It uses link:$$https://www.hibernate.org/410.html$$[Hibernate Search] and link:$$http://lucene.apache.org/java/docs/index.html$$[Apache Lucene] to index and search objects in the cache. It allows users to obtain objects within the cache without needing to know the keys to each object that they want to obtain, so you can now search your objects basing on some of it's properties, for example to retrieve all red cars (exact metadata match), or all books about a specific topic (full text search and relevance scoring). 

[[sid-18645131_QueryingInfinispan-UsagewithInfinispan5]]


==== Usage with Infinispan 5

Indexing must be enabled in the configuration (as explained in the next paragraph); then you interact with the Search capabilities via a SearchManager which exposes all needed functionality.

[[sid-18645131_QueryingInfinispan-Simpleexample]]


=== Simple example

 We're going to store _Book_ instances in Infinispan; each _Book_ will be defined as in the following example; we have to choose which properties are indexed, and for each property we can optionally choose advanced indexing options using the annotations defined in the Hibernate Search project. 


----
// example values stored in the cache and indexed:
import org.hibernate.search.annotations.*;

//to be indexed the object needs both @Indexed and @ProvidedId annotations:
@Indexed @ProvidedId
public class Book {
   @Field String title;
   @Field String description;
   @Field @DateBridge(resolution=Resolution.YEAR) Date publicationYear;
   @IndexedEmbedded Set<Author> authors = new HashSet<Author>();
}

public class Author {
   @Field String name;
   @Field String surname;
   // hashCode() and equals() omitted
}

----

 Now assuming we stored several _Book_ instances in our Infinispan _Cache_ , we can search them for any matching field as in the following example. 


----
// get the search manager from the cache:
SearchManager searchManager = org.infinispan.query.Search.getSearchManager(cache);

// create any standard Lucene query, via Lucene's QueryParser or any other means:
org.apache.lucene.search.Query fullTextQuery = //any Apache Lucene Query

// convert the Lucene query to a CacheQuery:
CacheQuery cacheQuery = searchManager.getQuery( fullTextQuery );

// get the results:
List<Object> found = cacheQuery.list();


----

 A Lucene Query is often created by parsing a query in text format such as "title:infinispan AND authors.name:sanne", or by using the query builder provided by Hibernate Search. 


----
// get the search manager from the cache:
SearchManager searchManager = org.infinispan.query.Search.getSearchManager( cache );

// you could make the queries via Lucene APIs, or use some helpers:
QueryBuilder queryBuilder = searchManager.buildQueryBuilderForClass( Book.class ).get();

// the queryBuilder has a nice fluent API which guides you through all options.
// this has some knowledge about your object, for example which Analyzers
// need to be applied, but the output is a failry standard Lucene Query.
org.apache.lucene.search.Query luceneQuery = queryBuilder.phrase()
                  .onField( "description" )
                  .andField( "title" )
                  .sentence( "a book on highly scalable query engines" )
                  .createQuery();

// the query API itself accepts any Lucene Query, and on top of that
// you can restrict the result to selected class types:
CacheQuery query = searchManager.getQuery( luceneQuery, Book.class );

// and there are your results!
List<Book> objectList = query.list();

for ( Book book : objectList ) {
      System.out.println( book.getTitle() );
}

----

 A part from _list()_ you have the option for streaming results, or use pagination. 

This barely scratches the surface of all what is possible to do: see the Hibernate Search reference documentation to learn about sorting, numeric fields, declarative filters, caching filters, complex object graph indexing, custom types and the powerfull faceting search API.

[[sid-18645131_QueryingInfinispan-NotabledifferenceswithHibernateSearch]]


==== Notable differences with Hibernate Search

 Using _@DocumentId_ to mark a field as identifier is not supported; instead all _@Indexed_ objects should also be marked with _@ProvidedId_ : Infinispan will provide the identifier, which is the key used to store each value in the cache. 

[[sid-18645131_QueryingInfinispan-ConfigurationviaXML]]


=== Configuration via XML

 To enable indexing via XML, you need to add the &lt;indexing ... /&gt; element to your cache configuration, and optionally pass additional properties to the embedded Hibernate Search engine: 


----
<?xml version="1.0" encoding="UTF-8"?>
<infinispan
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="urn:infinispan:config:5.1 http://www.infinispan.org/schemas/infinispan-config-5.1.xsd"
      xmlns="urn:infinispan:config:5.1">
   <default>
      <indexing enabled="true" indexLocalOnly="true">
         <properties>
            <property name="hibernate.search.default.directory_provider" value="ram" />
         </properties>
      </indexing>
   </default>
</infinispan>

----

 In this example the index is stored in memory, so when this nodes is shutdown the index is lost: good for a quick demo, but in real world cases you'll want to use the default (store on filesystem) or store the index in Infinispan as well. For the complete reference of properties to define, refer to the link:$$http://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/#search-configuration$$[Hibernate Search documentation] . 

[[sid-18645131_QueryingInfinispan-Usingprogrammaticconfigurationandindexmapping]]


=== Using programmatic configuration and index mapping

 In the following example we start Infinispan programmatically, avoiding XML configuration files, and also map an object _Author_ which is to be stored in the grid and made searchable on two properties but without annotating the class. 


----

SearchMapping mapping = new SearchMapping();
mapping.entity(Author.class).indexed().providedId()
      .property("name", ElementType.METHOD).field()
      .property("surname", ElementType.METHOD).field();

Properties properties = new Properties();
properties.put(org.hibernate.search.Environment.MODEL_MAPPING, mapping);
properties.put("hibernate.search.[other options]", "[...]");

Configuration infinispanConfiguration = new ConfigurationBuilder()
      .indexing()
         .enable()
         .indexLocalOnly(true)
         .withProperties(properties)
      .build();

DefaultCacheManager cacheManager = new DefaultCacheManager(infinispanConfiguration);

Cache<Long, Author> cache = cacheManager.getCache();
SearchManager sm = Search.getSearchManager(cache);

Author author = new Author(1, "Manik", "Surtani");
cache.put(author.getId(), author);

QueryBuilder qb = sm.buildQueryBuilderForClass(Author.class).get();
Query q = qb.keyword().onField("name").matching("Manik").createQuery();
CacheQuery cq = sm.getQuery(q, Author.class);
Assert.assertEquals(cq.getResultSize(), 1);

----

[[sid-18645131_QueryingInfinispan-Cachemodesandmanagingindexes]]


=== Cache modes and managing indexes

Index management is currently controlled by the Configuration.setIndexLocalOnly() setter, or the &lt;indexing indexLocalOnly="true" /&gt; XML element. If you set this to true, only modifications made locally on each node are considered in indexing. Otherwise, remote changes are considered too.

 Regarding actually configuring a Lucene directory, please refer to the link:$$http://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/#search-configuration$$[Hibernate Search documentation] on how to pass in the appropriate Lucene configuration via the Properties object passed to QueryHelper. 

[[sid-18645131_QueryingInfinispan-LOCAL]]


==== LOCAL

In local mode, you may use any Lucene Directory implementation. And it doesn't matter what you set indexLocalOnly to.

[[sid-18645131_QueryingInfinispan-REPLICATION]]


==== REPLICATION

 In replication mode, each node can have it's own local copy of the index. So indexes can either be stored locally on each node (RAMDirectory, FSDirectory, etc) but you need to set _indexLocalOnly_ to _false_ , so that each node will apply needed updates it receives from other nodes in addition to the updates started locally. Any Directory implementation can be used, but you have to make sure that when a new node is started it receives an up to date copy of the index; typically rsync is well suited for this task, but being an external operation you might end up with a slightly out-of-sync index, especially if updates are very frequent. 

 Alternately, if you use some form of shared storage for indexes (see _Sharing the Index_ ), you then have to set _indexLocalOnly_ to _true_ so that each node will apply only the changes originated locally; in this case there's no risk in having an out-of-sync index, but to avoid write contention on the index you should make sure that a single node is "in charge" of updating the index. Again, the Hibernate Search reference documentation describes means to use link:$$http://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/#jms-backend$$[a JMS queue] or link:$$http://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/#jgroups-backend$$[JGroups] to send indexing tasks to a master node. 

The diagram below shows a replicated deployment, in which each node has a local index.

 
.TODO InformalFigure image title empty
image::[]

 

[[sid-18645131_QueryingInfinispan-DISTRIBUTIONandINVALIDATION]]


==== DISTRIBUTION and INVALIDATION

 For these 2 cache modes, you _need_ to use a shared index and set indexLocalOnly to true. In future, we will be able to deal with truly distributed queries, but that would be after link:$$https://jira.jboss.org/jira/browse/ISPN-200$$[ISPN-200] . 

The diagram below shows a deployment with a shared index. Note that while not mandatory, a shared index can be used for replicated (vs. distributed) caches as well.

 
.TODO InformalFigure image title empty
image::[]

 

[[sid-18645131_QueryingInfinispan-SharingtheIndex]]


==== Sharing the Index

The most simple way to share an index is to use some form of shared storage for the indexes, like an FSDirectory on a shared disk; however this form is problematic as the FSDirectory relies on specific locking semantics which are often incompletely implemented on network filesystems, or not reliable enough; if you go for this approach make sure to search for potential problems on the Lucene mailing lists for other experiences and workarounds. Good luck, test well.

 There are many alternative Directory implementations you can find, one of the most suited approaches when working with Infinispan is of course to store the index in an Infinispan cache: have a look at the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737047$$[InfinispanDirectoryProvider] , as all Infinispan based layers it can be combined with persistent CacheLoaders to keep the index on a shared filesystem withouth the locking issues, or alternatively in a database, cloud storage, or any other CacheLoader implementation; you could backup the index in the same store used to backup your values. 

 For full documentation on clustering the Lucene engine, refer to the link:$$http://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/#search-configuration$$[Hibernate Search documentation] to properly configure it clustered. 

[[sid-18645131_QueryingInfinispan-ClusteringtheIndexinInfinispan]]


==== Clustering the Index in Infinispan

 Again the configuration details are in the Hibernate Search reference, in particular in the link:$$http://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/#infinispan-directories$$[infinispan-directories] section. This backend will by default start a secondary Infinispan CacheManager, and optionally take another Infinispan configuration file: don't reuse the same configuration or you will start grids recursively! It is currently not possible to share the same CacheManager. 

[[sid-18645132]]


=== Infinispan Query v.4

 This document is only relevant to the technology preview of Infinispan Query before version 5, as the API changed. Information about the latest version is link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737030$$[here] . 

[[sid-18645132_InfinispanQueryv.4-Theinfinispanquerymodule]]


==== The infinispan-query module

 This module adds querying capabilities to Infinispan. It uses link:$$https://www.hibernate.org/410.html$$[Hibernate Search] and link:$$http://lucene.apache.org/java/docs/index.html$$[Apache Lucene] to index and search objects in the cache. It allows users to obtain objects within the cache without needing to know the keys to each object that they want to obtain, so you can now search your objects basing on some of it's properties, for example to retrieve all red cars (exact metadata match), or all books about a specific topic (full text search and relevance scoring). 

[[sid-18645132_InfinispanQueryv.4-UsagewithInfinispan4]]


===== Usage with Infinispan 4

Indexing must be enabled in the configuration of the Infinispan cache.

[[sid-18645132_InfinispanQueryv.4-ConfigurationviaXML]]


==== Configuration via XML

To enable indexing via XML, you need to add the &lt;indexing ... /&gt; element to your &lt;namedCache ... /&gt; or &lt;default ... /&gt; section:


----
<infinispan>
     <default>
          <indexing enabled="true" indexLocalOnly="false" />
     </default>
</infinispan>

----

You still need to use the QueryHelper (see code example below) to specify the class types you wish to index.  This is transparent to you in Infinispan 5.

[[sid-18645132_InfinispanQueryv.4-SamplecodewithInfinispan4howdoIenableandusetheQueryAPI%3F]]


==== Sample code with Infinispan 4 - how do I enable and use the Query API?


----
import org.infinispan.Cache;
import org.infinispan.config.Configuration;
import org.infinispan.manager.DefaultCacheManager;
import org.infinispan.query.CacheQuery;
import org.infinispan.query.QueryFactory;
import org.infinispan.query.QueryIterator;
import org.infinispan.query.backend.QueryHelper;

import java.util.List;
import java.util.Properties;

public class MyFirstQueryClass  {

  public void queryMyCache()  {
    
     Configuration cfg = new Configuration();
     cfg.setIndexingEnabled(true);
     // set any other configuration attributes you may need
     // alternatively, you could configure this using XML

     Cache c = new DefaultCacheManager(cfg).getCache();

     // The QueryHelper must be instantiated before putting objects into the cache.
     QueryHelper qh = new QueryHelper(c, new Properties(), myClassToQuery.class);

     // Let's say I have a separate method that puts a bunch of things in the cache as per normal.
     putStuffInCache();

     // When I want to query objects in the cache, I will create a QueryFactory.
     QueryFactory qf = new QueryFactory(c, qh);

     // Let's say I'm searching on a field called "name" and looking for "John".    
     CacheQuery cq = qf.getBasicQuery("name", "John");

     // Now I can put all my hits into a list!
     List found = cq.list();

     // I can also just get the number of hits that I have. This is cheap as it
     // doesn't load objects from the cache.
     int hits = cq.getResultSize();
    
     // The CacheQuery interface has 2 kinds of iterators. They both implement the same interface but
     // have different implementations under the hood. One loads all hits from the cache first and the
     // other on the fly. They both implement the QueryIterator interface.
     QueryIterator eagerIterator = cq.iterator();
     QueryIterator lazyIterator = cq.lazyIterator();

     // From here, there are various other API methods on the interface.
     // For example, I can pick out the first and last elements of all my hits.
     eagerIterator.first();
     Object first = eagerIterator.next();

     lazyIterator.last();
     Object last = lazyIterator.previous();
  }
}
----

[[sid-18645132_InfinispanQueryv.4-LoggingDependency]]


==== Logging Dependency

The query module uses Hibernate Search which in turn uses SLF4J as logging framework. This framework expects users to decide which SLF4J logging implementation they want use, either log4j, jdk...etc. Neither Hibernate Search nor the Infinispan query module make any assumptions which means that if you haven't chosen any implementations, when you start your query module based app, you'll get an exception like this:


----
Exception in thread "pool-1-thread-1" java.lang.NoClassDefFoundError: org/slf4j/impl/StaticLoggerBinder
    at org.slf4j.LoggerFactory.getSingleton(LoggerFactory.java:223)
    at org.slf4j.LoggerFactory.bind(LoggerFactory.java:120)
    at org.slf4j.LoggerFactory.performInitialization(LoggerFactory.java:111)
    at org.slf4j.LoggerFactory.getILoggerFactory(LoggerFactory.java:269)
    at org.slf4j.LoggerFactory.getLogger(LoggerFactory.java:242)
    at org.hibernate.search.util.LoggerFactory.make(LoggerFactory.java:38)
    at org.hibernate.search.Version.<clinit>(Version.java:40)
    at org.hibernate.search.impl.SearchFactoryImpl.<clinit>(SearchFactoryImpl.java:102)
    at org.infinispan.query.backend.QueryHelper.<init>(QueryHelper.java:104)
    at org.infinispan.demo.InfinispanDemo$10.run(InfinispanDemo.java:377)
    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
    at java.lang.Thread.run(Thread.java:619)
Caused by: java.lang.ClassNotFoundException: org.slf4j.impl.StaticLoggerBinder
    at java.net.URLClassLoader$1.run(URLClassLoader.java:202)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:307)
    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:248)
    ... 13 more

----

 To get around it, make sure you select a SLF4J implementation and add the corresponding dependency. For example: 


----
<dependency>
   <groupId>org.slf4j</groupId>
   <artifactId>slf4j-log4j12</artifactId>
   <version>1.5.8</version>
</dependency>

----

Infinispan versions 5.x use JBoss Logging, which will pick a logger without throwing exceptions.

[[sid-18645132_InfinispanQueryv.4-NotabledifferenceswithHibernateSearch]]


===== Notable differences with Hibernate Search

 Using _@DocumentId_ to mark a field as identifier is not supported; instead all _@Indexed_ objects should also be marked with _@ProvidedId_ : Infinispan will provide the identifier, which is the key used to store each value in the cache. 

